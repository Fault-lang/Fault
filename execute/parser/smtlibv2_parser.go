// Code generated from SMTLIBv2.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // SMTLIBv2

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SMTLIBv2Parser struct {
	*antlr.BaseParser
}

var SMTLIBv2ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func smtlibv2ParserInit() {
	staticData := &SMTLIBv2ParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'('", "')'", "';'", "", "", "'not'", "'Bool'", "'continued-execution'",
		"'error'", "'false'", "'immediate-exit'", "'incomplete'", "'logic'",
		"'memout'", "'sat'", "'success'", "'theory'", "'true'", "'unknown'",
		"'unsupported'", "'unsat'", "'assert'", "'check-sat'", "'check-sat-assuming'",
		"'declare-const'", "'declare-datatype'", "'declare-datatypes'", "'declare-fun'",
		"'declare-sort'", "'define-fun'", "'define-fun-rec'", "'define-funs-rec'",
		"'define-sort'", "'echo'", "'exit'", "'get-assertions'", "'get-assignment'",
		"'get-info'", "'get-model'", "'get-option'", "'get-proof'", "'get-unsat-assumptions'",
		"'get-unsat-core'", "'get-value'", "'pop'", "'push'", "'reset'", "'reset-assertions'",
		"'set-info'", "'set-logic'", "'set-option'", "'!'", "'_'", "'as'", "'BINARY'",
		"'DECIMAL'", "'exists'", "'HEXADECIMAL'", "'forall'", "'let'", "'match'",
		"'NUMERAL'", "'par'", "'string'", "", "", "", "", "':'", "':all-statistics'",
		"':assertion-stack-levels'", "':authors'", "':category'", "':chainable'",
		"':definition'", "':diagnostic-output-channel'", "':error-behavior'",
		"':extensions'", "':funs'", "':funs-description'", "':global-declarations'",
		"':interactive-mode'", "':language'", "':left-assoc'", "':license'",
		"':named'", "':name'", "':notes'", "':pattern'", "':print-success'",
		"':produce-assertions'", "':produce-assignments'", "':produce-models'",
		"':produce-proofs'", "':produce-unsat-assumptions'", "':produce-unsat-cores'",
		"':random-seed'", "':reason-unknown'", "':regular-output-channel'",
		"':reproducible-resource-limit'", "':right-assoc'", "':smt-lib-version'",
		"':sorts'", "':sorts-description'", "':source'", "':status'", "':theories'",
		"':values'", "':verbosity'", "':version'", "'model'",
	}
	staticData.SymbolicNames = []string{
		"", "Comment", "ParOpen", "ParClose", "Semicolon", "String_", "QuotedSymbol",
		"PS_Not", "PS_Bool", "PS_ContinuedExecution", "PS_Error", "PS_False",
		"PS_ImmediateExit", "PS_Incomplete", "PS_Logic", "PS_Memout", "PS_Sat",
		"PS_Success", "PS_Theory", "PS_True", "PS_Unknown", "PS_Unsupported",
		"PS_Unsat", "CMD_Assert", "CMD_CheckSat", "CMD_CheckSatAssuming", "CMD_DeclareConst",
		"CMD_DeclareDatatype", "CMD_DeclareDatatypes", "CMD_DeclareFun", "CMD_DeclareSort",
		"CMD_DefineFun", "CMD_DefineFunRec", "CMD_DefineFunsRec", "CMD_DefineSort",
		"CMD_Echo", "CMD_Exit", "CMD_GetAssertions", "CMD_GetAssignment", "CMD_GetInfo",
		"CMD_GetModel", "CMD_GetOption", "CMD_GetProof", "CMD_GetUnsatAssumptions",
		"CMD_GetUnsatCore", "CMD_GetValue", "CMD_Pop", "CMD_Push", "CMD_Reset",
		"CMD_ResetAssertions", "CMD_SetInfo", "CMD_SetLogic", "CMD_SetOption",
		"GRW_Exclamation", "GRW_Underscore", "GRW_As", "GRW_Binary", "GRW_Decimal",
		"GRW_Exists", "GRW_Hexadecimal", "GRW_Forall", "GRW_Let", "GRW_Match",
		"GRW_Numeral", "GRW_Par", "GRW_String", "Numeral", "Binary", "HexDecimal",
		"Decimal", "Colon", "PK_AllStatistics", "PK_AssertionStackLevels", "PK_Authors",
		"PK_Category", "PK_Chainable", "PK_Definition", "PK_DiagnosticOutputChannel",
		"PK_ErrorBehaviour", "PK_Extension", "PK_Funs", "PK_FunsDescription",
		"PK_GlobalDeclarations", "PK_InteractiveMode", "PK_Language", "PK_LeftAssoc",
		"PK_License", "PK_Named", "PK_Name", "PK_Notes", "PK_Pattern", "PK_PrintSuccess",
		"PK_ProduceAssertions", "PK_ProduceAssignments", "PK_ProduceModels",
		"PK_ProduceProofs", "PK_ProduceUnsatAssumptions", "PK_ProduceUnsatCores",
		"PK_RandomSeed", "PK_ReasonUnknown", "PK_RegularOutputChannel", "PK_ReproducibleResourceLimit",
		"PK_RightAssoc", "PK_SmtLibVersion", "PK_Sorts", "PK_SortsDescription",
		"PK_Source", "PK_Status", "PK_Theories", "PK_Values", "PK_Verbosity",
		"PK_Version", "RS_Model", "UndefinedSymbol", "WS",
	}
	staticData.RuleNames = []string{
		"start", "generalReservedWord", "simpleSymbol", "quotedSymbol", "predefSymbol",
		"predefKeyword", "symbol", "numeral", "decimal", "hexadecimal", "binary",
		"string_", "keyword", "spec_constant", "s_expr", "index", "identifier",
		"attribute_value", "attribute", "sort", "qual_identifer", "var_binding",
		"sorted_var", "pattern", "match_case", "variable", "term", "sort_symbol_decl",
		"meta_spec_constant", "fun_symbol_decl", "par_fun_symbol_decl", "theory_attribute",
		"theory_decl", "logic_attribue", "logic", "sort_dec", "selector_dec",
		"constructor_dec", "datatype_dec", "function_dec", "function_def", "prop_literal",
		"script", "cmd_assert", "cmd_checkSat", "cmd_checkSatAssuming", "cmd_declareConst",
		"cmd_declareDatatype", "cmd_declareDatatypes", "cmd_declareFun", "cmd_declareSort",
		"cmd_defineFun", "cmd_defineFunRec", "cmd_defineFunsRec", "cmd_defineSort",
		"cmd_echo", "cmd_exit", "cmd_getAssertions", "cmd_getAssignment", "cmd_getInfo",
		"cmd_getModel", "cmd_getOption", "cmd_getProof", "cmd_getUnsatAssumptions",
		"cmd_getUnsatCore", "cmd_getValue", "cmd_pop", "cmd_push", "cmd_reset",
		"cmd_resetAssertions", "cmd_setInfo", "cmd_setLogic", "cmd_setOption",
		"command", "b_value", "option", "info_flag", "error_behaviour", "reason_unknown",
		"model_response", "info_response", "valuation_pair", "t_valuation_pair",
		"check_sat_response", "echo_response", "get_assertions_response", "get_assignment_response",
		"get_info_response", "get_model_response", "get_option_response", "get_proof_response",
		"get_unsat_assump_response", "get_unsat_core_response", "get_value_response",
		"specific_success_response", "general_response",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 114, 1105, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
		0, 1, 0, 1, 0, 1, 0, 3, 0, 205, 8, 0, 1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 211,
		8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6, 221, 8, 6,
		1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 12,
		1, 12, 1, 12, 3, 12, 236, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3,
		13, 243, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 250, 8, 14, 10,
		14, 12, 14, 253, 9, 14, 1, 14, 3, 14, 256, 8, 14, 1, 15, 1, 15, 3, 15,
		260, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 4, 16, 267, 8, 16, 11, 16,
		12, 16, 268, 1, 16, 1, 16, 3, 16, 273, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17,
		5, 17, 279, 8, 17, 10, 17, 12, 17, 282, 9, 17, 1, 17, 3, 17, 285, 8, 17,
		1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 291, 8, 18, 1, 19, 1, 19, 1, 19, 1,
		19, 4, 19, 297, 8, 19, 11, 19, 12, 19, 298, 1, 19, 1, 19, 3, 19, 303, 8,
		19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 312, 8, 20,
		1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		23, 1, 23, 1, 23, 1, 23, 4, 23, 328, 8, 23, 11, 23, 12, 23, 329, 1, 23,
		1, 23, 3, 23, 334, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 4, 26, 348, 8, 26, 11, 26, 12, 26,
		349, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 4, 26, 358, 8, 26, 11, 26,
		12, 26, 359, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 4,
		26, 370, 8, 26, 11, 26, 12, 26, 371, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 4, 26, 382, 8, 26, 11, 26, 12, 26, 383, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 4, 26, 395, 8, 26,
		11, 26, 12, 26, 396, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 4,
		26, 406, 8, 26, 11, 26, 12, 26, 407, 1, 26, 1, 26, 3, 26, 412, 8, 26, 1,
		27, 1, 27, 1, 27, 1, 27, 5, 27, 418, 8, 27, 10, 27, 12, 27, 421, 9, 27,
		1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 431, 8,
		29, 10, 29, 12, 29, 434, 9, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		5, 29, 442, 8, 29, 10, 29, 12, 29, 445, 9, 29, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 4, 29, 452, 8, 29, 11, 29, 12, 29, 453, 1, 29, 5, 29, 457, 8,
		29, 10, 29, 12, 29, 460, 9, 29, 1, 29, 1, 29, 3, 29, 464, 8, 29, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 4, 30, 471, 8, 30, 11, 30, 12, 30, 472, 1,
		30, 1, 30, 1, 30, 1, 30, 4, 30, 479, 8, 30, 11, 30, 12, 30, 480, 1, 30,
		5, 30, 484, 8, 30, 10, 30, 12, 30, 487, 9, 30, 1, 30, 1, 30, 1, 30, 3,
		30, 492, 8, 30, 1, 31, 1, 31, 1, 31, 4, 31, 497, 8, 31, 11, 31, 12, 31,
		498, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 4, 31, 506, 8, 31, 11, 31, 12,
		31, 507, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 523, 8, 31, 1, 32, 1, 32, 1, 32, 1,
		32, 4, 32, 529, 8, 32, 11, 32, 12, 32, 530, 1, 32, 1, 32, 1, 33, 1, 33,
		1, 33, 4, 33, 538, 8, 33, 11, 33, 12, 33, 539, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 553, 8, 33,
		1, 34, 1, 34, 1, 34, 1, 34, 4, 34, 559, 8, 34, 11, 34, 12, 34, 560, 1,
		34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 37, 1, 37, 1, 37, 5, 37, 578, 8, 37, 10, 37, 12, 37, 581, 9,
		37, 1, 37, 1, 37, 1, 38, 1, 38, 4, 38, 587, 8, 38, 11, 38, 12, 38, 588,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 4, 38, 597, 8, 38, 11, 38, 12,
		38, 598, 1, 38, 1, 38, 1, 38, 4, 38, 604, 8, 38, 11, 38, 12, 38, 605, 1,
		38, 1, 38, 1, 38, 3, 38, 611, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 5, 39,
		617, 8, 39, 10, 39, 12, 39, 620, 9, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		40, 1, 40, 1, 40, 5, 40, 629, 8, 40, 10, 40, 12, 40, 632, 9, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 644,
		8, 41, 1, 42, 5, 42, 647, 8, 42, 10, 42, 12, 42, 650, 9, 42, 1, 43, 1,
		43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 5, 45, 660, 8, 45, 10, 45,
		12, 45, 663, 9, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 4, 48, 678, 8, 48, 11, 48, 12, 48,
		679, 1, 48, 1, 48, 1, 48, 4, 48, 685, 8, 48, 11, 48, 12, 48, 686, 1, 48,
		1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 695, 8, 49, 10, 49, 12, 49, 698,
		9, 49, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1,
		51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 4, 53, 716, 8, 53, 11, 53,
		12, 53, 717, 1, 53, 1, 53, 1, 53, 4, 53, 723, 8, 53, 11, 53, 12, 53, 724,
		1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 733, 8, 54, 10, 54, 12,
		54, 736, 9, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56,
		1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61, 1,
		61, 1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65,
		4, 65, 767, 8, 65, 11, 65, 12, 65, 768, 1, 65, 1, 65, 1, 66, 1, 66, 1,
		66, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70,
		1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		3, 73, 912, 8, 73, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 3, 75, 945, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76,
		1, 76, 1, 76, 1, 76, 3, 76, 955, 8, 76, 1, 77, 1, 77, 1, 78, 1, 78, 1,
		78, 3, 78, 962, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79,
		1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 976, 8, 79, 1, 80, 1, 80, 1,
		80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80,
		3, 80, 991, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 84, 1, 84, 1, 85, 1, 85, 5, 85, 1009,
		8, 85, 10, 85, 12, 85, 1012, 9, 85, 1, 85, 1, 85, 1, 86, 1, 86, 5, 86,
		1018, 8, 86, 10, 86, 12, 86, 1021, 9, 86, 1, 86, 1, 86, 1, 87, 1, 87, 4,
		87, 1027, 8, 87, 11, 87, 12, 87, 1028, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88,
		5, 88, 1036, 8, 88, 10, 88, 12, 88, 1039, 9, 88, 1, 88, 1, 88, 1, 88, 5,
		88, 1044, 8, 88, 10, 88, 12, 88, 1047, 9, 88, 1, 88, 3, 88, 1050, 8, 88,
		1, 89, 1, 89, 1, 90, 1, 90, 1, 91, 1, 91, 5, 91, 1058, 8, 91, 10, 91, 12,
		91, 1061, 9, 91, 1, 91, 1, 91, 1, 92, 1, 92, 5, 92, 1067, 8, 92, 10, 92,
		12, 92, 1070, 9, 92, 1, 92, 1, 92, 1, 93, 1, 93, 4, 93, 1076, 8, 93, 11,
		93, 12, 93, 1077, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1093, 8, 94, 1, 95, 1, 95, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1103, 8, 95, 1, 95, 0, 0,
		96, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
		72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 0, 7,
		2, 0, 53, 65, 112, 112, 1, 0, 7, 22, 1, 0, 71, 111, 3, 0, 57, 57, 63, 63,
		65, 65, 2, 0, 11, 11, 19, 19, 2, 0, 9, 9, 12, 12, 3, 0, 16, 16, 20, 20,
		22, 22, 1174, 0, 204, 1, 0, 0, 0, 2, 206, 1, 0, 0, 0, 4, 210, 1, 0, 0,
		0, 6, 212, 1, 0, 0, 0, 8, 214, 1, 0, 0, 0, 10, 216, 1, 0, 0, 0, 12, 220,
		1, 0, 0, 0, 14, 222, 1, 0, 0, 0, 16, 224, 1, 0, 0, 0, 18, 226, 1, 0, 0,
		0, 20, 228, 1, 0, 0, 0, 22, 230, 1, 0, 0, 0, 24, 235, 1, 0, 0, 0, 26, 242,
		1, 0, 0, 0, 28, 255, 1, 0, 0, 0, 30, 259, 1, 0, 0, 0, 32, 272, 1, 0, 0,
		0, 34, 284, 1, 0, 0, 0, 36, 290, 1, 0, 0, 0, 38, 302, 1, 0, 0, 0, 40, 311,
		1, 0, 0, 0, 42, 313, 1, 0, 0, 0, 44, 318, 1, 0, 0, 0, 46, 333, 1, 0, 0,
		0, 48, 335, 1, 0, 0, 0, 50, 340, 1, 0, 0, 0, 52, 411, 1, 0, 0, 0, 54, 413,
		1, 0, 0, 0, 56, 424, 1, 0, 0, 0, 58, 463, 1, 0, 0, 0, 60, 491, 1, 0, 0,
		0, 62, 522, 1, 0, 0, 0, 64, 524, 1, 0, 0, 0, 66, 552, 1, 0, 0, 0, 68, 554,
		1, 0, 0, 0, 70, 564, 1, 0, 0, 0, 72, 569, 1, 0, 0, 0, 74, 574, 1, 0, 0,
		0, 76, 610, 1, 0, 0, 0, 78, 612, 1, 0, 0, 0, 80, 625, 1, 0, 0, 0, 82, 643,
		1, 0, 0, 0, 84, 648, 1, 0, 0, 0, 86, 651, 1, 0, 0, 0, 88, 654, 1, 0, 0,
		0, 90, 656, 1, 0, 0, 0, 92, 666, 1, 0, 0, 0, 94, 670, 1, 0, 0, 0, 96, 674,
		1, 0, 0, 0, 98, 690, 1, 0, 0, 0, 100, 702, 1, 0, 0, 0, 102, 706, 1, 0,
		0, 0, 104, 709, 1, 0, 0, 0, 106, 712, 1, 0, 0, 0, 108, 728, 1, 0, 0, 0,
		110, 740, 1, 0, 0, 0, 112, 743, 1, 0, 0, 0, 114, 745, 1, 0, 0, 0, 116,
		747, 1, 0, 0, 0, 118, 749, 1, 0, 0, 0, 120, 752, 1, 0, 0, 0, 122, 754,
		1, 0, 0, 0, 124, 757, 1, 0, 0, 0, 126, 759, 1, 0, 0, 0, 128, 761, 1, 0,
		0, 0, 130, 763, 1, 0, 0, 0, 132, 772, 1, 0, 0, 0, 134, 775, 1, 0, 0, 0,
		136, 778, 1, 0, 0, 0, 138, 780, 1, 0, 0, 0, 140, 782, 1, 0, 0, 0, 142,
		785, 1, 0, 0, 0, 144, 788, 1, 0, 0, 0, 146, 911, 1, 0, 0, 0, 148, 913,
		1, 0, 0, 0, 150, 944, 1, 0, 0, 0, 152, 954, 1, 0, 0, 0, 154, 956, 1, 0,
		0, 0, 156, 961, 1, 0, 0, 0, 158, 975, 1, 0, 0, 0, 160, 990, 1, 0, 0, 0,
		162, 992, 1, 0, 0, 0, 164, 997, 1, 0, 0, 0, 166, 1002, 1, 0, 0, 0, 168,
		1004, 1, 0, 0, 0, 170, 1006, 1, 0, 0, 0, 172, 1015, 1, 0, 0, 0, 174, 1024,
		1, 0, 0, 0, 176, 1049, 1, 0, 0, 0, 178, 1051, 1, 0, 0, 0, 180, 1053, 1,
		0, 0, 0, 182, 1055, 1, 0, 0, 0, 184, 1064, 1, 0, 0, 0, 186, 1073, 1, 0,
		0, 0, 188, 1092, 1, 0, 0, 0, 190, 1102, 1, 0, 0, 0, 192, 193, 3, 68, 34,
		0, 193, 194, 5, 0, 0, 1, 194, 205, 1, 0, 0, 0, 195, 196, 3, 64, 32, 0,
		196, 197, 5, 0, 0, 1, 197, 205, 1, 0, 0, 0, 198, 199, 3, 84, 42, 0, 199,
		200, 5, 0, 0, 1, 200, 205, 1, 0, 0, 0, 201, 202, 3, 190, 95, 0, 202, 203,
		5, 0, 0, 1, 203, 205, 1, 0, 0, 0, 204, 192, 1, 0, 0, 0, 204, 195, 1, 0,
		0, 0, 204, 198, 1, 0, 0, 0, 204, 201, 1, 0, 0, 0, 205, 1, 1, 0, 0, 0, 206,
		207, 7, 0, 0, 0, 207, 3, 1, 0, 0, 0, 208, 211, 3, 8, 4, 0, 209, 211, 5,
		113, 0, 0, 210, 208, 1, 0, 0, 0, 210, 209, 1, 0, 0, 0, 211, 5, 1, 0, 0,
		0, 212, 213, 5, 6, 0, 0, 213, 7, 1, 0, 0, 0, 214, 215, 7, 1, 0, 0, 215,
		9, 1, 0, 0, 0, 216, 217, 7, 2, 0, 0, 217, 11, 1, 0, 0, 0, 218, 221, 3,
		4, 2, 0, 219, 221, 3, 6, 3, 0, 220, 218, 1, 0, 0, 0, 220, 219, 1, 0, 0,
		0, 221, 13, 1, 0, 0, 0, 222, 223, 5, 66, 0, 0, 223, 15, 1, 0, 0, 0, 224,
		225, 5, 69, 0, 0, 225, 17, 1, 0, 0, 0, 226, 227, 5, 68, 0, 0, 227, 19,
		1, 0, 0, 0, 228, 229, 5, 67, 0, 0, 229, 21, 1, 0, 0, 0, 230, 231, 5, 5,
		0, 0, 231, 23, 1, 0, 0, 0, 232, 236, 3, 10, 5, 0, 233, 234, 5, 70, 0, 0,
		234, 236, 3, 4, 2, 0, 235, 232, 1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 236,
		25, 1, 0, 0, 0, 237, 243, 3, 14, 7, 0, 238, 243, 3, 16, 8, 0, 239, 243,
		3, 18, 9, 0, 240, 243, 3, 20, 10, 0, 241, 243, 3, 22, 11, 0, 242, 237,
		1, 0, 0, 0, 242, 238, 1, 0, 0, 0, 242, 239, 1, 0, 0, 0, 242, 240, 1, 0,
		0, 0, 242, 241, 1, 0, 0, 0, 243, 27, 1, 0, 0, 0, 244, 256, 3, 26, 13, 0,
		245, 256, 3, 12, 6, 0, 246, 256, 3, 24, 12, 0, 247, 251, 5, 2, 0, 0, 248,
		250, 3, 28, 14, 0, 249, 248, 1, 0, 0, 0, 250, 253, 1, 0, 0, 0, 251, 249,
		1, 0, 0, 0, 251, 252, 1, 0, 0, 0, 252, 254, 1, 0, 0, 0, 253, 251, 1, 0,
		0, 0, 254, 256, 5, 3, 0, 0, 255, 244, 1, 0, 0, 0, 255, 245, 1, 0, 0, 0,
		255, 246, 1, 0, 0, 0, 255, 247, 1, 0, 0, 0, 256, 29, 1, 0, 0, 0, 257, 260,
		3, 14, 7, 0, 258, 260, 3, 12, 6, 0, 259, 257, 1, 0, 0, 0, 259, 258, 1,
		0, 0, 0, 260, 31, 1, 0, 0, 0, 261, 273, 3, 12, 6, 0, 262, 263, 5, 2, 0,
		0, 263, 264, 5, 54, 0, 0, 264, 266, 3, 12, 6, 0, 265, 267, 3, 30, 15, 0,
		266, 265, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 266, 1, 0, 0, 0, 268,
		269, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270, 271, 5, 3, 0, 0, 271, 273,
		1, 0, 0, 0, 272, 261, 1, 0, 0, 0, 272, 262, 1, 0, 0, 0, 273, 33, 1, 0,
		0, 0, 274, 285, 3, 26, 13, 0, 275, 285, 3, 12, 6, 0, 276, 280, 5, 2, 0,
		0, 277, 279, 3, 28, 14, 0, 278, 277, 1, 0, 0, 0, 279, 282, 1, 0, 0, 0,
		280, 278, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 283, 1, 0, 0, 0, 282,
		280, 1, 0, 0, 0, 283, 285, 5, 3, 0, 0, 284, 274, 1, 0, 0, 0, 284, 275,
		1, 0, 0, 0, 284, 276, 1, 0, 0, 0, 285, 35, 1, 0, 0, 0, 286, 291, 3, 24,
		12, 0, 287, 288, 3, 24, 12, 0, 288, 289, 3, 34, 17, 0, 289, 291, 1, 0,
		0, 0, 290, 286, 1, 0, 0, 0, 290, 287, 1, 0, 0, 0, 291, 37, 1, 0, 0, 0,
		292, 303, 3, 32, 16, 0, 293, 294, 5, 2, 0, 0, 294, 296, 3, 32, 16, 0, 295,
		297, 3, 38, 19, 0, 296, 295, 1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298, 296,
		1, 0, 0, 0, 298, 299, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 301, 5, 3,
		0, 0, 301, 303, 1, 0, 0, 0, 302, 292, 1, 0, 0, 0, 302, 293, 1, 0, 0, 0,
		303, 39, 1, 0, 0, 0, 304, 312, 3, 32, 16, 0, 305, 306, 5, 2, 0, 0, 306,
		307, 5, 55, 0, 0, 307, 308, 3, 32, 16, 0, 308, 309, 3, 38, 19, 0, 309,
		310, 5, 3, 0, 0, 310, 312, 1, 0, 0, 0, 311, 304, 1, 0, 0, 0, 311, 305,
		1, 0, 0, 0, 312, 41, 1, 0, 0, 0, 313, 314, 5, 2, 0, 0, 314, 315, 3, 12,
		6, 0, 315, 316, 3, 52, 26, 0, 316, 317, 5, 3, 0, 0, 317, 43, 1, 0, 0, 0,
		318, 319, 5, 2, 0, 0, 319, 320, 3, 12, 6, 0, 320, 321, 3, 38, 19, 0, 321,
		322, 5, 3, 0, 0, 322, 45, 1, 0, 0, 0, 323, 334, 3, 12, 6, 0, 324, 325,
		5, 2, 0, 0, 325, 327, 3, 12, 6, 0, 326, 328, 3, 12, 6, 0, 327, 326, 1,
		0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 327, 1, 0, 0, 0, 329, 330, 1, 0, 0,
		0, 330, 331, 1, 0, 0, 0, 331, 332, 5, 3, 0, 0, 332, 334, 1, 0, 0, 0, 333,
		323, 1, 0, 0, 0, 333, 324, 1, 0, 0, 0, 334, 47, 1, 0, 0, 0, 335, 336, 5,
		2, 0, 0, 336, 337, 3, 46, 23, 0, 337, 338, 3, 52, 26, 0, 338, 339, 5, 3,
		0, 0, 339, 49, 1, 0, 0, 0, 340, 341, 3, 12, 6, 0, 341, 51, 1, 0, 0, 0,
		342, 412, 3, 26, 13, 0, 343, 412, 3, 40, 20, 0, 344, 345, 5, 2, 0, 0, 345,
		347, 3, 40, 20, 0, 346, 348, 3, 52, 26, 0, 347, 346, 1, 0, 0, 0, 348, 349,
		1, 0, 0, 0, 349, 347, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 1, 0,
		0, 0, 351, 352, 5, 3, 0, 0, 352, 412, 1, 0, 0, 0, 353, 354, 5, 2, 0, 0,
		354, 355, 5, 61, 0, 0, 355, 357, 5, 2, 0, 0, 356, 358, 3, 42, 21, 0, 357,
		356, 1, 0, 0, 0, 358, 359, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359, 360,
		1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 362, 5, 3, 0, 0, 362, 363, 3, 52,
		26, 0, 363, 364, 5, 3, 0, 0, 364, 412, 1, 0, 0, 0, 365, 366, 5, 2, 0, 0,
		366, 367, 5, 60, 0, 0, 367, 369, 5, 2, 0, 0, 368, 370, 3, 44, 22, 0, 369,
		368, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 369, 1, 0, 0, 0, 371, 372,
		1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 374, 5, 3, 0, 0, 374, 375, 3, 52,
		26, 0, 375, 376, 5, 3, 0, 0, 376, 412, 1, 0, 0, 0, 377, 378, 5, 2, 0, 0,
		378, 379, 5, 58, 0, 0, 379, 381, 5, 2, 0, 0, 380, 382, 3, 44, 22, 0, 381,
		380, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 383, 384,
		1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 386, 5, 3, 0, 0, 386, 387, 3, 52,
		26, 0, 387, 388, 5, 3, 0, 0, 388, 412, 1, 0, 0, 0, 389, 390, 5, 2, 0, 0,
		390, 391, 5, 62, 0, 0, 391, 392, 3, 52, 26, 0, 392, 394, 5, 2, 0, 0, 393,
		395, 3, 48, 24, 0, 394, 393, 1, 0, 0, 0, 395, 396, 1, 0, 0, 0, 396, 394,
		1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 399, 5, 3,
		0, 0, 399, 400, 5, 3, 0, 0, 400, 412, 1, 0, 0, 0, 401, 402, 5, 2, 0, 0,
		402, 403, 5, 53, 0, 0, 403, 405, 3, 52, 26, 0, 404, 406, 3, 36, 18, 0,
		405, 404, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 405, 1, 0, 0, 0, 407,
		408, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 410, 5, 3, 0, 0, 410, 412,
		1, 0, 0, 0, 411, 342, 1, 0, 0, 0, 411, 343, 1, 0, 0, 0, 411, 344, 1, 0,
		0, 0, 411, 353, 1, 0, 0, 0, 411, 365, 1, 0, 0, 0, 411, 377, 1, 0, 0, 0,
		411, 389, 1, 0, 0, 0, 411, 401, 1, 0, 0, 0, 412, 53, 1, 0, 0, 0, 413, 414,
		5, 2, 0, 0, 414, 415, 3, 32, 16, 0, 415, 419, 3, 14, 7, 0, 416, 418, 3,
		36, 18, 0, 417, 416, 1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0,
		0, 0, 419, 420, 1, 0, 0, 0, 420, 422, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0,
		422, 423, 5, 3, 0, 0, 423, 55, 1, 0, 0, 0, 424, 425, 7, 3, 0, 0, 425, 57,
		1, 0, 0, 0, 426, 427, 5, 2, 0, 0, 427, 428, 3, 26, 13, 0, 428, 432, 3,
		38, 19, 0, 429, 431, 3, 36, 18, 0, 430, 429, 1, 0, 0, 0, 431, 434, 1, 0,
		0, 0, 432, 430, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 435, 1, 0, 0, 0,
		434, 432, 1, 0, 0, 0, 435, 436, 5, 3, 0, 0, 436, 464, 1, 0, 0, 0, 437,
		438, 5, 2, 0, 0, 438, 439, 3, 56, 28, 0, 439, 443, 3, 38, 19, 0, 440, 442,
		3, 36, 18, 0, 441, 440, 1, 0, 0, 0, 442, 445, 1, 0, 0, 0, 443, 441, 1,
		0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 446, 1, 0, 0, 0, 445, 443, 1, 0, 0,
		0, 446, 447, 5, 3, 0, 0, 447, 464, 1, 0, 0, 0, 448, 449, 5, 2, 0, 0, 449,
		451, 3, 32, 16, 0, 450, 452, 3, 38, 19, 0, 451, 450, 1, 0, 0, 0, 452, 453,
		1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 458, 1, 0,
		0, 0, 455, 457, 3, 36, 18, 0, 456, 455, 1, 0, 0, 0, 457, 460, 1, 0, 0,
		0, 458, 456, 1, 0, 0, 0, 458, 459, 1, 0, 0, 0, 459, 461, 1, 0, 0, 0, 460,
		458, 1, 0, 0, 0, 461, 462, 5, 3, 0, 0, 462, 464, 1, 0, 0, 0, 463, 426,
		1, 0, 0, 0, 463, 437, 1, 0, 0, 0, 463, 448, 1, 0, 0, 0, 464, 59, 1, 0,
		0, 0, 465, 492, 3, 58, 29, 0, 466, 467, 5, 2, 0, 0, 467, 468, 5, 64, 0,
		0, 468, 470, 5, 2, 0, 0, 469, 471, 3, 12, 6, 0, 470, 469, 1, 0, 0, 0, 471,
		472, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 474,
		1, 0, 0, 0, 474, 475, 5, 3, 0, 0, 475, 476, 5, 2, 0, 0, 476, 478, 3, 32,
		16, 0, 477, 479, 3, 38, 19, 0, 478, 477, 1, 0, 0, 0, 479, 480, 1, 0, 0,
		0, 480, 478, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 485, 1, 0, 0, 0, 482,
		484, 3, 36, 18, 0, 483, 482, 1, 0, 0, 0, 484, 487, 1, 0, 0, 0, 485, 483,
		1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 488, 1, 0, 0, 0, 487, 485, 1, 0,
		0, 0, 488, 489, 5, 3, 0, 0, 489, 490, 5, 3, 0, 0, 490, 492, 1, 0, 0, 0,
		491, 465, 1, 0, 0, 0, 491, 466, 1, 0, 0, 0, 492, 61, 1, 0, 0, 0, 493, 494,
		5, 104, 0, 0, 494, 496, 5, 2, 0, 0, 495, 497, 3, 54, 27, 0, 496, 495, 1,
		0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0,
		0, 499, 500, 1, 0, 0, 0, 500, 501, 5, 3, 0, 0, 501, 523, 1, 0, 0, 0, 502,
		503, 5, 80, 0, 0, 503, 505, 5, 2, 0, 0, 504, 506, 3, 60, 30, 0, 505, 504,
		1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0,
		0, 0, 508, 509, 1, 0, 0, 0, 509, 510, 5, 3, 0, 0, 510, 523, 1, 0, 0, 0,
		511, 512, 5, 105, 0, 0, 512, 523, 3, 22, 11, 0, 513, 514, 5, 81, 0, 0,
		514, 523, 3, 22, 11, 0, 515, 516, 5, 76, 0, 0, 516, 523, 3, 22, 11, 0,
		517, 518, 5, 109, 0, 0, 518, 523, 3, 22, 11, 0, 519, 520, 5, 89, 0, 0,
		520, 523, 3, 22, 11, 0, 521, 523, 3, 36, 18, 0, 522, 493, 1, 0, 0, 0, 522,
		502, 1, 0, 0, 0, 522, 511, 1, 0, 0, 0, 522, 513, 1, 0, 0, 0, 522, 515,
		1, 0, 0, 0, 522, 517, 1, 0, 0, 0, 522, 519, 1, 0, 0, 0, 522, 521, 1, 0,
		0, 0, 523, 63, 1, 0, 0, 0, 524, 525, 5, 2, 0, 0, 525, 526, 5, 18, 0, 0,
		526, 528, 3, 12, 6, 0, 527, 529, 3, 62, 31, 0, 528, 527, 1, 0, 0, 0, 529,
		530, 1, 0, 0, 0, 530, 528, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 532,
		1, 0, 0, 0, 532, 533, 5, 3, 0, 0, 533, 65, 1, 0, 0, 0, 534, 535, 5, 108,
		0, 0, 535, 537, 5, 2, 0, 0, 536, 538, 3, 12, 6, 0, 537, 536, 1, 0, 0, 0,
		538, 539, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540,
		541, 1, 0, 0, 0, 541, 542, 5, 3, 0, 0, 542, 553, 1, 0, 0, 0, 543, 544,
		5, 84, 0, 0, 544, 553, 3, 22, 11, 0, 545, 546, 5, 79, 0, 0, 546, 553, 3,
		22, 11, 0, 547, 548, 5, 109, 0, 0, 548, 553, 3, 22, 11, 0, 549, 550, 5,
		89, 0, 0, 550, 553, 3, 22, 11, 0, 551, 553, 3, 36, 18, 0, 552, 534, 1,
		0, 0, 0, 552, 543, 1, 0, 0, 0, 552, 545, 1, 0, 0, 0, 552, 547, 1, 0, 0,
		0, 552, 549, 1, 0, 0, 0, 552, 551, 1, 0, 0, 0, 553, 67, 1, 0, 0, 0, 554,
		555, 5, 2, 0, 0, 555, 556, 5, 14, 0, 0, 556, 558, 3, 12, 6, 0, 557, 559,
		3, 66, 33, 0, 558, 557, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 558, 1,
		0, 0, 0, 560, 561, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 563, 5, 3, 0,
		0, 563, 69, 1, 0, 0, 0, 564, 565, 5, 2, 0, 0, 565, 566, 3, 12, 6, 0, 566,
		567, 3, 14, 7, 0, 567, 568, 5, 3, 0, 0, 568, 71, 1, 0, 0, 0, 569, 570,
		5, 2, 0, 0, 570, 571, 3, 12, 6, 0, 571, 572, 3, 38, 19, 0, 572, 573, 5,
		3, 0, 0, 573, 73, 1, 0, 0, 0, 574, 575, 5, 2, 0, 0, 575, 579, 3, 12, 6,
		0, 576, 578, 3, 72, 36, 0, 577, 576, 1, 0, 0, 0, 578, 581, 1, 0, 0, 0,
		579, 577, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 582, 1, 0, 0, 0, 581,
		579, 1, 0, 0, 0, 582, 583, 5, 3, 0, 0, 583, 75, 1, 0, 0, 0, 584, 586, 5,
		2, 0, 0, 585, 587, 3, 74, 37, 0, 586, 585, 1, 0, 0, 0, 587, 588, 1, 0,
		0, 0, 588, 586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0,
		590, 591, 5, 3, 0, 0, 591, 611, 1, 0, 0, 0, 592, 593, 5, 2, 0, 0, 593,
		594, 5, 64, 0, 0, 594, 596, 5, 2, 0, 0, 595, 597, 3, 12, 6, 0, 596, 595,
		1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 596, 1, 0, 0, 0, 598, 599, 1, 0,
		0, 0, 599, 600, 1, 0, 0, 0, 600, 601, 5, 3, 0, 0, 601, 603, 5, 2, 0, 0,
		602, 604, 3, 74, 37, 0, 603, 602, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605,
		603, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607, 608,
		5, 3, 0, 0, 608, 609, 5, 3, 0, 0, 609, 611, 1, 0, 0, 0, 610, 584, 1, 0,
		0, 0, 610, 592, 1, 0, 0, 0, 611, 77, 1, 0, 0, 0, 612, 613, 5, 2, 0, 0,
		613, 614, 3, 12, 6, 0, 614, 618, 5, 2, 0, 0, 615, 617, 3, 44, 22, 0, 616,
		615, 1, 0, 0, 0, 617, 620, 1, 0, 0, 0, 618, 616, 1, 0, 0, 0, 618, 619,
		1, 0, 0, 0, 619, 621, 1, 0, 0, 0, 620, 618, 1, 0, 0, 0, 621, 622, 5, 3,
		0, 0, 622, 623, 3, 38, 19, 0, 623, 624, 5, 3, 0, 0, 624, 79, 1, 0, 0, 0,
		625, 626, 3, 50, 25, 0, 626, 630, 5, 2, 0, 0, 627, 629, 3, 44, 22, 0, 628,
		627, 1, 0, 0, 0, 629, 632, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 631,
		1, 0, 0, 0, 631, 633, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 633, 634, 5, 3,
		0, 0, 634, 635, 3, 38, 19, 0, 635, 636, 3, 52, 26, 0, 636, 81, 1, 0, 0,
		0, 637, 644, 3, 12, 6, 0, 638, 639, 5, 2, 0, 0, 639, 640, 5, 7, 0, 0, 640,
		641, 3, 12, 6, 0, 641, 642, 5, 3, 0, 0, 642, 644, 1, 0, 0, 0, 643, 637,
		1, 0, 0, 0, 643, 638, 1, 0, 0, 0, 644, 83, 1, 0, 0, 0, 645, 647, 3, 146,
		73, 0, 646, 645, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648, 646, 1, 0, 0, 0,
		648, 649, 1, 0, 0, 0, 649, 85, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 651, 652,
		5, 23, 0, 0, 652, 653, 3, 52, 26, 0, 653, 87, 1, 0, 0, 0, 654, 655, 5,
		24, 0, 0, 655, 89, 1, 0, 0, 0, 656, 657, 5, 25, 0, 0, 657, 661, 5, 2, 0,
		0, 658, 660, 3, 82, 41, 0, 659, 658, 1, 0, 0, 0, 660, 663, 1, 0, 0, 0,
		661, 659, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 664, 1, 0, 0, 0, 663,
		661, 1, 0, 0, 0, 664, 665, 5, 3, 0, 0, 665, 91, 1, 0, 0, 0, 666, 667, 5,
		26, 0, 0, 667, 668, 3, 12, 6, 0, 668, 669, 3, 38, 19, 0, 669, 93, 1, 0,
		0, 0, 670, 671, 5, 27, 0, 0, 671, 672, 3, 12, 6, 0, 672, 673, 3, 76, 38,
		0, 673, 95, 1, 0, 0, 0, 674, 675, 5, 28, 0, 0, 675, 677, 5, 2, 0, 0, 676,
		678, 3, 70, 35, 0, 677, 676, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 677,
		1, 0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682, 5, 3,
		0, 0, 682, 684, 5, 2, 0, 0, 683, 685, 3, 76, 38, 0, 684, 683, 1, 0, 0,
		0, 685, 686, 1, 0, 0, 0, 686, 684, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687,
		688, 1, 0, 0, 0, 688, 689, 5, 3, 0, 0, 689, 97, 1, 0, 0, 0, 690, 691, 5,
		29, 0, 0, 691, 692, 3, 12, 6, 0, 692, 696, 5, 2, 0, 0, 693, 695, 3, 38,
		19, 0, 694, 693, 1, 0, 0, 0, 695, 698, 1, 0, 0, 0, 696, 694, 1, 0, 0, 0,
		696, 697, 1, 0, 0, 0, 697, 699, 1, 0, 0, 0, 698, 696, 1, 0, 0, 0, 699,
		700, 5, 3, 0, 0, 700, 701, 3, 38, 19, 0, 701, 99, 1, 0, 0, 0, 702, 703,
		5, 30, 0, 0, 703, 704, 3, 12, 6, 0, 704, 705, 3, 14, 7, 0, 705, 101, 1,
		0, 0, 0, 706, 707, 5, 31, 0, 0, 707, 708, 3, 80, 40, 0, 708, 103, 1, 0,
		0, 0, 709, 710, 5, 32, 0, 0, 710, 711, 3, 80, 40, 0, 711, 105, 1, 0, 0,
		0, 712, 713, 5, 33, 0, 0, 713, 715, 5, 2, 0, 0, 714, 716, 3, 78, 39, 0,
		715, 714, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0, 717,
		718, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720, 5, 3, 0, 0, 720, 722,
		5, 2, 0, 0, 721, 723, 3, 52, 26, 0, 722, 721, 1, 0, 0, 0, 723, 724, 1,
		0, 0, 0, 724, 722, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 1, 0, 0,
		0, 726, 727, 5, 3, 0, 0, 727, 107, 1, 0, 0, 0, 728, 729, 5, 34, 0, 0, 729,
		730, 3, 12, 6, 0, 730, 734, 5, 2, 0, 0, 731, 733, 3, 12, 6, 0, 732, 731,
		1, 0, 0, 0, 733, 736, 1, 0, 0, 0, 734, 732, 1, 0, 0, 0, 734, 735, 1, 0,
		0, 0, 735, 737, 1, 0, 0, 0, 736, 734, 1, 0, 0, 0, 737, 738, 5, 3, 0, 0,
		738, 739, 3, 38, 19, 0, 739, 109, 1, 0, 0, 0, 740, 741, 5, 35, 0, 0, 741,
		742, 3, 22, 11, 0, 742, 111, 1, 0, 0, 0, 743, 744, 5, 36, 0, 0, 744, 113,
		1, 0, 0, 0, 745, 746, 5, 37, 0, 0, 746, 115, 1, 0, 0, 0, 747, 748, 5, 38,
		0, 0, 748, 117, 1, 0, 0, 0, 749, 750, 5, 39, 0, 0, 750, 751, 3, 152, 76,
		0, 751, 119, 1, 0, 0, 0, 752, 753, 5, 40, 0, 0, 753, 121, 1, 0, 0, 0, 754,
		755, 5, 41, 0, 0, 755, 756, 3, 24, 12, 0, 756, 123, 1, 0, 0, 0, 757, 758,
		5, 42, 0, 0, 758, 125, 1, 0, 0, 0, 759, 760, 5, 43, 0, 0, 760, 127, 1,
		0, 0, 0, 761, 762, 5, 44, 0, 0, 762, 129, 1, 0, 0, 0, 763, 764, 5, 45,
		0, 0, 764, 766, 5, 2, 0, 0, 765, 767, 3, 52, 26, 0, 766, 765, 1, 0, 0,
		0, 767, 768, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769,
		770, 1, 0, 0, 0, 770, 771, 5, 3, 0, 0, 771, 131, 1, 0, 0, 0, 772, 773,
		5, 46, 0, 0, 773, 774, 3, 14, 7, 0, 774, 133, 1, 0, 0, 0, 775, 776, 5,
		47, 0, 0, 776, 777, 3, 14, 7, 0, 777, 135, 1, 0, 0, 0, 778, 779, 5, 48,
		0, 0, 779, 137, 1, 0, 0, 0, 780, 781, 5, 49, 0, 0, 781, 139, 1, 0, 0, 0,
		782, 783, 5, 50, 0, 0, 783, 784, 3, 36, 18, 0, 784, 141, 1, 0, 0, 0, 785,
		786, 5, 51, 0, 0, 786, 787, 3, 12, 6, 0, 787, 143, 1, 0, 0, 0, 788, 789,
		5, 52, 0, 0, 789, 790, 3, 150, 75, 0, 790, 145, 1, 0, 0, 0, 791, 792, 5,
		2, 0, 0, 792, 793, 3, 86, 43, 0, 793, 794, 5, 3, 0, 0, 794, 912, 1, 0,
		0, 0, 795, 796, 5, 2, 0, 0, 796, 797, 3, 88, 44, 0, 797, 798, 5, 3, 0,
		0, 798, 912, 1, 0, 0, 0, 799, 800, 5, 2, 0, 0, 800, 801, 3, 90, 45, 0,
		801, 802, 5, 3, 0, 0, 802, 912, 1, 0, 0, 0, 803, 804, 5, 2, 0, 0, 804,
		805, 3, 92, 46, 0, 805, 806, 5, 3, 0, 0, 806, 912, 1, 0, 0, 0, 807, 808,
		5, 2, 0, 0, 808, 809, 3, 94, 47, 0, 809, 810, 5, 3, 0, 0, 810, 912, 1,
		0, 0, 0, 811, 812, 5, 2, 0, 0, 812, 813, 3, 96, 48, 0, 813, 814, 5, 3,
		0, 0, 814, 912, 1, 0, 0, 0, 815, 816, 5, 2, 0, 0, 816, 817, 3, 98, 49,
		0, 817, 818, 5, 3, 0, 0, 818, 912, 1, 0, 0, 0, 819, 820, 5, 2, 0, 0, 820,
		821, 3, 100, 50, 0, 821, 822, 5, 3, 0, 0, 822, 912, 1, 0, 0, 0, 823, 824,
		5, 2, 0, 0, 824, 825, 3, 102, 51, 0, 825, 826, 5, 3, 0, 0, 826, 912, 1,
		0, 0, 0, 827, 828, 5, 2, 0, 0, 828, 829, 3, 104, 52, 0, 829, 830, 5, 3,
		0, 0, 830, 912, 1, 0, 0, 0, 831, 832, 5, 2, 0, 0, 832, 833, 3, 106, 53,
		0, 833, 834, 5, 3, 0, 0, 834, 912, 1, 0, 0, 0, 835, 836, 5, 2, 0, 0, 836,
		837, 3, 108, 54, 0, 837, 838, 5, 3, 0, 0, 838, 912, 1, 0, 0, 0, 839, 840,
		5, 2, 0, 0, 840, 841, 3, 110, 55, 0, 841, 842, 5, 3, 0, 0, 842, 912, 1,
		0, 0, 0, 843, 844, 5, 2, 0, 0, 844, 845, 3, 112, 56, 0, 845, 846, 5, 3,
		0, 0, 846, 912, 1, 0, 0, 0, 847, 848, 5, 2, 0, 0, 848, 849, 3, 114, 57,
		0, 849, 850, 5, 3, 0, 0, 850, 912, 1, 0, 0, 0, 851, 852, 5, 2, 0, 0, 852,
		853, 3, 116, 58, 0, 853, 854, 5, 3, 0, 0, 854, 912, 1, 0, 0, 0, 855, 856,
		5, 2, 0, 0, 856, 857, 3, 118, 59, 0, 857, 858, 5, 3, 0, 0, 858, 912, 1,
		0, 0, 0, 859, 860, 5, 2, 0, 0, 860, 861, 3, 120, 60, 0, 861, 862, 5, 3,
		0, 0, 862, 912, 1, 0, 0, 0, 863, 864, 5, 2, 0, 0, 864, 865, 3, 122, 61,
		0, 865, 866, 5, 3, 0, 0, 866, 912, 1, 0, 0, 0, 867, 868, 5, 2, 0, 0, 868,
		869, 3, 124, 62, 0, 869, 870, 5, 3, 0, 0, 870, 912, 1, 0, 0, 0, 871, 872,
		5, 2, 0, 0, 872, 873, 3, 126, 63, 0, 873, 874, 5, 3, 0, 0, 874, 912, 1,
		0, 0, 0, 875, 876, 5, 2, 0, 0, 876, 877, 3, 128, 64, 0, 877, 878, 5, 3,
		0, 0, 878, 912, 1, 0, 0, 0, 879, 880, 5, 2, 0, 0, 880, 881, 3, 130, 65,
		0, 881, 882, 5, 3, 0, 0, 882, 912, 1, 0, 0, 0, 883, 884, 5, 2, 0, 0, 884,
		885, 3, 132, 66, 0, 885, 886, 5, 3, 0, 0, 886, 912, 1, 0, 0, 0, 887, 888,
		5, 2, 0, 0, 888, 889, 3, 134, 67, 0, 889, 890, 5, 3, 0, 0, 890, 912, 1,
		0, 0, 0, 891, 892, 5, 2, 0, 0, 892, 893, 3, 136, 68, 0, 893, 894, 5, 3,
		0, 0, 894, 912, 1, 0, 0, 0, 895, 896, 5, 2, 0, 0, 896, 897, 3, 138, 69,
		0, 897, 898, 5, 3, 0, 0, 898, 912, 1, 0, 0, 0, 899, 900, 5, 2, 0, 0, 900,
		901, 3, 140, 70, 0, 901, 902, 5, 3, 0, 0, 902, 912, 1, 0, 0, 0, 903, 904,
		5, 2, 0, 0, 904, 905, 3, 142, 71, 0, 905, 906, 5, 3, 0, 0, 906, 912, 1,
		0, 0, 0, 907, 908, 5, 2, 0, 0, 908, 909, 3, 144, 72, 0, 909, 910, 5, 3,
		0, 0, 910, 912, 1, 0, 0, 0, 911, 791, 1, 0, 0, 0, 911, 795, 1, 0, 0, 0,
		911, 799, 1, 0, 0, 0, 911, 803, 1, 0, 0, 0, 911, 807, 1, 0, 0, 0, 911,
		811, 1, 0, 0, 0, 911, 815, 1, 0, 0, 0, 911, 819, 1, 0, 0, 0, 911, 823,
		1, 0, 0, 0, 911, 827, 1, 0, 0, 0, 911, 831, 1, 0, 0, 0, 911, 835, 1, 0,
		0, 0, 911, 839, 1, 0, 0, 0, 911, 843, 1, 0, 0, 0, 911, 847, 1, 0, 0, 0,
		911, 851, 1, 0, 0, 0, 911, 855, 1, 0, 0, 0, 911, 859, 1, 0, 0, 0, 911,
		863, 1, 0, 0, 0, 911, 867, 1, 0, 0, 0, 911, 871, 1, 0, 0, 0, 911, 875,
		1, 0, 0, 0, 911, 879, 1, 0, 0, 0, 911, 883, 1, 0, 0, 0, 911, 887, 1, 0,
		0, 0, 911, 891, 1, 0, 0, 0, 911, 895, 1, 0, 0, 0, 911, 899, 1, 0, 0, 0,
		911, 903, 1, 0, 0, 0, 911, 907, 1, 0, 0, 0, 912, 147, 1, 0, 0, 0, 913,
		914, 7, 4, 0, 0, 914, 149, 1, 0, 0, 0, 915, 916, 5, 77, 0, 0, 916, 945,
		3, 22, 11, 0, 917, 918, 5, 82, 0, 0, 918, 945, 3, 148, 74, 0, 919, 920,
		5, 83, 0, 0, 920, 945, 3, 148, 74, 0, 921, 922, 5, 91, 0, 0, 922, 945,
		3, 148, 74, 0, 923, 924, 5, 92, 0, 0, 924, 945, 3, 148, 74, 0, 925, 926,
		5, 93, 0, 0, 926, 945, 3, 148, 74, 0, 927, 928, 5, 94, 0, 0, 928, 945,
		3, 148, 74, 0, 929, 930, 5, 95, 0, 0, 930, 945, 3, 148, 74, 0, 931, 932,
		5, 96, 0, 0, 932, 945, 3, 148, 74, 0, 933, 934, 5, 97, 0, 0, 934, 945,
		3, 148, 74, 0, 935, 936, 5, 98, 0, 0, 936, 945, 3, 14, 7, 0, 937, 938,
		5, 100, 0, 0, 938, 945, 3, 22, 11, 0, 939, 940, 5, 101, 0, 0, 940, 945,
		3, 14, 7, 0, 941, 942, 5, 110, 0, 0, 942, 945, 3, 14, 7, 0, 943, 945, 3,
		36, 18, 0, 944, 915, 1, 0, 0, 0, 944, 917, 1, 0, 0, 0, 944, 919, 1, 0,
		0, 0, 944, 921, 1, 0, 0, 0, 944, 923, 1, 0, 0, 0, 944, 925, 1, 0, 0, 0,
		944, 927, 1, 0, 0, 0, 944, 929, 1, 0, 0, 0, 944, 931, 1, 0, 0, 0, 944,
		933, 1, 0, 0, 0, 944, 935, 1, 0, 0, 0, 944, 937, 1, 0, 0, 0, 944, 939,
		1, 0, 0, 0, 944, 941, 1, 0, 0, 0, 944, 943, 1, 0, 0, 0, 945, 151, 1, 0,
		0, 0, 946, 955, 5, 71, 0, 0, 947, 955, 5, 72, 0, 0, 948, 955, 5, 73, 0,
		0, 949, 955, 5, 78, 0, 0, 950, 955, 5, 88, 0, 0, 951, 955, 5, 99, 0, 0,
		952, 955, 5, 111, 0, 0, 953, 955, 3, 24, 12, 0, 954, 946, 1, 0, 0, 0, 954,
		947, 1, 0, 0, 0, 954, 948, 1, 0, 0, 0, 954, 949, 1, 0, 0, 0, 954, 950,
		1, 0, 0, 0, 954, 951, 1, 0, 0, 0, 954, 952, 1, 0, 0, 0, 954, 953, 1, 0,
		0, 0, 955, 153, 1, 0, 0, 0, 956, 957, 7, 5, 0, 0, 957, 155, 1, 0, 0, 0,
		958, 962, 5, 15, 0, 0, 959, 962, 5, 13, 0, 0, 960, 962, 3, 28, 14, 0, 961,
		958, 1, 0, 0, 0, 961, 959, 1, 0, 0, 0, 961, 960, 1, 0, 0, 0, 962, 157,
		1, 0, 0, 0, 963, 964, 5, 2, 0, 0, 964, 965, 3, 102, 51, 0, 965, 966, 5,
		3, 0, 0, 966, 976, 1, 0, 0, 0, 967, 968, 5, 2, 0, 0, 968, 969, 3, 104,
		52, 0, 969, 970, 5, 3, 0, 0, 970, 976, 1, 0, 0, 0, 971, 972, 5, 2, 0, 0,
		972, 973, 3, 106, 53, 0, 973, 974, 5, 3, 0, 0, 974, 976, 1, 0, 0, 0, 975,
		963, 1, 0, 0, 0, 975, 967, 1, 0, 0, 0, 975, 971, 1, 0, 0, 0, 976, 159,
		1, 0, 0, 0, 977, 978, 5, 72, 0, 0, 978, 991, 3, 14, 7, 0, 979, 980, 5,
		73, 0, 0, 980, 991, 3, 22, 11, 0, 981, 982, 5, 78, 0, 0, 982, 991, 3, 154,
		77, 0, 983, 984, 5, 88, 0, 0, 984, 991, 3, 22, 11, 0, 985, 986, 5, 99,
		0, 0, 986, 991, 3, 156, 78, 0, 987, 988, 5, 111, 0, 0, 988, 991, 3, 22,
		11, 0, 989, 991, 3, 36, 18, 0, 990, 977, 1, 0, 0, 0, 990, 979, 1, 0, 0,
		0, 990, 981, 1, 0, 0, 0, 990, 983, 1, 0, 0, 0, 990, 985, 1, 0, 0, 0, 990,
		987, 1, 0, 0, 0, 990, 989, 1, 0, 0, 0, 991, 161, 1, 0, 0, 0, 992, 993,
		5, 2, 0, 0, 993, 994, 3, 52, 26, 0, 994, 995, 3, 52, 26, 0, 995, 996, 5,
		3, 0, 0, 996, 163, 1, 0, 0, 0, 997, 998, 5, 2, 0, 0, 998, 999, 3, 12, 6,
		0, 999, 1000, 3, 148, 74, 0, 1000, 1001, 5, 3, 0, 0, 1001, 165, 1, 0, 0,
		0, 1002, 1003, 7, 6, 0, 0, 1003, 167, 1, 0, 0, 0, 1004, 1005, 3, 22, 11,
		0, 1005, 169, 1, 0, 0, 0, 1006, 1010, 5, 2, 0, 0, 1007, 1009, 3, 52, 26,
		0, 1008, 1007, 1, 0, 0, 0, 1009, 1012, 1, 0, 0, 0, 1010, 1008, 1, 0, 0,
		0, 1010, 1011, 1, 0, 0, 0, 1011, 1013, 1, 0, 0, 0, 1012, 1010, 1, 0, 0,
		0, 1013, 1014, 5, 3, 0, 0, 1014, 171, 1, 0, 0, 0, 1015, 1019, 5, 2, 0,
		0, 1016, 1018, 3, 164, 82, 0, 1017, 1016, 1, 0, 0, 0, 1018, 1021, 1, 0,
		0, 0, 1019, 1017, 1, 0, 0, 0, 1019, 1020, 1, 0, 0, 0, 1020, 1022, 1, 0,
		0, 0, 1021, 1019, 1, 0, 0, 0, 1022, 1023, 5, 3, 0, 0, 1023, 173, 1, 0,
		0, 0, 1024, 1026, 5, 2, 0, 0, 1025, 1027, 3, 160, 80, 0, 1026, 1025, 1,
		0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1026, 1, 0, 0, 0, 1028, 1029, 1,
		0, 0, 0, 1029, 1030, 1, 0, 0, 0, 1030, 1031, 5, 3, 0, 0, 1031, 175, 1,
		0, 0, 0, 1032, 1033, 5, 2, 0, 0, 1033, 1037, 5, 112, 0, 0, 1034, 1036,
		3, 158, 79, 0, 1035, 1034, 1, 0, 0, 0, 1036, 1039, 1, 0, 0, 0, 1037, 1035,
		1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 1040, 1, 0, 0, 0, 1039, 1037,
		1, 0, 0, 0, 1040, 1050, 5, 3, 0, 0, 1041, 1045, 5, 2, 0, 0, 1042, 1044,
		3, 158, 79, 0, 1043, 1042, 1, 0, 0, 0, 1044, 1047, 1, 0, 0, 0, 1045, 1043,
		1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1048, 1, 0, 0, 0, 1047, 1045,
		1, 0, 0, 0, 1048, 1050, 5, 3, 0, 0, 1049, 1032, 1, 0, 0, 0, 1049, 1041,
		1, 0, 0, 0, 1050, 177, 1, 0, 0, 0, 1051, 1052, 3, 34, 17, 0, 1052, 179,
		1, 0, 0, 0, 1053, 1054, 3, 28, 14, 0, 1054, 181, 1, 0, 0, 0, 1055, 1059,
		5, 2, 0, 0, 1056, 1058, 3, 12, 6, 0, 1057, 1056, 1, 0, 0, 0, 1058, 1061,
		1, 0, 0, 0, 1059, 1057, 1, 0, 0, 0, 1059, 1060, 1, 0, 0, 0, 1060, 1062,
		1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1062, 1063, 5, 3, 0, 0, 1063, 183,
		1, 0, 0, 0, 1064, 1068, 5, 2, 0, 0, 1065, 1067, 3, 12, 6, 0, 1066, 1065,
		1, 0, 0, 0, 1067, 1070, 1, 0, 0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069,
		1, 0, 0, 0, 1069, 1071, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 1072,
		5, 3, 0, 0, 1072, 185, 1, 0, 0, 0, 1073, 1075, 5, 2, 0, 0, 1074, 1076,
		3, 162, 81, 0, 1075, 1074, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1075,
		1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1080,
		5, 3, 0, 0, 1080, 187, 1, 0, 0, 0, 1081, 1093, 3, 166, 83, 0, 1082, 1093,
		3, 168, 84, 0, 1083, 1093, 3, 170, 85, 0, 1084, 1093, 3, 172, 86, 0, 1085,
		1093, 3, 174, 87, 0, 1086, 1093, 3, 176, 88, 0, 1087, 1093, 3, 178, 89,
		0, 1088, 1093, 3, 180, 90, 0, 1089, 1093, 3, 182, 91, 0, 1090, 1093, 3,
		184, 92, 0, 1091, 1093, 3, 186, 93, 0, 1092, 1081, 1, 0, 0, 0, 1092, 1082,
		1, 0, 0, 0, 1092, 1083, 1, 0, 0, 0, 1092, 1084, 1, 0, 0, 0, 1092, 1085,
		1, 0, 0, 0, 1092, 1086, 1, 0, 0, 0, 1092, 1087, 1, 0, 0, 0, 1092, 1088,
		1, 0, 0, 0, 1092, 1089, 1, 0, 0, 0, 1092, 1090, 1, 0, 0, 0, 1092, 1091,
		1, 0, 0, 0, 1093, 189, 1, 0, 0, 0, 1094, 1103, 5, 17, 0, 0, 1095, 1103,
		3, 188, 94, 0, 1096, 1103, 5, 21, 0, 0, 1097, 1098, 5, 2, 0, 0, 1098, 1099,
		5, 10, 0, 0, 1099, 1100, 3, 22, 11, 0, 1100, 1101, 5, 3, 0, 0, 1101, 1103,
		1, 0, 0, 0, 1102, 1094, 1, 0, 0, 0, 1102, 1095, 1, 0, 0, 0, 1102, 1096,
		1, 0, 0, 0, 1102, 1097, 1, 0, 0, 0, 1103, 191, 1, 0, 0, 0, 76, 204, 210,
		220, 235, 242, 251, 255, 259, 268, 272, 280, 284, 290, 298, 302, 311, 329,
		333, 349, 359, 371, 383, 396, 407, 411, 419, 432, 443, 453, 458, 463, 472,
		480, 485, 491, 498, 507, 522, 530, 539, 552, 560, 579, 588, 598, 605, 610,
		618, 630, 643, 648, 661, 679, 686, 696, 717, 724, 734, 768, 911, 944, 954,
		961, 975, 990, 1010, 1019, 1028, 1037, 1045, 1049, 1059, 1068, 1077, 1092,
		1102,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SMTLIBv2ParserInit initializes any static state used to implement SMTLIBv2Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSMTLIBv2Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SMTLIBv2ParserInit() {
	staticData := &SMTLIBv2ParserStaticData
	staticData.once.Do(smtlibv2ParserInit)
}

// NewSMTLIBv2Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewSMTLIBv2Parser(input antlr.TokenStream) *SMTLIBv2Parser {
	SMTLIBv2ParserInit()
	this := new(SMTLIBv2Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SMTLIBv2ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SMTLIBv2.g4"

	return this
}

// SMTLIBv2Parser tokens.
const (
	SMTLIBv2ParserEOF                          = antlr.TokenEOF
	SMTLIBv2ParserComment                      = 1
	SMTLIBv2ParserParOpen                      = 2
	SMTLIBv2ParserParClose                     = 3
	SMTLIBv2ParserSemicolon                    = 4
	SMTLIBv2ParserString_                      = 5
	SMTLIBv2ParserQuotedSymbol                 = 6
	SMTLIBv2ParserPS_Not                       = 7
	SMTLIBv2ParserPS_Bool                      = 8
	SMTLIBv2ParserPS_ContinuedExecution        = 9
	SMTLIBv2ParserPS_Error                     = 10
	SMTLIBv2ParserPS_False                     = 11
	SMTLIBv2ParserPS_ImmediateExit             = 12
	SMTLIBv2ParserPS_Incomplete                = 13
	SMTLIBv2ParserPS_Logic                     = 14
	SMTLIBv2ParserPS_Memout                    = 15
	SMTLIBv2ParserPS_Sat                       = 16
	SMTLIBv2ParserPS_Success                   = 17
	SMTLIBv2ParserPS_Theory                    = 18
	SMTLIBv2ParserPS_True                      = 19
	SMTLIBv2ParserPS_Unknown                   = 20
	SMTLIBv2ParserPS_Unsupported               = 21
	SMTLIBv2ParserPS_Unsat                     = 22
	SMTLIBv2ParserCMD_Assert                   = 23
	SMTLIBv2ParserCMD_CheckSat                 = 24
	SMTLIBv2ParserCMD_CheckSatAssuming         = 25
	SMTLIBv2ParserCMD_DeclareConst             = 26
	SMTLIBv2ParserCMD_DeclareDatatype          = 27
	SMTLIBv2ParserCMD_DeclareDatatypes         = 28
	SMTLIBv2ParserCMD_DeclareFun               = 29
	SMTLIBv2ParserCMD_DeclareSort              = 30
	SMTLIBv2ParserCMD_DefineFun                = 31
	SMTLIBv2ParserCMD_DefineFunRec             = 32
	SMTLIBv2ParserCMD_DefineFunsRec            = 33
	SMTLIBv2ParserCMD_DefineSort               = 34
	SMTLIBv2ParserCMD_Echo                     = 35
	SMTLIBv2ParserCMD_Exit                     = 36
	SMTLIBv2ParserCMD_GetAssertions            = 37
	SMTLIBv2ParserCMD_GetAssignment            = 38
	SMTLIBv2ParserCMD_GetInfo                  = 39
	SMTLIBv2ParserCMD_GetModel                 = 40
	SMTLIBv2ParserCMD_GetOption                = 41
	SMTLIBv2ParserCMD_GetProof                 = 42
	SMTLIBv2ParserCMD_GetUnsatAssumptions      = 43
	SMTLIBv2ParserCMD_GetUnsatCore             = 44
	SMTLIBv2ParserCMD_GetValue                 = 45
	SMTLIBv2ParserCMD_Pop                      = 46
	SMTLIBv2ParserCMD_Push                     = 47
	SMTLIBv2ParserCMD_Reset                    = 48
	SMTLIBv2ParserCMD_ResetAssertions          = 49
	SMTLIBv2ParserCMD_SetInfo                  = 50
	SMTLIBv2ParserCMD_SetLogic                 = 51
	SMTLIBv2ParserCMD_SetOption                = 52
	SMTLIBv2ParserGRW_Exclamation              = 53
	SMTLIBv2ParserGRW_Underscore               = 54
	SMTLIBv2ParserGRW_As                       = 55
	SMTLIBv2ParserGRW_Binary                   = 56
	SMTLIBv2ParserGRW_Decimal                  = 57
	SMTLIBv2ParserGRW_Exists                   = 58
	SMTLIBv2ParserGRW_Hexadecimal              = 59
	SMTLIBv2ParserGRW_Forall                   = 60
	SMTLIBv2ParserGRW_Let                      = 61
	SMTLIBv2ParserGRW_Match                    = 62
	SMTLIBv2ParserGRW_Numeral                  = 63
	SMTLIBv2ParserGRW_Par                      = 64
	SMTLIBv2ParserGRW_String                   = 65
	SMTLIBv2ParserNumeral                      = 66
	SMTLIBv2ParserBinary                       = 67
	SMTLIBv2ParserHexDecimal                   = 68
	SMTLIBv2ParserDecimal                      = 69
	SMTLIBv2ParserColon                        = 70
	SMTLIBv2ParserPK_AllStatistics             = 71
	SMTLIBv2ParserPK_AssertionStackLevels      = 72
	SMTLIBv2ParserPK_Authors                   = 73
	SMTLIBv2ParserPK_Category                  = 74
	SMTLIBv2ParserPK_Chainable                 = 75
	SMTLIBv2ParserPK_Definition                = 76
	SMTLIBv2ParserPK_DiagnosticOutputChannel   = 77
	SMTLIBv2ParserPK_ErrorBehaviour            = 78
	SMTLIBv2ParserPK_Extension                 = 79
	SMTLIBv2ParserPK_Funs                      = 80
	SMTLIBv2ParserPK_FunsDescription           = 81
	SMTLIBv2ParserPK_GlobalDeclarations        = 82
	SMTLIBv2ParserPK_InteractiveMode           = 83
	SMTLIBv2ParserPK_Language                  = 84
	SMTLIBv2ParserPK_LeftAssoc                 = 85
	SMTLIBv2ParserPK_License                   = 86
	SMTLIBv2ParserPK_Named                     = 87
	SMTLIBv2ParserPK_Name                      = 88
	SMTLIBv2ParserPK_Notes                     = 89
	SMTLIBv2ParserPK_Pattern                   = 90
	SMTLIBv2ParserPK_PrintSuccess              = 91
	SMTLIBv2ParserPK_ProduceAssertions         = 92
	SMTLIBv2ParserPK_ProduceAssignments        = 93
	SMTLIBv2ParserPK_ProduceModels             = 94
	SMTLIBv2ParserPK_ProduceProofs             = 95
	SMTLIBv2ParserPK_ProduceUnsatAssumptions   = 96
	SMTLIBv2ParserPK_ProduceUnsatCores         = 97
	SMTLIBv2ParserPK_RandomSeed                = 98
	SMTLIBv2ParserPK_ReasonUnknown             = 99
	SMTLIBv2ParserPK_RegularOutputChannel      = 100
	SMTLIBv2ParserPK_ReproducibleResourceLimit = 101
	SMTLIBv2ParserPK_RightAssoc                = 102
	SMTLIBv2ParserPK_SmtLibVersion             = 103
	SMTLIBv2ParserPK_Sorts                     = 104
	SMTLIBv2ParserPK_SortsDescription          = 105
	SMTLIBv2ParserPK_Source                    = 106
	SMTLIBv2ParserPK_Status                    = 107
	SMTLIBv2ParserPK_Theories                  = 108
	SMTLIBv2ParserPK_Values                    = 109
	SMTLIBv2ParserPK_Verbosity                 = 110
	SMTLIBv2ParserPK_Version                   = 111
	SMTLIBv2ParserRS_Model                     = 112
	SMTLIBv2ParserUndefinedSymbol              = 113
	SMTLIBv2ParserWS                           = 114
)

// SMTLIBv2Parser rules.
const (
	SMTLIBv2ParserRULE_start                     = 0
	SMTLIBv2ParserRULE_generalReservedWord       = 1
	SMTLIBv2ParserRULE_simpleSymbol              = 2
	SMTLIBv2ParserRULE_quotedSymbol              = 3
	SMTLIBv2ParserRULE_predefSymbol              = 4
	SMTLIBv2ParserRULE_predefKeyword             = 5
	SMTLIBv2ParserRULE_symbol                    = 6
	SMTLIBv2ParserRULE_numeral                   = 7
	SMTLIBv2ParserRULE_decimal                   = 8
	SMTLIBv2ParserRULE_hexadecimal               = 9
	SMTLIBv2ParserRULE_binary                    = 10
	SMTLIBv2ParserRULE_string_                   = 11
	SMTLIBv2ParserRULE_keyword                   = 12
	SMTLIBv2ParserRULE_spec_constant             = 13
	SMTLIBv2ParserRULE_s_expr                    = 14
	SMTLIBv2ParserRULE_index                     = 15
	SMTLIBv2ParserRULE_identifier                = 16
	SMTLIBv2ParserRULE_attribute_value           = 17
	SMTLIBv2ParserRULE_attribute                 = 18
	SMTLIBv2ParserRULE_sort                      = 19
	SMTLIBv2ParserRULE_qual_identifer            = 20
	SMTLIBv2ParserRULE_var_binding               = 21
	SMTLIBv2ParserRULE_sorted_var                = 22
	SMTLIBv2ParserRULE_pattern                   = 23
	SMTLIBv2ParserRULE_match_case                = 24
	SMTLIBv2ParserRULE_variable                  = 25
	SMTLIBv2ParserRULE_term                      = 26
	SMTLIBv2ParserRULE_sort_symbol_decl          = 27
	SMTLIBv2ParserRULE_meta_spec_constant        = 28
	SMTLIBv2ParserRULE_fun_symbol_decl           = 29
	SMTLIBv2ParserRULE_par_fun_symbol_decl       = 30
	SMTLIBv2ParserRULE_theory_attribute          = 31
	SMTLIBv2ParserRULE_theory_decl               = 32
	SMTLIBv2ParserRULE_logic_attribue            = 33
	SMTLIBv2ParserRULE_logic                     = 34
	SMTLIBv2ParserRULE_sort_dec                  = 35
	SMTLIBv2ParserRULE_selector_dec              = 36
	SMTLIBv2ParserRULE_constructor_dec           = 37
	SMTLIBv2ParserRULE_datatype_dec              = 38
	SMTLIBv2ParserRULE_function_dec              = 39
	SMTLIBv2ParserRULE_function_def              = 40
	SMTLIBv2ParserRULE_prop_literal              = 41
	SMTLIBv2ParserRULE_script                    = 42
	SMTLIBv2ParserRULE_cmd_assert                = 43
	SMTLIBv2ParserRULE_cmd_checkSat              = 44
	SMTLIBv2ParserRULE_cmd_checkSatAssuming      = 45
	SMTLIBv2ParserRULE_cmd_declareConst          = 46
	SMTLIBv2ParserRULE_cmd_declareDatatype       = 47
	SMTLIBv2ParserRULE_cmd_declareDatatypes      = 48
	SMTLIBv2ParserRULE_cmd_declareFun            = 49
	SMTLIBv2ParserRULE_cmd_declareSort           = 50
	SMTLIBv2ParserRULE_cmd_defineFun             = 51
	SMTLIBv2ParserRULE_cmd_defineFunRec          = 52
	SMTLIBv2ParserRULE_cmd_defineFunsRec         = 53
	SMTLIBv2ParserRULE_cmd_defineSort            = 54
	SMTLIBv2ParserRULE_cmd_echo                  = 55
	SMTLIBv2ParserRULE_cmd_exit                  = 56
	SMTLIBv2ParserRULE_cmd_getAssertions         = 57
	SMTLIBv2ParserRULE_cmd_getAssignment         = 58
	SMTLIBv2ParserRULE_cmd_getInfo               = 59
	SMTLIBv2ParserRULE_cmd_getModel              = 60
	SMTLIBv2ParserRULE_cmd_getOption             = 61
	SMTLIBv2ParserRULE_cmd_getProof              = 62
	SMTLIBv2ParserRULE_cmd_getUnsatAssumptions   = 63
	SMTLIBv2ParserRULE_cmd_getUnsatCore          = 64
	SMTLIBv2ParserRULE_cmd_getValue              = 65
	SMTLIBv2ParserRULE_cmd_pop                   = 66
	SMTLIBv2ParserRULE_cmd_push                  = 67
	SMTLIBv2ParserRULE_cmd_reset                 = 68
	SMTLIBv2ParserRULE_cmd_resetAssertions       = 69
	SMTLIBv2ParserRULE_cmd_setInfo               = 70
	SMTLIBv2ParserRULE_cmd_setLogic              = 71
	SMTLIBv2ParserRULE_cmd_setOption             = 72
	SMTLIBv2ParserRULE_command                   = 73
	SMTLIBv2ParserRULE_b_value                   = 74
	SMTLIBv2ParserRULE_option                    = 75
	SMTLIBv2ParserRULE_info_flag                 = 76
	SMTLIBv2ParserRULE_error_behaviour           = 77
	SMTLIBv2ParserRULE_reason_unknown            = 78
	SMTLIBv2ParserRULE_model_response            = 79
	SMTLIBv2ParserRULE_info_response             = 80
	SMTLIBv2ParserRULE_valuation_pair            = 81
	SMTLIBv2ParserRULE_t_valuation_pair          = 82
	SMTLIBv2ParserRULE_check_sat_response        = 83
	SMTLIBv2ParserRULE_echo_response             = 84
	SMTLIBv2ParserRULE_get_assertions_response   = 85
	SMTLIBv2ParserRULE_get_assignment_response   = 86
	SMTLIBv2ParserRULE_get_info_response         = 87
	SMTLIBv2ParserRULE_get_model_response        = 88
	SMTLIBv2ParserRULE_get_option_response       = 89
	SMTLIBv2ParserRULE_get_proof_response        = 90
	SMTLIBv2ParserRULE_get_unsat_assump_response = 91
	SMTLIBv2ParserRULE_get_unsat_core_response   = 92
	SMTLIBv2ParserRULE_get_value_response        = 93
	SMTLIBv2ParserRULE_specific_success_response = 94
	SMTLIBv2ParserRULE_general_response          = 95
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Logic() ILogicContext
	EOF() antlr.TerminalNode
	Theory_decl() ITheory_declContext
	Script() IScriptContext
	General_response() IGeneral_responseContext

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_start
	return p
}

func InitEmptyStartContext(p *StartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_start
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Logic() ILogicContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicContext)
}

func (s *StartContext) EOF() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserEOF, 0)
}

func (s *StartContext) Theory_decl() ITheory_declContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheory_declContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheory_declContext)
}

func (s *StartContext) Script() IScriptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScriptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScriptContext)
}

func (s *StartContext) General_response() IGeneral_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneral_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneral_responseContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitStart(s)
	}
}

func (s *StartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Start_() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SMTLIBv2ParserRULE_start)
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(192)
			p.Logic()
		}
		{
			p.SetState(193)
			p.Match(SMTLIBv2ParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(195)
			p.Theory_decl()
		}
		{
			p.SetState(196)
			p.Match(SMTLIBv2ParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(198)
			p.Script()
		}
		{
			p.SetState(199)
			p.Match(SMTLIBv2ParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(201)
			p.General_response()
		}
		{
			p.SetState(202)
			p.Match(SMTLIBv2ParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralReservedWordContext is an interface to support dynamic dispatch.
type IGeneralReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRW_Exclamation() antlr.TerminalNode
	GRW_Underscore() antlr.TerminalNode
	GRW_As() antlr.TerminalNode
	GRW_Binary() antlr.TerminalNode
	GRW_Decimal() antlr.TerminalNode
	GRW_Exists() antlr.TerminalNode
	GRW_Hexadecimal() antlr.TerminalNode
	GRW_Forall() antlr.TerminalNode
	GRW_Let() antlr.TerminalNode
	GRW_Match() antlr.TerminalNode
	GRW_Numeral() antlr.TerminalNode
	GRW_Par() antlr.TerminalNode
	GRW_String() antlr.TerminalNode
	RS_Model() antlr.TerminalNode

	// IsGeneralReservedWordContext differentiates from other interfaces.
	IsGeneralReservedWordContext()
}

type GeneralReservedWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralReservedWordContext() *GeneralReservedWordContext {
	var p = new(GeneralReservedWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord
	return p
}

func InitEmptyGeneralReservedWordContext(p *GeneralReservedWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord
}

func (*GeneralReservedWordContext) IsGeneralReservedWordContext() {}

func NewGeneralReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralReservedWordContext {
	var p = new(GeneralReservedWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord

	return p
}

func (s *GeneralReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralReservedWordContext) GRW_Exclamation() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exclamation, 0)
}

func (s *GeneralReservedWordContext) GRW_Underscore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Underscore, 0)
}

func (s *GeneralReservedWordContext) GRW_As() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_As, 0)
}

func (s *GeneralReservedWordContext) GRW_Binary() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Binary, 0)
}

func (s *GeneralReservedWordContext) GRW_Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Decimal, 0)
}

func (s *GeneralReservedWordContext) GRW_Exists() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exists, 0)
}

func (s *GeneralReservedWordContext) GRW_Hexadecimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Hexadecimal, 0)
}

func (s *GeneralReservedWordContext) GRW_Forall() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Forall, 0)
}

func (s *GeneralReservedWordContext) GRW_Let() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Let, 0)
}

func (s *GeneralReservedWordContext) GRW_Match() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Match, 0)
}

func (s *GeneralReservedWordContext) GRW_Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Numeral, 0)
}

func (s *GeneralReservedWordContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *GeneralReservedWordContext) GRW_String() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_String, 0)
}

func (s *GeneralReservedWordContext) RS_Model() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserRS_Model, 0)
}

func (s *GeneralReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGeneralReservedWord(s)
	}
}

func (s *GeneralReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGeneralReservedWord(s)
	}
}

func (s *GeneralReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGeneralReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) GeneralReservedWord() (localctx IGeneralReservedWordContext) {
	localctx = NewGeneralReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SMTLIBv2ParserRULE_generalReservedWord)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&576460752303431679) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleSymbolContext is an interface to support dynamic dispatch.
type ISimpleSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredefSymbol() IPredefSymbolContext
	UndefinedSymbol() antlr.TerminalNode

	// IsSimpleSymbolContext differentiates from other interfaces.
	IsSimpleSymbolContext()
}

type SimpleSymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleSymbolContext() *SimpleSymbolContext {
	var p = new(SimpleSymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol
	return p
}

func InitEmptySimpleSymbolContext(p *SimpleSymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol
}

func (*SimpleSymbolContext) IsSimpleSymbolContext() {}

func NewSimpleSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleSymbolContext {
	var p = new(SimpleSymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol

	return p
}

func (s *SimpleSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleSymbolContext) PredefSymbol() IPredefSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefSymbolContext)
}

func (s *SimpleSymbolContext) UndefinedSymbol() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserUndefinedSymbol, 0)
}

func (s *SimpleSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSimpleSymbol(s)
	}
}

func (s *SimpleSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSimpleSymbol(s)
	}
}

func (s *SimpleSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSimpleSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) SimpleSymbol() (localctx ISimpleSymbolContext) {
	localctx = NewSimpleSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SMTLIBv2ParserRULE_simpleSymbol)
	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(208)
			p.PredefSymbol()
		}

	case SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(209)
			p.Match(SMTLIBv2ParserUndefinedSymbol)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedSymbolContext is an interface to support dynamic dispatch.
type IQuotedSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuotedSymbol() antlr.TerminalNode

	// IsQuotedSymbolContext differentiates from other interfaces.
	IsQuotedSymbolContext()
}

type QuotedSymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedSymbolContext() *QuotedSymbolContext {
	var p = new(QuotedSymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol
	return p
}

func InitEmptyQuotedSymbolContext(p *QuotedSymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol
}

func (*QuotedSymbolContext) IsQuotedSymbolContext() {}

func NewQuotedSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedSymbolContext {
	var p = new(QuotedSymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol

	return p
}

func (s *QuotedSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedSymbolContext) QuotedSymbol() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserQuotedSymbol, 0)
}

func (s *QuotedSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterQuotedSymbol(s)
	}
}

func (s *QuotedSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitQuotedSymbol(s)
	}
}

func (s *QuotedSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitQuotedSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) QuotedSymbol() (localctx IQuotedSymbolContext) {
	localctx = NewQuotedSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SMTLIBv2ParserRULE_quotedSymbol)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		p.Match(SMTLIBv2ParserQuotedSymbol)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredefSymbolContext is an interface to support dynamic dispatch.
type IPredefSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PS_Not() antlr.TerminalNode
	PS_Bool() antlr.TerminalNode
	PS_ContinuedExecution() antlr.TerminalNode
	PS_Error() antlr.TerminalNode
	PS_False() antlr.TerminalNode
	PS_ImmediateExit() antlr.TerminalNode
	PS_Incomplete() antlr.TerminalNode
	PS_Logic() antlr.TerminalNode
	PS_Memout() antlr.TerminalNode
	PS_Sat() antlr.TerminalNode
	PS_Success() antlr.TerminalNode
	PS_Theory() antlr.TerminalNode
	PS_True() antlr.TerminalNode
	PS_Unknown() antlr.TerminalNode
	PS_Unsupported() antlr.TerminalNode
	PS_Unsat() antlr.TerminalNode

	// IsPredefSymbolContext differentiates from other interfaces.
	IsPredefSymbolContext()
}

type PredefSymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefSymbolContext() *PredefSymbolContext {
	var p = new(PredefSymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol
	return p
}

func InitEmptyPredefSymbolContext(p *PredefSymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol
}

func (*PredefSymbolContext) IsPredefSymbolContext() {}

func NewPredefSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefSymbolContext {
	var p = new(PredefSymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol

	return p
}

func (s *PredefSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefSymbolContext) PS_Not() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Not, 0)
}

func (s *PredefSymbolContext) PS_Bool() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Bool, 0)
}

func (s *PredefSymbolContext) PS_ContinuedExecution() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ContinuedExecution, 0)
}

func (s *PredefSymbolContext) PS_Error() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Error, 0)
}

func (s *PredefSymbolContext) PS_False() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_False, 0)
}

func (s *PredefSymbolContext) PS_ImmediateExit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ImmediateExit, 0)
}

func (s *PredefSymbolContext) PS_Incomplete() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Incomplete, 0)
}

func (s *PredefSymbolContext) PS_Logic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Logic, 0)
}

func (s *PredefSymbolContext) PS_Memout() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Memout, 0)
}

func (s *PredefSymbolContext) PS_Sat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Sat, 0)
}

func (s *PredefSymbolContext) PS_Success() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Success, 0)
}

func (s *PredefSymbolContext) PS_Theory() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Theory, 0)
}

func (s *PredefSymbolContext) PS_True() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_True, 0)
}

func (s *PredefSymbolContext) PS_Unknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unknown, 0)
}

func (s *PredefSymbolContext) PS_Unsupported() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsupported, 0)
}

func (s *PredefSymbolContext) PS_Unsat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsat, 0)
}

func (s *PredefSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPredefSymbol(s)
	}
}

func (s *PredefSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPredefSymbol(s)
	}
}

func (s *PredefSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPredefSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) PredefSymbol() (localctx IPredefSymbolContext) {
	localctx = NewPredefSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SMTLIBv2ParserRULE_predefSymbol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388480) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredefKeywordContext is an interface to support dynamic dispatch.
type IPredefKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PK_AllStatistics() antlr.TerminalNode
	PK_AssertionStackLevels() antlr.TerminalNode
	PK_Authors() antlr.TerminalNode
	PK_Category() antlr.TerminalNode
	PK_Chainable() antlr.TerminalNode
	PK_Definition() antlr.TerminalNode
	PK_DiagnosticOutputChannel() antlr.TerminalNode
	PK_ErrorBehaviour() antlr.TerminalNode
	PK_Extension() antlr.TerminalNode
	PK_Funs() antlr.TerminalNode
	PK_FunsDescription() antlr.TerminalNode
	PK_GlobalDeclarations() antlr.TerminalNode
	PK_InteractiveMode() antlr.TerminalNode
	PK_Language() antlr.TerminalNode
	PK_LeftAssoc() antlr.TerminalNode
	PK_License() antlr.TerminalNode
	PK_Named() antlr.TerminalNode
	PK_Name() antlr.TerminalNode
	PK_Notes() antlr.TerminalNode
	PK_Pattern() antlr.TerminalNode
	PK_PrintSuccess() antlr.TerminalNode
	PK_ProduceAssertions() antlr.TerminalNode
	PK_ProduceAssignments() antlr.TerminalNode
	PK_ProduceModels() antlr.TerminalNode
	PK_ProduceProofs() antlr.TerminalNode
	PK_ProduceUnsatAssumptions() antlr.TerminalNode
	PK_ProduceUnsatCores() antlr.TerminalNode
	PK_RandomSeed() antlr.TerminalNode
	PK_ReasonUnknown() antlr.TerminalNode
	PK_RegularOutputChannel() antlr.TerminalNode
	PK_ReproducibleResourceLimit() antlr.TerminalNode
	PK_RightAssoc() antlr.TerminalNode
	PK_SmtLibVersion() antlr.TerminalNode
	PK_Sorts() antlr.TerminalNode
	PK_SortsDescription() antlr.TerminalNode
	PK_Source() antlr.TerminalNode
	PK_Status() antlr.TerminalNode
	PK_Theories() antlr.TerminalNode
	PK_Values() antlr.TerminalNode
	PK_Verbosity() antlr.TerminalNode
	PK_Version() antlr.TerminalNode

	// IsPredefKeywordContext differentiates from other interfaces.
	IsPredefKeywordContext()
}

type PredefKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefKeywordContext() *PredefKeywordContext {
	var p = new(PredefKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword
	return p
}

func InitEmptyPredefKeywordContext(p *PredefKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword
}

func (*PredefKeywordContext) IsPredefKeywordContext() {}

func NewPredefKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefKeywordContext {
	var p = new(PredefKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword

	return p
}

func (s *PredefKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefKeywordContext) PK_AllStatistics() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AllStatistics, 0)
}

func (s *PredefKeywordContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *PredefKeywordContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *PredefKeywordContext) PK_Category() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Category, 0)
}

func (s *PredefKeywordContext) PK_Chainable() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Chainable, 0)
}

func (s *PredefKeywordContext) PK_Definition() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Definition, 0)
}

func (s *PredefKeywordContext) PK_DiagnosticOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_DiagnosticOutputChannel, 0)
}

func (s *PredefKeywordContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *PredefKeywordContext) PK_Extension() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Extension, 0)
}

func (s *PredefKeywordContext) PK_Funs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Funs, 0)
}

func (s *PredefKeywordContext) PK_FunsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_FunsDescription, 0)
}

func (s *PredefKeywordContext) PK_GlobalDeclarations() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_GlobalDeclarations, 0)
}

func (s *PredefKeywordContext) PK_InteractiveMode() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_InteractiveMode, 0)
}

func (s *PredefKeywordContext) PK_Language() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Language, 0)
}

func (s *PredefKeywordContext) PK_LeftAssoc() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_LeftAssoc, 0)
}

func (s *PredefKeywordContext) PK_License() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_License, 0)
}

func (s *PredefKeywordContext) PK_Named() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Named, 0)
}

func (s *PredefKeywordContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *PredefKeywordContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *PredefKeywordContext) PK_Pattern() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Pattern, 0)
}

func (s *PredefKeywordContext) PK_PrintSuccess() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_PrintSuccess, 0)
}

func (s *PredefKeywordContext) PK_ProduceAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssertions, 0)
}

func (s *PredefKeywordContext) PK_ProduceAssignments() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssignments, 0)
}

func (s *PredefKeywordContext) PK_ProduceModels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceModels, 0)
}

func (s *PredefKeywordContext) PK_ProduceProofs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceProofs, 0)
}

func (s *PredefKeywordContext) PK_ProduceUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatAssumptions, 0)
}

func (s *PredefKeywordContext) PK_ProduceUnsatCores() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatCores, 0)
}

func (s *PredefKeywordContext) PK_RandomSeed() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RandomSeed, 0)
}

func (s *PredefKeywordContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *PredefKeywordContext) PK_RegularOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RegularOutputChannel, 0)
}

func (s *PredefKeywordContext) PK_ReproducibleResourceLimit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReproducibleResourceLimit, 0)
}

func (s *PredefKeywordContext) PK_RightAssoc() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RightAssoc, 0)
}

func (s *PredefKeywordContext) PK_SmtLibVersion() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SmtLibVersion, 0)
}

func (s *PredefKeywordContext) PK_Sorts() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Sorts, 0)
}

func (s *PredefKeywordContext) PK_SortsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SortsDescription, 0)
}

func (s *PredefKeywordContext) PK_Source() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Source, 0)
}

func (s *PredefKeywordContext) PK_Status() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Status, 0)
}

func (s *PredefKeywordContext) PK_Theories() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Theories, 0)
}

func (s *PredefKeywordContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *PredefKeywordContext) PK_Verbosity() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Verbosity, 0)
}

func (s *PredefKeywordContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *PredefKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPredefKeyword(s)
	}
}

func (s *PredefKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPredefKeyword(s)
	}
}

func (s *PredefKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPredefKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) PredefKeyword() (localctx IPredefKeywordContext) {
	localctx = NewPredefKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SMTLIBv2ParserRULE_predefKeyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(216)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&2199023255551) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleSymbol() ISimpleSymbolContext
	QuotedSymbol() IQuotedSymbolContext

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_symbol
	return p
}

func InitEmptySymbolContext(p *SymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_symbol
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) SimpleSymbol() ISimpleSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleSymbolContext)
}

func (s *SymbolContext) QuotedSymbol() IQuotedSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedSymbolContext)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (s *SymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SMTLIBv2ParserRULE_symbol)
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(218)
			p.SimpleSymbol()
		}

	case SMTLIBv2ParserQuotedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(219)
			p.QuotedSymbol()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumeralContext is an interface to support dynamic dispatch.
type INumeralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Numeral() antlr.TerminalNode

	// IsNumeralContext differentiates from other interfaces.
	IsNumeralContext()
}

type NumeralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeralContext() *NumeralContext {
	var p = new(NumeralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_numeral
	return p
}

func InitEmptyNumeralContext(p *NumeralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_numeral
}

func (*NumeralContext) IsNumeralContext() {}

func NewNumeralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumeralContext {
	var p = new(NumeralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_numeral

	return p
}

func (s *NumeralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumeralContext) Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserNumeral, 0)
}

func (s *NumeralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumeralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumeralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterNumeral(s)
	}
}

func (s *NumeralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitNumeral(s)
	}
}

func (s *NumeralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitNumeral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Numeral() (localctx INumeralContext) {
	localctx = NewNumeralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SMTLIBv2ParserRULE_numeral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(SMTLIBv2ParserNumeral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalContext is an interface to support dynamic dispatch.
type IDecimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Decimal() antlr.TerminalNode

	// IsDecimalContext differentiates from other interfaces.
	IsDecimalContext()
}

type DecimalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalContext() *DecimalContext {
	var p = new(DecimalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_decimal
	return p
}

func InitEmptyDecimalContext(p *DecimalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_decimal
}

func (*DecimalContext) IsDecimalContext() {}

func NewDecimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalContext {
	var p = new(DecimalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_decimal

	return p
}

func (s *DecimalContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalContext) Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserDecimal, 0)
}

func (s *DecimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterDecimal(s)
	}
}

func (s *DecimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitDecimal(s)
	}
}

func (s *DecimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitDecimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Decimal() (localctx IDecimalContext) {
	localctx = NewDecimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SMTLIBv2ParserRULE_decimal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(SMTLIBv2ParserDecimal)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexadecimalContext is an interface to support dynamic dispatch.
type IHexadecimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HexDecimal() antlr.TerminalNode

	// IsHexadecimalContext differentiates from other interfaces.
	IsHexadecimalContext()
}

type HexadecimalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalContext() *HexadecimalContext {
	var p = new(HexadecimalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal
	return p
}

func InitEmptyHexadecimalContext(p *HexadecimalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal
}

func (*HexadecimalContext) IsHexadecimalContext() {}

func NewHexadecimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalContext {
	var p = new(HexadecimalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal

	return p
}

func (s *HexadecimalContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalContext) HexDecimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserHexDecimal, 0)
}

func (s *HexadecimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterHexadecimal(s)
	}
}

func (s *HexadecimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitHexadecimal(s)
	}
}

func (s *HexadecimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitHexadecimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Hexadecimal() (localctx IHexadecimalContext) {
	localctx = NewHexadecimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SMTLIBv2ParserRULE_hexadecimal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(SMTLIBv2ParserHexDecimal)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Binary() antlr.TerminalNode

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_binary
	return p
}

func InitEmptyBinaryContext(p *BinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_binary
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) Binary() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserBinary, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitBinary(s)
	}
}

func (s *BinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SMTLIBv2ParserRULE_binary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(228)
		p.Match(SMTLIBv2ParserBinary)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_() antlr.TerminalNode

	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_string_
	return p
}

func InitEmptyString_Context(p *String_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_string_
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) String_() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserString_, 0)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterString_(s)
	}
}

func (s *String_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitString_(s)
	}
}

func (s *String_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitString_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SMTLIBv2ParserRULE_string_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(SMTLIBv2ParserString_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredefKeyword() IPredefKeywordContext
	Colon() antlr.TerminalNode
	SimpleSymbol() ISimpleSymbolContext

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) PredefKeyword() IPredefKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefKeywordContext)
}

func (s *KeywordContext) Colon() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserColon, 0)
}

func (s *KeywordContext) SimpleSymbol() ISimpleSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleSymbolContext)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SMTLIBv2ParserRULE_keyword)
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPK_AllStatistics, SMTLIBv2ParserPK_AssertionStackLevels, SMTLIBv2ParserPK_Authors, SMTLIBv2ParserPK_Category, SMTLIBv2ParserPK_Chainable, SMTLIBv2ParserPK_Definition, SMTLIBv2ParserPK_DiagnosticOutputChannel, SMTLIBv2ParserPK_ErrorBehaviour, SMTLIBv2ParserPK_Extension, SMTLIBv2ParserPK_Funs, SMTLIBv2ParserPK_FunsDescription, SMTLIBv2ParserPK_GlobalDeclarations, SMTLIBv2ParserPK_InteractiveMode, SMTLIBv2ParserPK_Language, SMTLIBv2ParserPK_LeftAssoc, SMTLIBv2ParserPK_License, SMTLIBv2ParserPK_Named, SMTLIBv2ParserPK_Name, SMTLIBv2ParserPK_Notes, SMTLIBv2ParserPK_Pattern, SMTLIBv2ParserPK_PrintSuccess, SMTLIBv2ParserPK_ProduceAssertions, SMTLIBv2ParserPK_ProduceAssignments, SMTLIBv2ParserPK_ProduceModels, SMTLIBv2ParserPK_ProduceProofs, SMTLIBv2ParserPK_ProduceUnsatAssumptions, SMTLIBv2ParserPK_ProduceUnsatCores, SMTLIBv2ParserPK_RandomSeed, SMTLIBv2ParserPK_ReasonUnknown, SMTLIBv2ParserPK_RegularOutputChannel, SMTLIBv2ParserPK_ReproducibleResourceLimit, SMTLIBv2ParserPK_RightAssoc, SMTLIBv2ParserPK_SmtLibVersion, SMTLIBv2ParserPK_Sorts, SMTLIBv2ParserPK_SortsDescription, SMTLIBv2ParserPK_Source, SMTLIBv2ParserPK_Status, SMTLIBv2ParserPK_Theories, SMTLIBv2ParserPK_Values, SMTLIBv2ParserPK_Verbosity, SMTLIBv2ParserPK_Version:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(232)
			p.PredefKeyword()
		}

	case SMTLIBv2ParserColon:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(233)
			p.Match(SMTLIBv2ParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(234)
			p.SimpleSymbol()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpec_constantContext is an interface to support dynamic dispatch.
type ISpec_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Numeral() INumeralContext
	Decimal() IDecimalContext
	Hexadecimal() IHexadecimalContext
	Binary() IBinaryContext
	String_() IString_Context

	// IsSpec_constantContext differentiates from other interfaces.
	IsSpec_constantContext()
}

type Spec_constantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpec_constantContext() *Spec_constantContext {
	var p = new(Spec_constantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant
	return p
}

func InitEmptySpec_constantContext(p *Spec_constantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant
}

func (*Spec_constantContext) IsSpec_constantContext() {}

func NewSpec_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Spec_constantContext {
	var p = new(Spec_constantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant

	return p
}

func (s *Spec_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Spec_constantContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Spec_constantContext) Decimal() IDecimalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalContext)
}

func (s *Spec_constantContext) Hexadecimal() IHexadecimalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalContext)
}

func (s *Spec_constantContext) Binary() IBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *Spec_constantContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Spec_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Spec_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Spec_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSpec_constant(s)
	}
}

func (s *Spec_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSpec_constant(s)
	}
}

func (s *Spec_constantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSpec_constant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Spec_constant() (localctx ISpec_constantContext) {
	localctx = NewSpec_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SMTLIBv2ParserRULE_spec_constant)
	p.SetState(242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserNumeral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(237)
			p.Numeral()
		}

	case SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(238)
			p.Decimal()
		}

	case SMTLIBv2ParserHexDecimal:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(239)
			p.Hexadecimal()
		}

	case SMTLIBv2ParserBinary:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(240)
			p.Binary()
		}

	case SMTLIBv2ParserString_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(241)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IS_exprContext is an interface to support dynamic dispatch.
type IS_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Spec_constant() ISpec_constantContext
	Symbol() ISymbolContext
	Keyword() IKeywordContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllS_expr() []IS_exprContext
	S_expr(i int) IS_exprContext

	// IsS_exprContext differentiates from other interfaces.
	IsS_exprContext()
}

type S_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyS_exprContext() *S_exprContext {
	var p = new(S_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr
	return p
}

func InitEmptyS_exprContext(p *S_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr
}

func (*S_exprContext) IsS_exprContext() {}

func NewS_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *S_exprContext {
	var p = new(S_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr

	return p
}

func (s *S_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *S_exprContext) Spec_constant() ISpec_constantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpec_constantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *S_exprContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *S_exprContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *S_exprContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *S_exprContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *S_exprContext) AllS_expr() []IS_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IS_exprContext); ok {
			len++
		}
	}

	tst := make([]IS_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IS_exprContext); ok {
			tst[i] = t.(IS_exprContext)
			i++
		}
	}

	return tst
}

func (s *S_exprContext) S_expr(i int) IS_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IS_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *S_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *S_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *S_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterS_expr(s)
	}
}

func (s *S_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitS_expr(s)
	}
}

func (s *S_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitS_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) S_expr() (localctx IS_exprContext) {
	localctx = NewS_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SMTLIBv2ParserRULE_s_expr)
	var _la int

	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserString_, SMTLIBv2ParserNumeral, SMTLIBv2ParserBinary, SMTLIBv2ParserHexDecimal, SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(244)
			p.Spec_constant()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(245)
			p.Symbol()
		}

	case SMTLIBv2ParserColon, SMTLIBv2ParserPK_AllStatistics, SMTLIBv2ParserPK_AssertionStackLevels, SMTLIBv2ParserPK_Authors, SMTLIBv2ParserPK_Category, SMTLIBv2ParserPK_Chainable, SMTLIBv2ParserPK_Definition, SMTLIBv2ParserPK_DiagnosticOutputChannel, SMTLIBv2ParserPK_ErrorBehaviour, SMTLIBv2ParserPK_Extension, SMTLIBv2ParserPK_Funs, SMTLIBv2ParserPK_FunsDescription, SMTLIBv2ParserPK_GlobalDeclarations, SMTLIBv2ParserPK_InteractiveMode, SMTLIBv2ParserPK_Language, SMTLIBv2ParserPK_LeftAssoc, SMTLIBv2ParserPK_License, SMTLIBv2ParserPK_Named, SMTLIBv2ParserPK_Name, SMTLIBv2ParserPK_Notes, SMTLIBv2ParserPK_Pattern, SMTLIBv2ParserPK_PrintSuccess, SMTLIBv2ParserPK_ProduceAssertions, SMTLIBv2ParserPK_ProduceAssignments, SMTLIBv2ParserPK_ProduceModels, SMTLIBv2ParserPK_ProduceProofs, SMTLIBv2ParserPK_ProduceUnsatAssumptions, SMTLIBv2ParserPK_ProduceUnsatCores, SMTLIBv2ParserPK_RandomSeed, SMTLIBv2ParserPK_ReasonUnknown, SMTLIBv2ParserPK_RegularOutputChannel, SMTLIBv2ParserPK_ReproducibleResourceLimit, SMTLIBv2ParserPK_RightAssoc, SMTLIBv2ParserPK_SmtLibVersion, SMTLIBv2ParserPK_Sorts, SMTLIBv2ParserPK_SortsDescription, SMTLIBv2ParserPK_Source, SMTLIBv2ParserPK_Status, SMTLIBv2ParserPK_Theories, SMTLIBv2ParserPK_Values, SMTLIBv2ParserPK_Verbosity, SMTLIBv2ParserPK_Version:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(246)
			p.Keyword()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(247)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388580) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&211106232532991) != 0) {
			{
				p.SetState(248)
				p.S_expr()
			}

			p.SetState(253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(254)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexContext is an interface to support dynamic dispatch.
type IIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Numeral() INumeralContext
	Symbol() ISymbolContext

	// IsIndexContext differentiates from other interfaces.
	IsIndexContext()
}

type IndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexContext() *IndexContext {
	var p = new(IndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_index
	return p
}

func InitEmptyIndexContext(p *IndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_index
}

func (*IndexContext) IsIndexContext() {}

func NewIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexContext {
	var p = new(IndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_index

	return p
}

func (s *IndexContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *IndexContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *IndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterIndex(s)
	}
}

func (s *IndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitIndex(s)
	}
}

func (s *IndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Index() (localctx IIndexContext) {
	localctx = NewIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SMTLIBv2ParserRULE_index)
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserNumeral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(257)
			p.Numeral()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(258)
			p.Symbol()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext
	ParOpen() antlr.TerminalNode
	GRW_Underscore() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllIndex() []IIndexContext
	Index(i int) IIndexContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *IdentifierContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *IdentifierContext) GRW_Underscore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Underscore, 0)
}

func (s *IdentifierContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *IdentifierContext) AllIndex() []IIndexContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexContext); ok {
			len++
		}
	}

	tst := make([]IIndexContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexContext); ok {
			tst[i] = t.(IIndexContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) Index(i int) IIndexContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SMTLIBv2ParserRULE_identifier)
	var _la int

	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(261)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(262)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(263)
			p.Match(SMTLIBv2ParserGRW_Underscore)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(264)
			p.Symbol()
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserNumeral || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(265)
				p.Index()
			}

			p.SetState(268)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(270)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttribute_valueContext is an interface to support dynamic dispatch.
type IAttribute_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Spec_constant() ISpec_constantContext
	Symbol() ISymbolContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllS_expr() []IS_exprContext
	S_expr(i int) IS_exprContext

	// IsAttribute_valueContext differentiates from other interfaces.
	IsAttribute_valueContext()
}

type Attribute_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_valueContext() *Attribute_valueContext {
	var p = new(Attribute_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value
	return p
}

func InitEmptyAttribute_valueContext(p *Attribute_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value
}

func (*Attribute_valueContext) IsAttribute_valueContext() {}

func NewAttribute_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_valueContext {
	var p = new(Attribute_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value

	return p
}

func (s *Attribute_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_valueContext) Spec_constant() ISpec_constantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpec_constantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *Attribute_valueContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Attribute_valueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Attribute_valueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Attribute_valueContext) AllS_expr() []IS_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IS_exprContext); ok {
			len++
		}
	}

	tst := make([]IS_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IS_exprContext); ok {
			tst[i] = t.(IS_exprContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_valueContext) S_expr(i int) IS_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IS_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Attribute_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterAttribute_value(s)
	}
}

func (s *Attribute_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitAttribute_value(s)
	}
}

func (s *Attribute_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitAttribute_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Attribute_value() (localctx IAttribute_valueContext) {
	localctx = NewAttribute_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SMTLIBv2ParserRULE_attribute_value)
	var _la int

	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserString_, SMTLIBv2ParserNumeral, SMTLIBv2ParserBinary, SMTLIBv2ParserHexDecimal, SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(274)
			p.Spec_constant()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(275)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(276)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388580) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&211106232532991) != 0) {
			{
				p.SetState(277)
				p.S_expr()
			}

			p.SetState(282)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(283)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keyword() IKeywordContext
	Attribute_value() IAttribute_valueContext

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute
	return p
}

func InitEmptyAttributeContext(p *AttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *AttributeContext) Attribute_value() IAttribute_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribute_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SMTLIBv2ParserRULE_attribute)
	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(286)
			p.Keyword()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(287)
			p.Keyword()
		}
		{
			p.SetState(288)
			p.Attribute_value()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortContext is an interface to support dynamic dispatch.
type ISortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllSort() []ISortContext
	Sort(i int) ISortContext

	// IsSortContext differentiates from other interfaces.
	IsSortContext()
}

type SortContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortContext() *SortContext {
	var p = new(SortContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort
	return p
}

func InitEmptySortContext(p *SortContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort
}

func (*SortContext) IsSortContext() {}

func NewSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortContext {
	var p = new(SortContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort

	return p
}

func (s *SortContext) GetParser() antlr.Parser { return s.parser }

func (s *SortContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SortContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *SortContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *SortContext) AllSort() []ISortContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortContext); ok {
			len++
		}
	}

	tst := make([]ISortContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortContext); ok {
			tst[i] = t.(ISortContext)
			i++
		}
	}

	return tst
}

func (s *SortContext) Sort(i int) ISortContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *SortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort(s)
	}
}

func (s *SortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort(s)
	}
}

func (s *SortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort() (localctx ISortContext) {
	localctx = NewSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SMTLIBv2ParserRULE_sort)
	var _la int

	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(292)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(293)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(294)
			p.Identifier()
		}
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388548) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(295)
				p.Sort()
			}

			p.SetState(298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(300)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQual_identiferContext is an interface to support dynamic dispatch.
type IQual_identiferContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ParOpen() antlr.TerminalNode
	GRW_As() antlr.TerminalNode
	Sort() ISortContext
	ParClose() antlr.TerminalNode

	// IsQual_identiferContext differentiates from other interfaces.
	IsQual_identiferContext()
}

type Qual_identiferContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQual_identiferContext() *Qual_identiferContext {
	var p = new(Qual_identiferContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer
	return p
}

func InitEmptyQual_identiferContext(p *Qual_identiferContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer
}

func (*Qual_identiferContext) IsQual_identiferContext() {}

func NewQual_identiferContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qual_identiferContext {
	var p = new(Qual_identiferContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer

	return p
}

func (s *Qual_identiferContext) GetParser() antlr.Parser { return s.parser }

func (s *Qual_identiferContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Qual_identiferContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Qual_identiferContext) GRW_As() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_As, 0)
}

func (s *Qual_identiferContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Qual_identiferContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Qual_identiferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qual_identiferContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qual_identiferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterQual_identifer(s)
	}
}

func (s *Qual_identiferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitQual_identifer(s)
	}
}

func (s *Qual_identiferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitQual_identifer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Qual_identifer() (localctx IQual_identiferContext) {
	localctx = NewQual_identiferContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SMTLIBv2ParserRULE_qual_identifer)
	p.SetState(311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(304)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(305)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(306)
			p.Match(SMTLIBv2ParserGRW_As)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(307)
			p.Identifier()
		}
		{
			p.SetState(308)
			p.Sort()
		}
		{
			p.SetState(309)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVar_bindingContext is an interface to support dynamic dispatch.
type IVar_bindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Symbol() ISymbolContext
	Term() ITermContext
	ParClose() antlr.TerminalNode

	// IsVar_bindingContext differentiates from other interfaces.
	IsVar_bindingContext()
}

type Var_bindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_bindingContext() *Var_bindingContext {
	var p = new(Var_bindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding
	return p
}

func InitEmptyVar_bindingContext(p *Var_bindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding
}

func (*Var_bindingContext) IsVar_bindingContext() {}

func NewVar_bindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_bindingContext {
	var p = new(Var_bindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding

	return p
}

func (s *Var_bindingContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_bindingContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Var_bindingContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Var_bindingContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Var_bindingContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Var_bindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_bindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_bindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterVar_binding(s)
	}
}

func (s *Var_bindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitVar_binding(s)
	}
}

func (s *Var_bindingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitVar_binding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Var_binding() (localctx IVar_bindingContext) {
	localctx = NewVar_bindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SMTLIBv2ParserRULE_var_binding)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(314)
		p.Symbol()
	}
	{
		p.SetState(315)
		p.Term()
	}
	{
		p.SetState(316)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISorted_varContext is an interface to support dynamic dispatch.
type ISorted_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Symbol() ISymbolContext
	Sort() ISortContext
	ParClose() antlr.TerminalNode

	// IsSorted_varContext differentiates from other interfaces.
	IsSorted_varContext()
}

type Sorted_varContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySorted_varContext() *Sorted_varContext {
	var p = new(Sorted_varContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var
	return p
}

func InitEmptySorted_varContext(p *Sorted_varContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var
}

func (*Sorted_varContext) IsSorted_varContext() {}

func NewSorted_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sorted_varContext {
	var p = new(Sorted_varContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var

	return p
}

func (s *Sorted_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Sorted_varContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sorted_varContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Sorted_varContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Sorted_varContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sorted_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sorted_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sorted_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSorted_var(s)
	}
}

func (s *Sorted_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSorted_var(s)
	}
}

func (s *Sorted_varContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSorted_var(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sorted_var() (localctx ISorted_varContext) {
	localctx = NewSorted_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SMTLIBv2ParserRULE_sorted_var)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(319)
		p.Symbol()
	}
	{
		p.SetState(320)
		p.Sort()
	}
	{
		p.SetState(321)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *PatternContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *PatternContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPattern(s)
	}
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SMTLIBv2ParserRULE_pattern)
	var _la int

	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(323)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(324)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(325)
			p.Symbol()
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(326)
				p.Symbol()
			}

			p.SetState(329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(331)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_caseContext is an interface to support dynamic dispatch.
type IMatch_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Pattern() IPatternContext
	Term() ITermContext
	ParClose() antlr.TerminalNode

	// IsMatch_caseContext differentiates from other interfaces.
	IsMatch_caseContext()
}

type Match_caseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_caseContext() *Match_caseContext {
	var p = new(Match_caseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_match_case
	return p
}

func InitEmptyMatch_caseContext(p *Match_caseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_match_case
}

func (*Match_caseContext) IsMatch_caseContext() {}

func NewMatch_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_caseContext {
	var p = new(Match_caseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_match_case

	return p
}

func (s *Match_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_caseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Match_caseContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Match_caseContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Match_caseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Match_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterMatch_case(s)
	}
}

func (s *Match_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitMatch_case(s)
	}
}

func (s *Match_caseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitMatch_case(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Match_case() (localctx IMatch_caseContext) {
	localctx = NewMatch_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SMTLIBv2ParserRULE_match_case)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(336)
		p.Pattern()
	}
	{
		p.SetState(337)
		p.Term()
	}
	{
		p.SetState(338)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SMTLIBv2ParserRULE_variable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Symbol()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Spec_constant() ISpec_constantContext
	Qual_identifer() IQual_identiferContext
	AllParOpen() []antlr.TerminalNode
	ParOpen(i int) antlr.TerminalNode
	AllParClose() []antlr.TerminalNode
	ParClose(i int) antlr.TerminalNode
	AllTerm() []ITermContext
	Term(i int) ITermContext
	GRW_Let() antlr.TerminalNode
	AllVar_binding() []IVar_bindingContext
	Var_binding(i int) IVar_bindingContext
	GRW_Forall() antlr.TerminalNode
	AllSorted_var() []ISorted_varContext
	Sorted_var(i int) ISorted_varContext
	GRW_Exists() antlr.TerminalNode
	GRW_Match() antlr.TerminalNode
	AllMatch_case() []IMatch_caseContext
	Match_case(i int) IMatch_caseContext
	GRW_Exclamation() antlr.TerminalNode
	AllAttribute() []IAttributeContext
	Attribute(i int) IAttributeContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) Spec_constant() ISpec_constantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpec_constantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *TermContext) Qual_identifer() IQual_identiferContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQual_identiferContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQual_identiferContext)
}

func (s *TermContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *TermContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *TermContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *TermContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *TermContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GRW_Let() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Let, 0)
}

func (s *TermContext) AllVar_binding() []IVar_bindingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVar_bindingContext); ok {
			len++
		}
	}

	tst := make([]IVar_bindingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVar_bindingContext); ok {
			tst[i] = t.(IVar_bindingContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Var_binding(i int) IVar_bindingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_bindingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_bindingContext)
}

func (s *TermContext) GRW_Forall() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Forall, 0)
}

func (s *TermContext) AllSorted_var() []ISorted_varContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISorted_varContext); ok {
			len++
		}
	}

	tst := make([]ISorted_varContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISorted_varContext); ok {
			tst[i] = t.(ISorted_varContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Sorted_var(i int) ISorted_varContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISorted_varContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *TermContext) GRW_Exists() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exists, 0)
}

func (s *TermContext) GRW_Match() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Match, 0)
}

func (s *TermContext) AllMatch_case() []IMatch_caseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatch_caseContext); ok {
			len++
		}
	}

	tst := make([]IMatch_caseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatch_caseContext); ok {
			tst[i] = t.(IMatch_caseContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Match_case(i int) IMatch_caseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_caseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_caseContext)
}

func (s *TermContext) GRW_Exclamation() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exclamation, 0)
}

func (s *TermContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *TermContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SMTLIBv2ParserRULE_term)
	var _la int

	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(342)
			p.Spec_constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(343)
			p.Qual_identifer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(344)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)
			p.Qual_identifer()
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388580) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&140737488355343) != 0) {
			{
				p.SetState(346)
				p.Term()
			}

			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(351)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(353)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(354)
			p.Match(SMTLIBv2ParserGRW_Let)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(355)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(356)
				p.Var_binding()
			}

			p.SetState(359)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(361)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(362)
			p.Term()
		}
		{
			p.SetState(363)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(365)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.Match(SMTLIBv2ParserGRW_Forall)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(367)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(368)
				p.Sorted_var()
			}

			p.SetState(371)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(373)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.Term()
		}
		{
			p.SetState(375)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(377)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.Match(SMTLIBv2ParserGRW_Exists)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(379)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(380)
				p.Sorted_var()
			}

			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(385)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(386)
			p.Term()
		}
		{
			p.SetState(387)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(389)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(390)
			p.Match(SMTLIBv2ParserGRW_Match)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(391)
			p.Term()
		}
		{
			p.SetState(392)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(393)
				p.Match_case()
			}

			p.SetState(396)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(398)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(399)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(401)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)
			p.Match(SMTLIBv2ParserGRW_Exclamation)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(403)
			p.Term()
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0) {
			{
				p.SetState(404)
				p.Attribute()
			}

			p.SetState(407)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(409)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_symbol_declContext is an interface to support dynamic dispatch.
type ISort_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Identifier() IIdentifierContext
	Numeral() INumeralContext
	ParClose() antlr.TerminalNode
	AllAttribute() []IAttributeContext
	Attribute(i int) IAttributeContext

	// IsSort_symbol_declContext differentiates from other interfaces.
	IsSort_symbol_declContext()
}

type Sort_symbol_declContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_symbol_declContext() *Sort_symbol_declContext {
	var p = new(Sort_symbol_declContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl
	return p
}

func InitEmptySort_symbol_declContext(p *Sort_symbol_declContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl
}

func (*Sort_symbol_declContext) IsSort_symbol_declContext() {}

func NewSort_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_symbol_declContext {
	var p = new(Sort_symbol_declContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl

	return p
}

func (s *Sort_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_symbol_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sort_symbol_declContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Sort_symbol_declContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Sort_symbol_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sort_symbol_declContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *Sort_symbol_declContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Sort_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort_symbol_decl(s)
	}
}

func (s *Sort_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort_symbol_decl(s)
	}
}

func (s *Sort_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort_symbol_decl() (localctx ISort_symbol_declContext) {
	localctx = NewSort_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SMTLIBv2ParserRULE_sort_symbol_decl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(414)
		p.Identifier()
	}
	{
		p.SetState(415)
		p.Numeral()
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0 {
		{
			p.SetState(416)
			p.Attribute()
		}

		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(422)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMeta_spec_constantContext is an interface to support dynamic dispatch.
type IMeta_spec_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRW_Numeral() antlr.TerminalNode
	GRW_Decimal() antlr.TerminalNode
	GRW_String() antlr.TerminalNode

	// IsMeta_spec_constantContext differentiates from other interfaces.
	IsMeta_spec_constantContext()
}

type Meta_spec_constantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeta_spec_constantContext() *Meta_spec_constantContext {
	var p = new(Meta_spec_constantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant
	return p
}

func InitEmptyMeta_spec_constantContext(p *Meta_spec_constantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant
}

func (*Meta_spec_constantContext) IsMeta_spec_constantContext() {}

func NewMeta_spec_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Meta_spec_constantContext {
	var p = new(Meta_spec_constantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant

	return p
}

func (s *Meta_spec_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Meta_spec_constantContext) GRW_Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Numeral, 0)
}

func (s *Meta_spec_constantContext) GRW_Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Decimal, 0)
}

func (s *Meta_spec_constantContext) GRW_String() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_String, 0)
}

func (s *Meta_spec_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Meta_spec_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Meta_spec_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterMeta_spec_constant(s)
	}
}

func (s *Meta_spec_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitMeta_spec_constant(s)
	}
}

func (s *Meta_spec_constantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitMeta_spec_constant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Meta_spec_constant() (localctx IMeta_spec_constantContext) {
	localctx = NewMeta_spec_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SMTLIBv2ParserRULE_meta_spec_constant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-57)) & ^0x3f) == 0 && ((int64(1)<<(_la-57))&321) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFun_symbol_declContext is an interface to support dynamic dispatch.
type IFun_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Spec_constant() ISpec_constantContext
	AllSort() []ISortContext
	Sort(i int) ISortContext
	ParClose() antlr.TerminalNode
	AllAttribute() []IAttributeContext
	Attribute(i int) IAttributeContext
	Meta_spec_constant() IMeta_spec_constantContext
	Identifier() IIdentifierContext

	// IsFun_symbol_declContext differentiates from other interfaces.
	IsFun_symbol_declContext()
}

type Fun_symbol_declContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFun_symbol_declContext() *Fun_symbol_declContext {
	var p = new(Fun_symbol_declContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl
	return p
}

func InitEmptyFun_symbol_declContext(p *Fun_symbol_declContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl
}

func (*Fun_symbol_declContext) IsFun_symbol_declContext() {}

func NewFun_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fun_symbol_declContext {
	var p = new(Fun_symbol_declContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl

	return p
}

func (s *Fun_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Fun_symbol_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Fun_symbol_declContext) Spec_constant() ISpec_constantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpec_constantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *Fun_symbol_declContext) AllSort() []ISortContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortContext); ok {
			len++
		}
	}

	tst := make([]ISortContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortContext); ok {
			tst[i] = t.(ISortContext)
			i++
		}
	}

	return tst
}

func (s *Fun_symbol_declContext) Sort(i int) ISortContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Fun_symbol_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Fun_symbol_declContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *Fun_symbol_declContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Fun_symbol_declContext) Meta_spec_constant() IMeta_spec_constantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeta_spec_constantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeta_spec_constantContext)
}

func (s *Fun_symbol_declContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Fun_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fun_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fun_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFun_symbol_decl(s)
	}
}

func (s *Fun_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFun_symbol_decl(s)
	}
}

func (s *Fun_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFun_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Fun_symbol_decl() (localctx IFun_symbol_declContext) {
	localctx = NewFun_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SMTLIBv2ParserRULE_fun_symbol_decl)
	var _la int

	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(426)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Spec_constant()
		}
		{
			p.SetState(428)
			p.Sort()
		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0 {
			{
				p.SetState(429)
				p.Attribute()
			}

			p.SetState(434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(435)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(437)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			p.Meta_spec_constant()
		}
		{
			p.SetState(439)
			p.Sort()
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0 {
			{
				p.SetState(440)
				p.Attribute()
			}

			p.SetState(445)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(446)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(448)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(449)
			p.Identifier()
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388548) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(450)
				p.Sort()
			}

			p.SetState(453)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0 {
			{
				p.SetState(455)
				p.Attribute()
			}

			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(461)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPar_fun_symbol_declContext is an interface to support dynamic dispatch.
type IPar_fun_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Fun_symbol_decl() IFun_symbol_declContext
	AllParOpen() []antlr.TerminalNode
	ParOpen(i int) antlr.TerminalNode
	GRW_Par() antlr.TerminalNode
	AllParClose() []antlr.TerminalNode
	ParClose(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext
	AllSort() []ISortContext
	Sort(i int) ISortContext
	AllAttribute() []IAttributeContext
	Attribute(i int) IAttributeContext

	// IsPar_fun_symbol_declContext differentiates from other interfaces.
	IsPar_fun_symbol_declContext()
}

type Par_fun_symbol_declContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_fun_symbol_declContext() *Par_fun_symbol_declContext {
	var p = new(Par_fun_symbol_declContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl
	return p
}

func InitEmptyPar_fun_symbol_declContext(p *Par_fun_symbol_declContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl
}

func (*Par_fun_symbol_declContext) IsPar_fun_symbol_declContext() {}

func NewPar_fun_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_fun_symbol_declContext {
	var p = new(Par_fun_symbol_declContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl

	return p
}

func (s *Par_fun_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_fun_symbol_declContext) Fun_symbol_decl() IFun_symbol_declContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFun_symbol_declContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFun_symbol_declContext)
}

func (s *Par_fun_symbol_declContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Par_fun_symbol_declContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Par_fun_symbol_declContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *Par_fun_symbol_declContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Par_fun_symbol_declContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Par_fun_symbol_declContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Par_fun_symbol_declContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Par_fun_symbol_declContext) AllSort() []ISortContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortContext); ok {
			len++
		}
	}

	tst := make([]ISortContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortContext); ok {
			tst[i] = t.(ISortContext)
			i++
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Sort(i int) ISortContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Par_fun_symbol_declContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Par_fun_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_fun_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_fun_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPar_fun_symbol_decl(s)
	}
}

func (s *Par_fun_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPar_fun_symbol_decl(s)
	}
}

func (s *Par_fun_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPar_fun_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Par_fun_symbol_decl() (localctx IPar_fun_symbol_declContext) {
	localctx = NewPar_fun_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SMTLIBv2ParserRULE_par_fun_symbol_decl)
	var _la int

	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(465)
			p.Fun_symbol_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(466)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(467)
			p.Match(SMTLIBv2ParserGRW_Par)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(468)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(469)
				p.Symbol()
			}

			p.SetState(472)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(474)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(475)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.Identifier()
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388548) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(477)
				p.Sort()
			}

			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0 {
			{
				p.SetState(482)
				p.Attribute()
			}

			p.SetState(487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(488)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(489)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITheory_attributeContext is an interface to support dynamic dispatch.
type ITheory_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PK_Sorts() antlr.TerminalNode
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllSort_symbol_decl() []ISort_symbol_declContext
	Sort_symbol_decl(i int) ISort_symbol_declContext
	PK_Funs() antlr.TerminalNode
	AllPar_fun_symbol_decl() []IPar_fun_symbol_declContext
	Par_fun_symbol_decl(i int) IPar_fun_symbol_declContext
	PK_SortsDescription() antlr.TerminalNode
	String_() IString_Context
	PK_FunsDescription() antlr.TerminalNode
	PK_Definition() antlr.TerminalNode
	PK_Values() antlr.TerminalNode
	PK_Notes() antlr.TerminalNode
	Attribute() IAttributeContext

	// IsTheory_attributeContext differentiates from other interfaces.
	IsTheory_attributeContext()
}

type Theory_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_attributeContext() *Theory_attributeContext {
	var p = new(Theory_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute
	return p
}

func InitEmptyTheory_attributeContext(p *Theory_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute
}

func (*Theory_attributeContext) IsTheory_attributeContext() {}

func NewTheory_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_attributeContext {
	var p = new(Theory_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute

	return p
}

func (s *Theory_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_attributeContext) PK_Sorts() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Sorts, 0)
}

func (s *Theory_attributeContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Theory_attributeContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Theory_attributeContext) AllSort_symbol_decl() []ISort_symbol_declContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_symbol_declContext); ok {
			len++
		}
	}

	tst := make([]ISort_symbol_declContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_symbol_declContext); ok {
			tst[i] = t.(ISort_symbol_declContext)
			i++
		}
	}

	return tst
}

func (s *Theory_attributeContext) Sort_symbol_decl(i int) ISort_symbol_declContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_symbol_declContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_symbol_declContext)
}

func (s *Theory_attributeContext) PK_Funs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Funs, 0)
}

func (s *Theory_attributeContext) AllPar_fun_symbol_decl() []IPar_fun_symbol_declContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPar_fun_symbol_declContext); ok {
			len++
		}
	}

	tst := make([]IPar_fun_symbol_declContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPar_fun_symbol_declContext); ok {
			tst[i] = t.(IPar_fun_symbol_declContext)
			i++
		}
	}

	return tst
}

func (s *Theory_attributeContext) Par_fun_symbol_decl(i int) IPar_fun_symbol_declContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPar_fun_symbol_declContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPar_fun_symbol_declContext)
}

func (s *Theory_attributeContext) PK_SortsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SortsDescription, 0)
}

func (s *Theory_attributeContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Theory_attributeContext) PK_FunsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_FunsDescription, 0)
}

func (s *Theory_attributeContext) PK_Definition() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Definition, 0)
}

func (s *Theory_attributeContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *Theory_attributeContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *Theory_attributeContext) Attribute() IAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Theory_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTheory_attribute(s)
	}
}

func (s *Theory_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTheory_attribute(s)
	}
}

func (s *Theory_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTheory_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Theory_attribute() (localctx ITheory_attributeContext) {
	localctx = NewTheory_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SMTLIBv2ParserRULE_theory_attribute)
	var _la int

	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(493)
			p.Match(SMTLIBv2ParserPK_Sorts)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(495)
				p.Sort_symbol_decl()
			}

			p.SetState(498)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(500)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.Match(SMTLIBv2ParserPK_Funs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(503)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(504)
				p.Par_fun_symbol_decl()
			}

			p.SetState(507)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(509)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(511)
			p.Match(SMTLIBv2ParserPK_SortsDescription)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.String_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(513)
			p.Match(SMTLIBv2ParserPK_FunsDescription)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(514)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(515)
			p.Match(SMTLIBv2ParserPK_Definition)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(517)
			p.Match(SMTLIBv2ParserPK_Values)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(518)
			p.String_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(519)
			p.Match(SMTLIBv2ParserPK_Notes)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(520)
			p.String_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(521)
			p.Attribute()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITheory_declContext is an interface to support dynamic dispatch.
type ITheory_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	PS_Theory() antlr.TerminalNode
	Symbol() ISymbolContext
	ParClose() antlr.TerminalNode
	AllTheory_attribute() []ITheory_attributeContext
	Theory_attribute(i int) ITheory_attributeContext

	// IsTheory_declContext differentiates from other interfaces.
	IsTheory_declContext()
}

type Theory_declContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_declContext() *Theory_declContext {
	var p = new(Theory_declContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl
	return p
}

func InitEmptyTheory_declContext(p *Theory_declContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl
}

func (*Theory_declContext) IsTheory_declContext() {}

func NewTheory_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_declContext {
	var p = new(Theory_declContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl

	return p
}

func (s *Theory_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Theory_declContext) PS_Theory() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Theory, 0)
}

func (s *Theory_declContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Theory_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Theory_declContext) AllTheory_attribute() []ITheory_attributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITheory_attributeContext); ok {
			len++
		}
	}

	tst := make([]ITheory_attributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITheory_attributeContext); ok {
			tst[i] = t.(ITheory_attributeContext)
			i++
		}
	}

	return tst
}

func (s *Theory_declContext) Theory_attribute(i int) ITheory_attributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheory_attributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheory_attributeContext)
}

func (s *Theory_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTheory_decl(s)
	}
}

func (s *Theory_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTheory_decl(s)
	}
}

func (s *Theory_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTheory_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Theory_decl() (localctx ITheory_declContext) {
	localctx = NewTheory_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SMTLIBv2ParserRULE_theory_decl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.Match(SMTLIBv2ParserPS_Theory)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(526)
		p.Symbol()
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0) {
		{
			p.SetState(527)
			p.Theory_attribute()
		}

		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(532)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogic_attribueContext is an interface to support dynamic dispatch.
type ILogic_attribueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PK_Theories() antlr.TerminalNode
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext
	PK_Language() antlr.TerminalNode
	String_() IString_Context
	PK_Extension() antlr.TerminalNode
	PK_Values() antlr.TerminalNode
	PK_Notes() antlr.TerminalNode
	Attribute() IAttributeContext

	// IsLogic_attribueContext differentiates from other interfaces.
	IsLogic_attribueContext()
}

type Logic_attribueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogic_attribueContext() *Logic_attribueContext {
	var p = new(Logic_attribueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue
	return p
}

func InitEmptyLogic_attribueContext(p *Logic_attribueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue
}

func (*Logic_attribueContext) IsLogic_attribueContext() {}

func NewLogic_attribueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logic_attribueContext {
	var p = new(Logic_attribueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue

	return p
}

func (s *Logic_attribueContext) GetParser() antlr.Parser { return s.parser }

func (s *Logic_attribueContext) PK_Theories() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Theories, 0)
}

func (s *Logic_attribueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Logic_attribueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Logic_attribueContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *Logic_attribueContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Logic_attribueContext) PK_Language() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Language, 0)
}

func (s *Logic_attribueContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Logic_attribueContext) PK_Extension() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Extension, 0)
}

func (s *Logic_attribueContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *Logic_attribueContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *Logic_attribueContext) Attribute() IAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Logic_attribueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logic_attribueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logic_attribueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterLogic_attribue(s)
	}
}

func (s *Logic_attribueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitLogic_attribue(s)
	}
}

func (s *Logic_attribueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitLogic_attribue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Logic_attribue() (localctx ILogic_attribueContext) {
	localctx = NewLogic_attribueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SMTLIBv2ParserRULE_logic_attribue)
	var _la int

	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.Match(SMTLIBv2ParserPK_Theories)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(535)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(536)
				p.Symbol()
			}

			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(541)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(543)
			p.Match(SMTLIBv2ParserPK_Language)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(544)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(545)
			p.Match(SMTLIBv2ParserPK_Extension)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(546)
			p.String_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(547)
			p.Match(SMTLIBv2ParserPK_Values)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(549)
			p.Match(SMTLIBv2ParserPK_Notes)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(550)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(551)
			p.Attribute()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicContext is an interface to support dynamic dispatch.
type ILogicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	PS_Logic() antlr.TerminalNode
	Symbol() ISymbolContext
	ParClose() antlr.TerminalNode
	AllLogic_attribue() []ILogic_attribueContext
	Logic_attribue(i int) ILogic_attribueContext

	// IsLogicContext differentiates from other interfaces.
	IsLogicContext()
}

type LogicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicContext() *LogicContext {
	var p = new(LogicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic
	return p
}

func InitEmptyLogicContext(p *LogicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic
}

func (*LogicContext) IsLogicContext() {}

func NewLogicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicContext {
	var p = new(LogicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_logic

	return p
}

func (s *LogicContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *LogicContext) PS_Logic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Logic, 0)
}

func (s *LogicContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *LogicContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *LogicContext) AllLogic_attribue() []ILogic_attribueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogic_attribueContext); ok {
			len++
		}
	}

	tst := make([]ILogic_attribueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogic_attribueContext); ok {
			tst[i] = t.(ILogic_attribueContext)
			i++
		}
	}

	return tst
}

func (s *LogicContext) Logic_attribue(i int) ILogic_attribueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogic_attribueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogic_attribueContext)
}

func (s *LogicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterLogic(s)
	}
}

func (s *LogicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitLogic(s)
	}
}

func (s *LogicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitLogic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Logic() (localctx ILogicContext) {
	localctx = NewLogicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SMTLIBv2ParserRULE_logic)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(555)
		p.Match(SMTLIBv2ParserPS_Logic)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(556)
		p.Symbol()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0) {
		{
			p.SetState(557)
			p.Logic_attribue()
		}

		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(562)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_decContext is an interface to support dynamic dispatch.
type ISort_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Symbol() ISymbolContext
	Numeral() INumeralContext
	ParClose() antlr.TerminalNode

	// IsSort_decContext differentiates from other interfaces.
	IsSort_decContext()
}

type Sort_decContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_decContext() *Sort_decContext {
	var p = new(Sort_decContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec
	return p
}

func InitEmptySort_decContext(p *Sort_decContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec
}

func (*Sort_decContext) IsSort_decContext() {}

func NewSort_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_decContext {
	var p = new(Sort_decContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec

	return p
}

func (s *Sort_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sort_decContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Sort_decContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Sort_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sort_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort_dec(s)
	}
}

func (s *Sort_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort_dec(s)
	}
}

func (s *Sort_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort_dec() (localctx ISort_decContext) {
	localctx = NewSort_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SMTLIBv2ParserRULE_sort_dec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(565)
		p.Symbol()
	}
	{
		p.SetState(566)
		p.Numeral()
	}
	{
		p.SetState(567)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelector_decContext is an interface to support dynamic dispatch.
type ISelector_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Symbol() ISymbolContext
	Sort() ISortContext
	ParClose() antlr.TerminalNode

	// IsSelector_decContext differentiates from other interfaces.
	IsSelector_decContext()
}

type Selector_decContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_decContext() *Selector_decContext {
	var p = new(Selector_decContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec
	return p
}

func InitEmptySelector_decContext(p *Selector_decContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec
}

func (*Selector_decContext) IsSelector_decContext() {}

func NewSelector_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_decContext {
	var p = new(Selector_decContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec

	return p
}

func (s *Selector_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Selector_decContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Selector_decContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Selector_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Selector_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selector_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSelector_dec(s)
	}
}

func (s *Selector_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSelector_dec(s)
	}
}

func (s *Selector_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSelector_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Selector_dec() (localctx ISelector_decContext) {
	localctx = NewSelector_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SMTLIBv2ParserRULE_selector_dec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(570)
		p.Symbol()
	}
	{
		p.SetState(571)
		p.Sort()
	}
	{
		p.SetState(572)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructor_decContext is an interface to support dynamic dispatch.
type IConstructor_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Symbol() ISymbolContext
	ParClose() antlr.TerminalNode
	AllSelector_dec() []ISelector_decContext
	Selector_dec(i int) ISelector_decContext

	// IsConstructor_decContext differentiates from other interfaces.
	IsConstructor_decContext()
}

type Constructor_decContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_decContext() *Constructor_decContext {
	var p = new(Constructor_decContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec
	return p
}

func InitEmptyConstructor_decContext(p *Constructor_decContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec
}

func (*Constructor_decContext) IsConstructor_decContext() {}

func NewConstructor_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_decContext {
	var p = new(Constructor_decContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec

	return p
}

func (s *Constructor_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Constructor_decContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Constructor_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Constructor_decContext) AllSelector_dec() []ISelector_decContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelector_decContext); ok {
			len++
		}
	}

	tst := make([]ISelector_decContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelector_decContext); ok {
			tst[i] = t.(ISelector_decContext)
			i++
		}
	}

	return tst
}

func (s *Constructor_decContext) Selector_dec(i int) ISelector_decContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelector_decContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelector_decContext)
}

func (s *Constructor_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterConstructor_dec(s)
	}
}

func (s *Constructor_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitConstructor_dec(s)
	}
}

func (s *Constructor_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitConstructor_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Constructor_dec() (localctx IConstructor_decContext) {
	localctx = NewConstructor_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SMTLIBv2ParserRULE_constructor_dec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.Symbol()
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(576)
			p.Selector_dec()
		}

		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(582)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatype_decContext is an interface to support dynamic dispatch.
type IDatatype_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParOpen() []antlr.TerminalNode
	ParOpen(i int) antlr.TerminalNode
	AllParClose() []antlr.TerminalNode
	ParClose(i int) antlr.TerminalNode
	AllConstructor_dec() []IConstructor_decContext
	Constructor_dec(i int) IConstructor_decContext
	GRW_Par() antlr.TerminalNode
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext

	// IsDatatype_decContext differentiates from other interfaces.
	IsDatatype_decContext()
}

type Datatype_decContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatype_decContext() *Datatype_decContext {
	var p = new(Datatype_decContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec
	return p
}

func InitEmptyDatatype_decContext(p *Datatype_decContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec
}

func (*Datatype_decContext) IsDatatype_decContext() {}

func NewDatatype_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datatype_decContext {
	var p = new(Datatype_decContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec

	return p
}

func (s *Datatype_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Datatype_decContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Datatype_decContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Datatype_decContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Datatype_decContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Datatype_decContext) AllConstructor_dec() []IConstructor_decContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstructor_decContext); ok {
			len++
		}
	}

	tst := make([]IConstructor_decContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstructor_decContext); ok {
			tst[i] = t.(IConstructor_decContext)
			i++
		}
	}

	return tst
}

func (s *Datatype_decContext) Constructor_dec(i int) IConstructor_decContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructor_decContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructor_decContext)
}

func (s *Datatype_decContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *Datatype_decContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *Datatype_decContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Datatype_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datatype_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datatype_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterDatatype_dec(s)
	}
}

func (s *Datatype_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitDatatype_dec(s)
	}
}

func (s *Datatype_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitDatatype_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Datatype_dec() (localctx IDatatype_decContext) {
	localctx = NewDatatype_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SMTLIBv2ParserRULE_datatype_dec)
	var _la int

	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(584)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(585)
				p.Constructor_dec()
			}

			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(590)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(592)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.Match(SMTLIBv2ParserGRW_Par)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(595)
				p.Symbol()
			}

			p.SetState(598)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(600)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(601)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(602)
				p.Constructor_dec()
			}

			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(607)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_decContext is an interface to support dynamic dispatch.
type IFunction_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParOpen() []antlr.TerminalNode
	ParOpen(i int) antlr.TerminalNode
	Symbol() ISymbolContext
	AllParClose() []antlr.TerminalNode
	ParClose(i int) antlr.TerminalNode
	Sort() ISortContext
	AllSorted_var() []ISorted_varContext
	Sorted_var(i int) ISorted_varContext

	// IsFunction_decContext differentiates from other interfaces.
	IsFunction_decContext()
}

type Function_decContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_decContext() *Function_decContext {
	var p = new(Function_decContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec
	return p
}

func InitEmptyFunction_decContext(p *Function_decContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec
}

func (*Function_decContext) IsFunction_decContext() {}

func NewFunction_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_decContext {
	var p = new(Function_decContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec

	return p
}

func (s *Function_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_decContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Function_decContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Function_decContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Function_decContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Function_decContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Function_decContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Function_decContext) AllSorted_var() []ISorted_varContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISorted_varContext); ok {
			len++
		}
	}

	tst := make([]ISorted_varContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISorted_varContext); ok {
			tst[i] = t.(ISorted_varContext)
			i++
		}
	}

	return tst
}

func (s *Function_decContext) Sorted_var(i int) ISorted_varContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISorted_varContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *Function_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFunction_dec(s)
	}
}

func (s *Function_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFunction_dec(s)
	}
}

func (s *Function_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFunction_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Function_dec() (localctx IFunction_decContext) {
	localctx = NewFunction_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SMTLIBv2ParserRULE_function_dec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(613)
		p.Symbol()
	}
	{
		p.SetState(614)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(615)
			p.Sorted_var()
		}

		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(621)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(622)
		p.Sort()
	}
	{
		p.SetState(623)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_defContext is an interface to support dynamic dispatch.
type IFunction_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable() IVariableContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	Sort() ISortContext
	Term() ITermContext
	AllSorted_var() []ISorted_varContext
	Sorted_var(i int) ISorted_varContext

	// IsFunction_defContext differentiates from other interfaces.
	IsFunction_defContext()
}

type Function_defContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_defContext() *Function_defContext {
	var p = new(Function_defContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_def
	return p
}

func InitEmptyFunction_defContext(p *Function_defContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_def
}

func (*Function_defContext) IsFunction_defContext() {}

func NewFunction_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_defContext {
	var p = new(Function_defContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_function_def

	return p
}

func (s *Function_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_defContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Function_defContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Function_defContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Function_defContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Function_defContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Function_defContext) AllSorted_var() []ISorted_varContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISorted_varContext); ok {
			len++
		}
	}

	tst := make([]ISorted_varContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISorted_varContext); ok {
			tst[i] = t.(ISorted_varContext)
			i++
		}
	}

	return tst
}

func (s *Function_defContext) Sorted_var(i int) ISorted_varContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISorted_varContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *Function_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFunction_def(s)
	}
}

func (s *Function_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFunction_def(s)
	}
}

func (s *Function_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFunction_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Function_def() (localctx IFunction_defContext) {
	localctx = NewFunction_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SMTLIBv2ParserRULE_function_def)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Variable()
	}
	{
		p.SetState(626)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(627)
			p.Sorted_var()
		}

		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(633)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(634)
		p.Sort()
	}
	{
		p.SetState(635)
		p.Term()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProp_literalContext is an interface to support dynamic dispatch.
type IProp_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Symbol() ISymbolContext
	ParOpen() antlr.TerminalNode
	PS_Not() antlr.TerminalNode
	ParClose() antlr.TerminalNode

	// IsProp_literalContext differentiates from other interfaces.
	IsProp_literalContext()
}

type Prop_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProp_literalContext() *Prop_literalContext {
	var p = new(Prop_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal
	return p
}

func InitEmptyProp_literalContext(p *Prop_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal
}

func (*Prop_literalContext) IsProp_literalContext() {}

func NewProp_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Prop_literalContext {
	var p = new(Prop_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal

	return p
}

func (s *Prop_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Prop_literalContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Prop_literalContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Prop_literalContext) PS_Not() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Not, 0)
}

func (s *Prop_literalContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Prop_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Prop_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Prop_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterProp_literal(s)
	}
}

func (s *Prop_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitProp_literal(s)
	}
}

func (s *Prop_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitProp_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Prop_literal() (localctx IProp_literalContext) {
	localctx = NewProp_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SMTLIBv2ParserRULE_prop_literal)
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(639)
			p.Match(SMTLIBv2ParserPS_Not)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)
			p.Symbol()
		}
		{
			p.SetState(641)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCommand() []ICommandContext
	Command(i int) ICommandContext

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_script
	return p
}

func InitEmptyScriptContext(p *ScriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_script
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) AllCommand() []ICommandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommandContext); ok {
			len++
		}
	}

	tst := make([]ICommandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommandContext); ok {
			tst[i] = t.(ICommandContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) Command(i int) ICommandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitScript(s)
	}
}

func (s *ScriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitScript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SMTLIBv2ParserRULE_script)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(645)
			p.Command()
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_assertContext is an interface to support dynamic dispatch.
type ICmd_assertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_Assert() antlr.TerminalNode
	Term() ITermContext

	// IsCmd_assertContext differentiates from other interfaces.
	IsCmd_assertContext()
}

type Cmd_assertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_assertContext() *Cmd_assertContext {
	var p = new(Cmd_assertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert
	return p
}

func InitEmptyCmd_assertContext(p *Cmd_assertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert
}

func (*Cmd_assertContext) IsCmd_assertContext() {}

func NewCmd_assertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_assertContext {
	var p = new(Cmd_assertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert

	return p
}

func (s *Cmd_assertContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_assertContext) CMD_Assert() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Assert, 0)
}

func (s *Cmd_assertContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_assertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_assertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_assertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_assert(s)
	}
}

func (s *Cmd_assertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_assert(s)
	}
}

func (s *Cmd_assertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_assert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_assert() (localctx ICmd_assertContext) {
	localctx = NewCmd_assertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SMTLIBv2ParserRULE_cmd_assert)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(SMTLIBv2ParserCMD_Assert)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Term()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_checkSatContext is an interface to support dynamic dispatch.
type ICmd_checkSatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_CheckSat() antlr.TerminalNode

	// IsCmd_checkSatContext differentiates from other interfaces.
	IsCmd_checkSatContext()
}

type Cmd_checkSatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_checkSatContext() *Cmd_checkSatContext {
	var p = new(Cmd_checkSatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat
	return p
}

func InitEmptyCmd_checkSatContext(p *Cmd_checkSatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat
}

func (*Cmd_checkSatContext) IsCmd_checkSatContext() {}

func NewCmd_checkSatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_checkSatContext {
	var p = new(Cmd_checkSatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat

	return p
}

func (s *Cmd_checkSatContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_checkSatContext) CMD_CheckSat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_CheckSat, 0)
}

func (s *Cmd_checkSatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_checkSatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_checkSatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_checkSat(s)
	}
}

func (s *Cmd_checkSatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_checkSat(s)
	}
}

func (s *Cmd_checkSatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_checkSat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_checkSat() (localctx ICmd_checkSatContext) {
	localctx = NewCmd_checkSatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SMTLIBv2ParserRULE_cmd_checkSat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Match(SMTLIBv2ParserCMD_CheckSat)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_checkSatAssumingContext is an interface to support dynamic dispatch.
type ICmd_checkSatAssumingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_CheckSatAssuming() antlr.TerminalNode
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllProp_literal() []IProp_literalContext
	Prop_literal(i int) IProp_literalContext

	// IsCmd_checkSatAssumingContext differentiates from other interfaces.
	IsCmd_checkSatAssumingContext()
}

type Cmd_checkSatAssumingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_checkSatAssumingContext() *Cmd_checkSatAssumingContext {
	var p = new(Cmd_checkSatAssumingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming
	return p
}

func InitEmptyCmd_checkSatAssumingContext(p *Cmd_checkSatAssumingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming
}

func (*Cmd_checkSatAssumingContext) IsCmd_checkSatAssumingContext() {}

func NewCmd_checkSatAssumingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_checkSatAssumingContext {
	var p = new(Cmd_checkSatAssumingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming

	return p
}

func (s *Cmd_checkSatAssumingContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_checkSatAssumingContext) CMD_CheckSatAssuming() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_CheckSatAssuming, 0)
}

func (s *Cmd_checkSatAssumingContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_checkSatAssumingContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_checkSatAssumingContext) AllProp_literal() []IProp_literalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProp_literalContext); ok {
			len++
		}
	}

	tst := make([]IProp_literalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProp_literalContext); ok {
			tst[i] = t.(IProp_literalContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_checkSatAssumingContext) Prop_literal(i int) IProp_literalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProp_literalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProp_literalContext)
}

func (s *Cmd_checkSatAssumingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_checkSatAssumingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_checkSatAssumingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_checkSatAssuming(s)
	}
}

func (s *Cmd_checkSatAssumingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_checkSatAssuming(s)
	}
}

func (s *Cmd_checkSatAssumingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_checkSatAssuming(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_checkSatAssuming() (localctx ICmd_checkSatAssumingContext) {
	localctx = NewCmd_checkSatAssumingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SMTLIBv2ParserRULE_cmd_checkSatAssuming)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(SMTLIBv2ParserCMD_CheckSatAssuming)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388548) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(658)
			p.Prop_literal()
		}

		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(664)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_declareConstContext is an interface to support dynamic dispatch.
type ICmd_declareConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DeclareConst() antlr.TerminalNode
	Symbol() ISymbolContext
	Sort() ISortContext

	// IsCmd_declareConstContext differentiates from other interfaces.
	IsCmd_declareConstContext()
}

type Cmd_declareConstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareConstContext() *Cmd_declareConstContext {
	var p = new(Cmd_declareConstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst
	return p
}

func InitEmptyCmd_declareConstContext(p *Cmd_declareConstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst
}

func (*Cmd_declareConstContext) IsCmd_declareConstContext() {}

func NewCmd_declareConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareConstContext {
	var p = new(Cmd_declareConstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst

	return p
}

func (s *Cmd_declareConstContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareConstContext) CMD_DeclareConst() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareConst, 0)
}

func (s *Cmd_declareConstContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareConstContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_declareConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareConst(s)
	}
}

func (s *Cmd_declareConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareConst(s)
	}
}

func (s *Cmd_declareConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareConst() (localctx ICmd_declareConstContext) {
	localctx = NewCmd_declareConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SMTLIBv2ParserRULE_cmd_declareConst)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(SMTLIBv2ParserCMD_DeclareConst)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(667)
		p.Symbol()
	}
	{
		p.SetState(668)
		p.Sort()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_declareDatatypeContext is an interface to support dynamic dispatch.
type ICmd_declareDatatypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DeclareDatatype() antlr.TerminalNode
	Symbol() ISymbolContext
	Datatype_dec() IDatatype_decContext

	// IsCmd_declareDatatypeContext differentiates from other interfaces.
	IsCmd_declareDatatypeContext()
}

type Cmd_declareDatatypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareDatatypeContext() *Cmd_declareDatatypeContext {
	var p = new(Cmd_declareDatatypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype
	return p
}

func InitEmptyCmd_declareDatatypeContext(p *Cmd_declareDatatypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype
}

func (*Cmd_declareDatatypeContext) IsCmd_declareDatatypeContext() {}

func NewCmd_declareDatatypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareDatatypeContext {
	var p = new(Cmd_declareDatatypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype

	return p
}

func (s *Cmd_declareDatatypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareDatatypeContext) CMD_DeclareDatatype() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareDatatype, 0)
}

func (s *Cmd_declareDatatypeContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareDatatypeContext) Datatype_dec() IDatatype_decContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_decContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_decContext)
}

func (s *Cmd_declareDatatypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareDatatypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareDatatypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareDatatype(s)
	}
}

func (s *Cmd_declareDatatypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareDatatype(s)
	}
}

func (s *Cmd_declareDatatypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareDatatype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareDatatype() (localctx ICmd_declareDatatypeContext) {
	localctx = NewCmd_declareDatatypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SMTLIBv2ParserRULE_cmd_declareDatatype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(SMTLIBv2ParserCMD_DeclareDatatype)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(671)
		p.Symbol()
	}
	{
		p.SetState(672)
		p.Datatype_dec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_declareDatatypesContext is an interface to support dynamic dispatch.
type ICmd_declareDatatypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DeclareDatatypes() antlr.TerminalNode
	AllParOpen() []antlr.TerminalNode
	ParOpen(i int) antlr.TerminalNode
	AllParClose() []antlr.TerminalNode
	ParClose(i int) antlr.TerminalNode
	AllSort_dec() []ISort_decContext
	Sort_dec(i int) ISort_decContext
	AllDatatype_dec() []IDatatype_decContext
	Datatype_dec(i int) IDatatype_decContext

	// IsCmd_declareDatatypesContext differentiates from other interfaces.
	IsCmd_declareDatatypesContext()
}

type Cmd_declareDatatypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareDatatypesContext() *Cmd_declareDatatypesContext {
	var p = new(Cmd_declareDatatypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes
	return p
}

func InitEmptyCmd_declareDatatypesContext(p *Cmd_declareDatatypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes
}

func (*Cmd_declareDatatypesContext) IsCmd_declareDatatypesContext() {}

func NewCmd_declareDatatypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareDatatypesContext {
	var p = new(Cmd_declareDatatypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes

	return p
}

func (s *Cmd_declareDatatypesContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareDatatypesContext) CMD_DeclareDatatypes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareDatatypes, 0)
}

func (s *Cmd_declareDatatypesContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Cmd_declareDatatypesContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Cmd_declareDatatypesContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Cmd_declareDatatypesContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Cmd_declareDatatypesContext) AllSort_dec() []ISort_decContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_decContext); ok {
			len++
		}
	}

	tst := make([]ISort_decContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_decContext); ok {
			tst[i] = t.(ISort_decContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_declareDatatypesContext) Sort_dec(i int) ISort_decContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_decContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_decContext)
}

func (s *Cmd_declareDatatypesContext) AllDatatype_dec() []IDatatype_decContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDatatype_decContext); ok {
			len++
		}
	}

	tst := make([]IDatatype_decContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDatatype_decContext); ok {
			tst[i] = t.(IDatatype_decContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_declareDatatypesContext) Datatype_dec(i int) IDatatype_decContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatype_decContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatype_decContext)
}

func (s *Cmd_declareDatatypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareDatatypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareDatatypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareDatatypes(s)
	}
}

func (s *Cmd_declareDatatypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareDatatypes(s)
	}
}

func (s *Cmd_declareDatatypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareDatatypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareDatatypes() (localctx ICmd_declareDatatypesContext) {
	localctx = NewCmd_declareDatatypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SMTLIBv2ParserRULE_cmd_declareDatatypes)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(SMTLIBv2ParserCMD_DeclareDatatypes)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(675)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(676)
			p.Sort_dec()
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(681)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(682)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(683)
			p.Datatype_dec()
		}

		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(688)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_declareFunContext is an interface to support dynamic dispatch.
type ICmd_declareFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DeclareFun() antlr.TerminalNode
	Symbol() ISymbolContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllSort() []ISortContext
	Sort(i int) ISortContext

	// IsCmd_declareFunContext differentiates from other interfaces.
	IsCmd_declareFunContext()
}

type Cmd_declareFunContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareFunContext() *Cmd_declareFunContext {
	var p = new(Cmd_declareFunContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun
	return p
}

func InitEmptyCmd_declareFunContext(p *Cmd_declareFunContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun
}

func (*Cmd_declareFunContext) IsCmd_declareFunContext() {}

func NewCmd_declareFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareFunContext {
	var p = new(Cmd_declareFunContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun

	return p
}

func (s *Cmd_declareFunContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareFunContext) CMD_DeclareFun() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareFun, 0)
}

func (s *Cmd_declareFunContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareFunContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_declareFunContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_declareFunContext) AllSort() []ISortContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortContext); ok {
			len++
		}
	}

	tst := make([]ISortContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortContext); ok {
			tst[i] = t.(ISortContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_declareFunContext) Sort(i int) ISortContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_declareFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareFun(s)
	}
}

func (s *Cmd_declareFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareFun(s)
	}
}

func (s *Cmd_declareFunContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareFun(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareFun() (localctx ICmd_declareFunContext) {
	localctx = NewCmd_declareFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SMTLIBv2ParserRULE_cmd_declareFun)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(SMTLIBv2ParserCMD_DeclareFun)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(691)
		p.Symbol()
	}
	{
		p.SetState(692)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388548) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(693)
			p.Sort()
		}

		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(699)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(700)
		p.Sort()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_declareSortContext is an interface to support dynamic dispatch.
type ICmd_declareSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DeclareSort() antlr.TerminalNode
	Symbol() ISymbolContext
	Numeral() INumeralContext

	// IsCmd_declareSortContext differentiates from other interfaces.
	IsCmd_declareSortContext()
}

type Cmd_declareSortContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareSortContext() *Cmd_declareSortContext {
	var p = new(Cmd_declareSortContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort
	return p
}

func InitEmptyCmd_declareSortContext(p *Cmd_declareSortContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort
}

func (*Cmd_declareSortContext) IsCmd_declareSortContext() {}

func NewCmd_declareSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareSortContext {
	var p = new(Cmd_declareSortContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort

	return p
}

func (s *Cmd_declareSortContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareSortContext) CMD_DeclareSort() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareSort, 0)
}

func (s *Cmd_declareSortContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareSortContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_declareSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareSort(s)
	}
}

func (s *Cmd_declareSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareSort(s)
	}
}

func (s *Cmd_declareSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareSort() (localctx ICmd_declareSortContext) {
	localctx = NewCmd_declareSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SMTLIBv2ParserRULE_cmd_declareSort)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(SMTLIBv2ParserCMD_DeclareSort)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(703)
		p.Symbol()
	}
	{
		p.SetState(704)
		p.Numeral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_defineFunContext is an interface to support dynamic dispatch.
type ICmd_defineFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DefineFun() antlr.TerminalNode
	Function_def() IFunction_defContext

	// IsCmd_defineFunContext differentiates from other interfaces.
	IsCmd_defineFunContext()
}

type Cmd_defineFunContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunContext() *Cmd_defineFunContext {
	var p = new(Cmd_defineFunContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun
	return p
}

func InitEmptyCmd_defineFunContext(p *Cmd_defineFunContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun
}

func (*Cmd_defineFunContext) IsCmd_defineFunContext() {}

func NewCmd_defineFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunContext {
	var p = new(Cmd_defineFunContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun

	return p
}

func (s *Cmd_defineFunContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunContext) CMD_DefineFun() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFun, 0)
}

func (s *Cmd_defineFunContext) Function_def() IFunction_defContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_defContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_defContext)
}

func (s *Cmd_defineFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFun(s)
	}
}

func (s *Cmd_defineFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFun(s)
	}
}

func (s *Cmd_defineFunContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFun(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFun() (localctx ICmd_defineFunContext) {
	localctx = NewCmd_defineFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SMTLIBv2ParserRULE_cmd_defineFun)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(SMTLIBv2ParserCMD_DefineFun)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(707)
		p.Function_def()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_defineFunRecContext is an interface to support dynamic dispatch.
type ICmd_defineFunRecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DefineFunRec() antlr.TerminalNode
	Function_def() IFunction_defContext

	// IsCmd_defineFunRecContext differentiates from other interfaces.
	IsCmd_defineFunRecContext()
}

type Cmd_defineFunRecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunRecContext() *Cmd_defineFunRecContext {
	var p = new(Cmd_defineFunRecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec
	return p
}

func InitEmptyCmd_defineFunRecContext(p *Cmd_defineFunRecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec
}

func (*Cmd_defineFunRecContext) IsCmd_defineFunRecContext() {}

func NewCmd_defineFunRecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunRecContext {
	var p = new(Cmd_defineFunRecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec

	return p
}

func (s *Cmd_defineFunRecContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunRecContext) CMD_DefineFunRec() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFunRec, 0)
}

func (s *Cmd_defineFunRecContext) Function_def() IFunction_defContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_defContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_defContext)
}

func (s *Cmd_defineFunRecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunRecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunRecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFunRec(s)
	}
}

func (s *Cmd_defineFunRecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFunRec(s)
	}
}

func (s *Cmd_defineFunRecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFunRec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFunRec() (localctx ICmd_defineFunRecContext) {
	localctx = NewCmd_defineFunRecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SMTLIBv2ParserRULE_cmd_defineFunRec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(SMTLIBv2ParserCMD_DefineFunRec)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(710)
		p.Function_def()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_defineFunsRecContext is an interface to support dynamic dispatch.
type ICmd_defineFunsRecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DefineFunsRec() antlr.TerminalNode
	AllParOpen() []antlr.TerminalNode
	ParOpen(i int) antlr.TerminalNode
	AllParClose() []antlr.TerminalNode
	ParClose(i int) antlr.TerminalNode
	AllFunction_dec() []IFunction_decContext
	Function_dec(i int) IFunction_decContext
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsCmd_defineFunsRecContext differentiates from other interfaces.
	IsCmd_defineFunsRecContext()
}

type Cmd_defineFunsRecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunsRecContext() *Cmd_defineFunsRecContext {
	var p = new(Cmd_defineFunsRecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec
	return p
}

func InitEmptyCmd_defineFunsRecContext(p *Cmd_defineFunsRecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec
}

func (*Cmd_defineFunsRecContext) IsCmd_defineFunsRecContext() {}

func NewCmd_defineFunsRecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunsRecContext {
	var p = new(Cmd_defineFunsRecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec

	return p
}

func (s *Cmd_defineFunsRecContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunsRecContext) CMD_DefineFunsRec() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFunsRec, 0)
}

func (s *Cmd_defineFunsRecContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Cmd_defineFunsRecContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Cmd_defineFunsRecContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Cmd_defineFunsRecContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Cmd_defineFunsRecContext) AllFunction_dec() []IFunction_decContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunction_decContext); ok {
			len++
		}
	}

	tst := make([]IFunction_decContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunction_decContext); ok {
			tst[i] = t.(IFunction_decContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_defineFunsRecContext) Function_dec(i int) IFunction_decContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_decContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_decContext)
}

func (s *Cmd_defineFunsRecContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_defineFunsRecContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_defineFunsRecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunsRecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunsRecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFunsRec(s)
	}
}

func (s *Cmd_defineFunsRecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFunsRec(s)
	}
}

func (s *Cmd_defineFunsRecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFunsRec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFunsRec() (localctx ICmd_defineFunsRecContext) {
	localctx = NewCmd_defineFunsRecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SMTLIBv2ParserRULE_cmd_defineFunsRec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Match(SMTLIBv2ParserCMD_DefineFunsRec)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(713)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(714)
			p.Function_dec()
		}

		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(719)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(720)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388580) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&140737488355343) != 0) {
		{
			p.SetState(721)
			p.Term()
		}

		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(726)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_defineSortContext is an interface to support dynamic dispatch.
type ICmd_defineSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_DefineSort() antlr.TerminalNode
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	Sort() ISortContext

	// IsCmd_defineSortContext differentiates from other interfaces.
	IsCmd_defineSortContext()
}

type Cmd_defineSortContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineSortContext() *Cmd_defineSortContext {
	var p = new(Cmd_defineSortContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort
	return p
}

func InitEmptyCmd_defineSortContext(p *Cmd_defineSortContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort
}

func (*Cmd_defineSortContext) IsCmd_defineSortContext() {}

func NewCmd_defineSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineSortContext {
	var p = new(Cmd_defineSortContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort

	return p
}

func (s *Cmd_defineSortContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineSortContext) CMD_DefineSort() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineSort, 0)
}

func (s *Cmd_defineSortContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_defineSortContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_defineSortContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_defineSortContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_defineSortContext) Sort() ISortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_defineSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineSort(s)
	}
}

func (s *Cmd_defineSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineSort(s)
	}
}

func (s *Cmd_defineSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineSort() (localctx ICmd_defineSortContext) {
	localctx = NewCmd_defineSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SMTLIBv2ParserRULE_cmd_defineSort)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(SMTLIBv2ParserCMD_DefineSort)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(729)
		p.Symbol()
	}
	{
		p.SetState(730)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(731)
			p.Symbol()
		}

		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(737)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(738)
		p.Sort()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_echoContext is an interface to support dynamic dispatch.
type ICmd_echoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_Echo() antlr.TerminalNode
	String_() IString_Context

	// IsCmd_echoContext differentiates from other interfaces.
	IsCmd_echoContext()
}

type Cmd_echoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_echoContext() *Cmd_echoContext {
	var p = new(Cmd_echoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo
	return p
}

func InitEmptyCmd_echoContext(p *Cmd_echoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo
}

func (*Cmd_echoContext) IsCmd_echoContext() {}

func NewCmd_echoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_echoContext {
	var p = new(Cmd_echoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo

	return p
}

func (s *Cmd_echoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_echoContext) CMD_Echo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Echo, 0)
}

func (s *Cmd_echoContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Cmd_echoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_echoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_echoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_echo(s)
	}
}

func (s *Cmd_echoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_echo(s)
	}
}

func (s *Cmd_echoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_echo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_echo() (localctx ICmd_echoContext) {
	localctx = NewCmd_echoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SMTLIBv2ParserRULE_cmd_echo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(SMTLIBv2ParserCMD_Echo)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(741)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_exitContext is an interface to support dynamic dispatch.
type ICmd_exitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_Exit() antlr.TerminalNode

	// IsCmd_exitContext differentiates from other interfaces.
	IsCmd_exitContext()
}

type Cmd_exitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_exitContext() *Cmd_exitContext {
	var p = new(Cmd_exitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit
	return p
}

func InitEmptyCmd_exitContext(p *Cmd_exitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit
}

func (*Cmd_exitContext) IsCmd_exitContext() {}

func NewCmd_exitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_exitContext {
	var p = new(Cmd_exitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit

	return p
}

func (s *Cmd_exitContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_exitContext) CMD_Exit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Exit, 0)
}

func (s *Cmd_exitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_exitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_exitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_exit(s)
	}
}

func (s *Cmd_exitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_exit(s)
	}
}

func (s *Cmd_exitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_exit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_exit() (localctx ICmd_exitContext) {
	localctx = NewCmd_exitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SMTLIBv2ParserRULE_cmd_exit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(SMTLIBv2ParserCMD_Exit)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getAssertionsContext is an interface to support dynamic dispatch.
type ICmd_getAssertionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetAssertions() antlr.TerminalNode

	// IsCmd_getAssertionsContext differentiates from other interfaces.
	IsCmd_getAssertionsContext()
}

type Cmd_getAssertionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getAssertionsContext() *Cmd_getAssertionsContext {
	var p = new(Cmd_getAssertionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions
	return p
}

func InitEmptyCmd_getAssertionsContext(p *Cmd_getAssertionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions
}

func (*Cmd_getAssertionsContext) IsCmd_getAssertionsContext() {}

func NewCmd_getAssertionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getAssertionsContext {
	var p = new(Cmd_getAssertionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions

	return p
}

func (s *Cmd_getAssertionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getAssertionsContext) CMD_GetAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetAssertions, 0)
}

func (s *Cmd_getAssertionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getAssertionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getAssertionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getAssertions(s)
	}
}

func (s *Cmd_getAssertionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getAssertions(s)
	}
}

func (s *Cmd_getAssertionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getAssertions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getAssertions() (localctx ICmd_getAssertionsContext) {
	localctx = NewCmd_getAssertionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SMTLIBv2ParserRULE_cmd_getAssertions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(SMTLIBv2ParserCMD_GetAssertions)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getAssignmentContext is an interface to support dynamic dispatch.
type ICmd_getAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetAssignment() antlr.TerminalNode

	// IsCmd_getAssignmentContext differentiates from other interfaces.
	IsCmd_getAssignmentContext()
}

type Cmd_getAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getAssignmentContext() *Cmd_getAssignmentContext {
	var p = new(Cmd_getAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment
	return p
}

func InitEmptyCmd_getAssignmentContext(p *Cmd_getAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment
}

func (*Cmd_getAssignmentContext) IsCmd_getAssignmentContext() {}

func NewCmd_getAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getAssignmentContext {
	var p = new(Cmd_getAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment

	return p
}

func (s *Cmd_getAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getAssignmentContext) CMD_GetAssignment() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetAssignment, 0)
}

func (s *Cmd_getAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getAssignment(s)
	}
}

func (s *Cmd_getAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getAssignment(s)
	}
}

func (s *Cmd_getAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getAssignment() (localctx ICmd_getAssignmentContext) {
	localctx = NewCmd_getAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SMTLIBv2ParserRULE_cmd_getAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(SMTLIBv2ParserCMD_GetAssignment)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getInfoContext is an interface to support dynamic dispatch.
type ICmd_getInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetInfo() antlr.TerminalNode
	Info_flag() IInfo_flagContext

	// IsCmd_getInfoContext differentiates from other interfaces.
	IsCmd_getInfoContext()
}

type Cmd_getInfoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getInfoContext() *Cmd_getInfoContext {
	var p = new(Cmd_getInfoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo
	return p
}

func InitEmptyCmd_getInfoContext(p *Cmd_getInfoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo
}

func (*Cmd_getInfoContext) IsCmd_getInfoContext() {}

func NewCmd_getInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getInfoContext {
	var p = new(Cmd_getInfoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo

	return p
}

func (s *Cmd_getInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getInfoContext) CMD_GetInfo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetInfo, 0)
}

func (s *Cmd_getInfoContext) Info_flag() IInfo_flagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfo_flagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfo_flagContext)
}

func (s *Cmd_getInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getInfo(s)
	}
}

func (s *Cmd_getInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getInfo(s)
	}
}

func (s *Cmd_getInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getInfo() (localctx ICmd_getInfoContext) {
	localctx = NewCmd_getInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SMTLIBv2ParserRULE_cmd_getInfo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(SMTLIBv2ParserCMD_GetInfo)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(750)
		p.Info_flag()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getModelContext is an interface to support dynamic dispatch.
type ICmd_getModelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetModel() antlr.TerminalNode

	// IsCmd_getModelContext differentiates from other interfaces.
	IsCmd_getModelContext()
}

type Cmd_getModelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getModelContext() *Cmd_getModelContext {
	var p = new(Cmd_getModelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel
	return p
}

func InitEmptyCmd_getModelContext(p *Cmd_getModelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel
}

func (*Cmd_getModelContext) IsCmd_getModelContext() {}

func NewCmd_getModelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getModelContext {
	var p = new(Cmd_getModelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel

	return p
}

func (s *Cmd_getModelContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getModelContext) CMD_GetModel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetModel, 0)
}

func (s *Cmd_getModelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getModelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getModelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getModel(s)
	}
}

func (s *Cmd_getModelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getModel(s)
	}
}

func (s *Cmd_getModelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getModel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getModel() (localctx ICmd_getModelContext) {
	localctx = NewCmd_getModelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SMTLIBv2ParserRULE_cmd_getModel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Match(SMTLIBv2ParserCMD_GetModel)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getOptionContext is an interface to support dynamic dispatch.
type ICmd_getOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetOption() antlr.TerminalNode
	Keyword() IKeywordContext

	// IsCmd_getOptionContext differentiates from other interfaces.
	IsCmd_getOptionContext()
}

type Cmd_getOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getOptionContext() *Cmd_getOptionContext {
	var p = new(Cmd_getOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption
	return p
}

func InitEmptyCmd_getOptionContext(p *Cmd_getOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption
}

func (*Cmd_getOptionContext) IsCmd_getOptionContext() {}

func NewCmd_getOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getOptionContext {
	var p = new(Cmd_getOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption

	return p
}

func (s *Cmd_getOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getOptionContext) CMD_GetOption() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetOption, 0)
}

func (s *Cmd_getOptionContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *Cmd_getOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getOption(s)
	}
}

func (s *Cmd_getOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getOption(s)
	}
}

func (s *Cmd_getOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getOption() (localctx ICmd_getOptionContext) {
	localctx = NewCmd_getOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SMTLIBv2ParserRULE_cmd_getOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(SMTLIBv2ParserCMD_GetOption)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(755)
		p.Keyword()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getProofContext is an interface to support dynamic dispatch.
type ICmd_getProofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetProof() antlr.TerminalNode

	// IsCmd_getProofContext differentiates from other interfaces.
	IsCmd_getProofContext()
}

type Cmd_getProofContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getProofContext() *Cmd_getProofContext {
	var p = new(Cmd_getProofContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof
	return p
}

func InitEmptyCmd_getProofContext(p *Cmd_getProofContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof
}

func (*Cmd_getProofContext) IsCmd_getProofContext() {}

func NewCmd_getProofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getProofContext {
	var p = new(Cmd_getProofContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof

	return p
}

func (s *Cmd_getProofContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getProofContext) CMD_GetProof() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetProof, 0)
}

func (s *Cmd_getProofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getProofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getProofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getProof(s)
	}
}

func (s *Cmd_getProofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getProof(s)
	}
}

func (s *Cmd_getProofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getProof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getProof() (localctx ICmd_getProofContext) {
	localctx = NewCmd_getProofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SMTLIBv2ParserRULE_cmd_getProof)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(SMTLIBv2ParserCMD_GetProof)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getUnsatAssumptionsContext is an interface to support dynamic dispatch.
type ICmd_getUnsatAssumptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetUnsatAssumptions() antlr.TerminalNode

	// IsCmd_getUnsatAssumptionsContext differentiates from other interfaces.
	IsCmd_getUnsatAssumptionsContext()
}

type Cmd_getUnsatAssumptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getUnsatAssumptionsContext() *Cmd_getUnsatAssumptionsContext {
	var p = new(Cmd_getUnsatAssumptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions
	return p
}

func InitEmptyCmd_getUnsatAssumptionsContext(p *Cmd_getUnsatAssumptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions
}

func (*Cmd_getUnsatAssumptionsContext) IsCmd_getUnsatAssumptionsContext() {}

func NewCmd_getUnsatAssumptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getUnsatAssumptionsContext {
	var p = new(Cmd_getUnsatAssumptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions

	return p
}

func (s *Cmd_getUnsatAssumptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getUnsatAssumptionsContext) CMD_GetUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetUnsatAssumptions, 0)
}

func (s *Cmd_getUnsatAssumptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getUnsatAssumptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getUnsatAssumptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getUnsatAssumptions(s)
	}
}

func (s *Cmd_getUnsatAssumptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getUnsatAssumptions(s)
	}
}

func (s *Cmd_getUnsatAssumptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getUnsatAssumptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getUnsatAssumptions() (localctx ICmd_getUnsatAssumptionsContext) {
	localctx = NewCmd_getUnsatAssumptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SMTLIBv2ParserRULE_cmd_getUnsatAssumptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(SMTLIBv2ParserCMD_GetUnsatAssumptions)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getUnsatCoreContext is an interface to support dynamic dispatch.
type ICmd_getUnsatCoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetUnsatCore() antlr.TerminalNode

	// IsCmd_getUnsatCoreContext differentiates from other interfaces.
	IsCmd_getUnsatCoreContext()
}

type Cmd_getUnsatCoreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getUnsatCoreContext() *Cmd_getUnsatCoreContext {
	var p = new(Cmd_getUnsatCoreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore
	return p
}

func InitEmptyCmd_getUnsatCoreContext(p *Cmd_getUnsatCoreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore
}

func (*Cmd_getUnsatCoreContext) IsCmd_getUnsatCoreContext() {}

func NewCmd_getUnsatCoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getUnsatCoreContext {
	var p = new(Cmd_getUnsatCoreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore

	return p
}

func (s *Cmd_getUnsatCoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getUnsatCoreContext) CMD_GetUnsatCore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetUnsatCore, 0)
}

func (s *Cmd_getUnsatCoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getUnsatCoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getUnsatCoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getUnsatCore(s)
	}
}

func (s *Cmd_getUnsatCoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getUnsatCore(s)
	}
}

func (s *Cmd_getUnsatCoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getUnsatCore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getUnsatCore() (localctx ICmd_getUnsatCoreContext) {
	localctx = NewCmd_getUnsatCoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SMTLIBv2ParserRULE_cmd_getUnsatCore)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(SMTLIBv2ParserCMD_GetUnsatCore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_getValueContext is an interface to support dynamic dispatch.
type ICmd_getValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_GetValue() antlr.TerminalNode
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsCmd_getValueContext differentiates from other interfaces.
	IsCmd_getValueContext()
}

type Cmd_getValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getValueContext() *Cmd_getValueContext {
	var p = new(Cmd_getValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue
	return p
}

func InitEmptyCmd_getValueContext(p *Cmd_getValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue
}

func (*Cmd_getValueContext) IsCmd_getValueContext() {}

func NewCmd_getValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getValueContext {
	var p = new(Cmd_getValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue

	return p
}

func (s *Cmd_getValueContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getValueContext) CMD_GetValue() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetValue, 0)
}

func (s *Cmd_getValueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_getValueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_getValueContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *Cmd_getValueContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_getValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getValue(s)
	}
}

func (s *Cmd_getValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getValue(s)
	}
}

func (s *Cmd_getValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getValue() (localctx ICmd_getValueContext) {
	localctx = NewCmd_getValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SMTLIBv2ParserRULE_cmd_getValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Match(SMTLIBv2ParserCMD_GetValue)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(764)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388580) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&140737488355343) != 0) {
		{
			p.SetState(765)
			p.Term()
		}

		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(770)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_popContext is an interface to support dynamic dispatch.
type ICmd_popContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_Pop() antlr.TerminalNode
	Numeral() INumeralContext

	// IsCmd_popContext differentiates from other interfaces.
	IsCmd_popContext()
}

type Cmd_popContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_popContext() *Cmd_popContext {
	var p = new(Cmd_popContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop
	return p
}

func InitEmptyCmd_popContext(p *Cmd_popContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop
}

func (*Cmd_popContext) IsCmd_popContext() {}

func NewCmd_popContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_popContext {
	var p = new(Cmd_popContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop

	return p
}

func (s *Cmd_popContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_popContext) CMD_Pop() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Pop, 0)
}

func (s *Cmd_popContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_popContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_popContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_popContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_pop(s)
	}
}

func (s *Cmd_popContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_pop(s)
	}
}

func (s *Cmd_popContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_pop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_pop() (localctx ICmd_popContext) {
	localctx = NewCmd_popContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SMTLIBv2ParserRULE_cmd_pop)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(SMTLIBv2ParserCMD_Pop)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Numeral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_pushContext is an interface to support dynamic dispatch.
type ICmd_pushContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_Push() antlr.TerminalNode
	Numeral() INumeralContext

	// IsCmd_pushContext differentiates from other interfaces.
	IsCmd_pushContext()
}

type Cmd_pushContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_pushContext() *Cmd_pushContext {
	var p = new(Cmd_pushContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push
	return p
}

func InitEmptyCmd_pushContext(p *Cmd_pushContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push
}

func (*Cmd_pushContext) IsCmd_pushContext() {}

func NewCmd_pushContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_pushContext {
	var p = new(Cmd_pushContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push

	return p
}

func (s *Cmd_pushContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_pushContext) CMD_Push() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Push, 0)
}

func (s *Cmd_pushContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_pushContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_pushContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_pushContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_push(s)
	}
}

func (s *Cmd_pushContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_push(s)
	}
}

func (s *Cmd_pushContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_push(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_push() (localctx ICmd_pushContext) {
	localctx = NewCmd_pushContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SMTLIBv2ParserRULE_cmd_push)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(SMTLIBv2ParserCMD_Push)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(776)
		p.Numeral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_resetContext is an interface to support dynamic dispatch.
type ICmd_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_Reset() antlr.TerminalNode

	// IsCmd_resetContext differentiates from other interfaces.
	IsCmd_resetContext()
}

type Cmd_resetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_resetContext() *Cmd_resetContext {
	var p = new(Cmd_resetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset
	return p
}

func InitEmptyCmd_resetContext(p *Cmd_resetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset
}

func (*Cmd_resetContext) IsCmd_resetContext() {}

func NewCmd_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_resetContext {
	var p = new(Cmd_resetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset

	return p
}

func (s *Cmd_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_resetContext) CMD_Reset() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Reset, 0)
}

func (s *Cmd_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_reset(s)
	}
}

func (s *Cmd_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_reset(s)
	}
}

func (s *Cmd_resetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_reset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_reset() (localctx ICmd_resetContext) {
	localctx = NewCmd_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SMTLIBv2ParserRULE_cmd_reset)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Match(SMTLIBv2ParserCMD_Reset)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_resetAssertionsContext is an interface to support dynamic dispatch.
type ICmd_resetAssertionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_ResetAssertions() antlr.TerminalNode

	// IsCmd_resetAssertionsContext differentiates from other interfaces.
	IsCmd_resetAssertionsContext()
}

type Cmd_resetAssertionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_resetAssertionsContext() *Cmd_resetAssertionsContext {
	var p = new(Cmd_resetAssertionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions
	return p
}

func InitEmptyCmd_resetAssertionsContext(p *Cmd_resetAssertionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions
}

func (*Cmd_resetAssertionsContext) IsCmd_resetAssertionsContext() {}

func NewCmd_resetAssertionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_resetAssertionsContext {
	var p = new(Cmd_resetAssertionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions

	return p
}

func (s *Cmd_resetAssertionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_resetAssertionsContext) CMD_ResetAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_ResetAssertions, 0)
}

func (s *Cmd_resetAssertionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_resetAssertionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_resetAssertionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_resetAssertions(s)
	}
}

func (s *Cmd_resetAssertionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_resetAssertions(s)
	}
}

func (s *Cmd_resetAssertionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_resetAssertions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_resetAssertions() (localctx ICmd_resetAssertionsContext) {
	localctx = NewCmd_resetAssertionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SMTLIBv2ParserRULE_cmd_resetAssertions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(SMTLIBv2ParserCMD_ResetAssertions)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_setInfoContext is an interface to support dynamic dispatch.
type ICmd_setInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_SetInfo() antlr.TerminalNode
	Attribute() IAttributeContext

	// IsCmd_setInfoContext differentiates from other interfaces.
	IsCmd_setInfoContext()
}

type Cmd_setInfoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setInfoContext() *Cmd_setInfoContext {
	var p = new(Cmd_setInfoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo
	return p
}

func InitEmptyCmd_setInfoContext(p *Cmd_setInfoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo
}

func (*Cmd_setInfoContext) IsCmd_setInfoContext() {}

func NewCmd_setInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setInfoContext {
	var p = new(Cmd_setInfoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo

	return p
}

func (s *Cmd_setInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setInfoContext) CMD_SetInfo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetInfo, 0)
}

func (s *Cmd_setInfoContext) Attribute() IAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Cmd_setInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setInfo(s)
	}
}

func (s *Cmd_setInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setInfo(s)
	}
}

func (s *Cmd_setInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setInfo() (localctx ICmd_setInfoContext) {
	localctx = NewCmd_setInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SMTLIBv2ParserRULE_cmd_setInfo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(SMTLIBv2ParserCMD_SetInfo)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(783)
		p.Attribute()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_setLogicContext is an interface to support dynamic dispatch.
type ICmd_setLogicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_SetLogic() antlr.TerminalNode
	Symbol() ISymbolContext

	// IsCmd_setLogicContext differentiates from other interfaces.
	IsCmd_setLogicContext()
}

type Cmd_setLogicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setLogicContext() *Cmd_setLogicContext {
	var p = new(Cmd_setLogicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic
	return p
}

func InitEmptyCmd_setLogicContext(p *Cmd_setLogicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic
}

func (*Cmd_setLogicContext) IsCmd_setLogicContext() {}

func NewCmd_setLogicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setLogicContext {
	var p = new(Cmd_setLogicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic

	return p
}

func (s *Cmd_setLogicContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setLogicContext) CMD_SetLogic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetLogic, 0)
}

func (s *Cmd_setLogicContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_setLogicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setLogicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setLogicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setLogic(s)
	}
}

func (s *Cmd_setLogicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setLogic(s)
	}
}

func (s *Cmd_setLogicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setLogic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setLogic() (localctx ICmd_setLogicContext) {
	localctx = NewCmd_setLogicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SMTLIBv2ParserRULE_cmd_setLogic)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		p.Match(SMTLIBv2ParserCMD_SetLogic)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(786)
		p.Symbol()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmd_setOptionContext is an interface to support dynamic dispatch.
type ICmd_setOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CMD_SetOption() antlr.TerminalNode
	Option() IOptionContext

	// IsCmd_setOptionContext differentiates from other interfaces.
	IsCmd_setOptionContext()
}

type Cmd_setOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setOptionContext() *Cmd_setOptionContext {
	var p = new(Cmd_setOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption
	return p
}

func InitEmptyCmd_setOptionContext(p *Cmd_setOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption
}

func (*Cmd_setOptionContext) IsCmd_setOptionContext() {}

func NewCmd_setOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setOptionContext {
	var p = new(Cmd_setOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption

	return p
}

func (s *Cmd_setOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setOptionContext) CMD_SetOption() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetOption, 0)
}

func (s *Cmd_setOptionContext) Option() IOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionContext)
}

func (s *Cmd_setOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setOption(s)
	}
}

func (s *Cmd_setOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setOption(s)
	}
}

func (s *Cmd_setOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setOption() (localctx ICmd_setOptionContext) {
	localctx = NewCmd_setOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SMTLIBv2ParserRULE_cmd_setOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)
		p.Match(SMTLIBv2ParserCMD_SetOption)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(789)
		p.Option()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandContext is an interface to support dynamic dispatch.
type ICommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Cmd_assert() ICmd_assertContext
	ParClose() antlr.TerminalNode
	Cmd_checkSat() ICmd_checkSatContext
	Cmd_checkSatAssuming() ICmd_checkSatAssumingContext
	Cmd_declareConst() ICmd_declareConstContext
	Cmd_declareDatatype() ICmd_declareDatatypeContext
	Cmd_declareDatatypes() ICmd_declareDatatypesContext
	Cmd_declareFun() ICmd_declareFunContext
	Cmd_declareSort() ICmd_declareSortContext
	Cmd_defineFun() ICmd_defineFunContext
	Cmd_defineFunRec() ICmd_defineFunRecContext
	Cmd_defineFunsRec() ICmd_defineFunsRecContext
	Cmd_defineSort() ICmd_defineSortContext
	Cmd_echo() ICmd_echoContext
	Cmd_exit() ICmd_exitContext
	Cmd_getAssertions() ICmd_getAssertionsContext
	Cmd_getAssignment() ICmd_getAssignmentContext
	Cmd_getInfo() ICmd_getInfoContext
	Cmd_getModel() ICmd_getModelContext
	Cmd_getOption() ICmd_getOptionContext
	Cmd_getProof() ICmd_getProofContext
	Cmd_getUnsatAssumptions() ICmd_getUnsatAssumptionsContext
	Cmd_getUnsatCore() ICmd_getUnsatCoreContext
	Cmd_getValue() ICmd_getValueContext
	Cmd_pop() ICmd_popContext
	Cmd_push() ICmd_pushContext
	Cmd_reset() ICmd_resetContext
	Cmd_resetAssertions() ICmd_resetAssertionsContext
	Cmd_setInfo() ICmd_setInfoContext
	Cmd_setLogic() ICmd_setLogicContext
	Cmd_setOption() ICmd_setOptionContext

	// IsCommandContext differentiates from other interfaces.
	IsCommandContext()
}

type CommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandContext() *CommandContext {
	var p = new(CommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_command
	return p
}

func InitEmptyCommandContext(p *CommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_command
}

func (*CommandContext) IsCommandContext() {}

func NewCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandContext {
	var p = new(CommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_command

	return p
}

func (s *CommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *CommandContext) Cmd_assert() ICmd_assertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_assertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_assertContext)
}

func (s *CommandContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *CommandContext) Cmd_checkSat() ICmd_checkSatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_checkSatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_checkSatContext)
}

func (s *CommandContext) Cmd_checkSatAssuming() ICmd_checkSatAssumingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_checkSatAssumingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_checkSatAssumingContext)
}

func (s *CommandContext) Cmd_declareConst() ICmd_declareConstContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_declareConstContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_declareConstContext)
}

func (s *CommandContext) Cmd_declareDatatype() ICmd_declareDatatypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_declareDatatypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_declareDatatypeContext)
}

func (s *CommandContext) Cmd_declareDatatypes() ICmd_declareDatatypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_declareDatatypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_declareDatatypesContext)
}

func (s *CommandContext) Cmd_declareFun() ICmd_declareFunContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_declareFunContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_declareFunContext)
}

func (s *CommandContext) Cmd_declareSort() ICmd_declareSortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_declareSortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_declareSortContext)
}

func (s *CommandContext) Cmd_defineFun() ICmd_defineFunContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineFunContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunContext)
}

func (s *CommandContext) Cmd_defineFunRec() ICmd_defineFunRecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineFunRecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunRecContext)
}

func (s *CommandContext) Cmd_defineFunsRec() ICmd_defineFunsRecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineFunsRecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunsRecContext)
}

func (s *CommandContext) Cmd_defineSort() ICmd_defineSortContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineSortContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineSortContext)
}

func (s *CommandContext) Cmd_echo() ICmd_echoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_echoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_echoContext)
}

func (s *CommandContext) Cmd_exit() ICmd_exitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_exitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_exitContext)
}

func (s *CommandContext) Cmd_getAssertions() ICmd_getAssertionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getAssertionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getAssertionsContext)
}

func (s *CommandContext) Cmd_getAssignment() ICmd_getAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getAssignmentContext)
}

func (s *CommandContext) Cmd_getInfo() ICmd_getInfoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getInfoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getInfoContext)
}

func (s *CommandContext) Cmd_getModel() ICmd_getModelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getModelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getModelContext)
}

func (s *CommandContext) Cmd_getOption() ICmd_getOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getOptionContext)
}

func (s *CommandContext) Cmd_getProof() ICmd_getProofContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getProofContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getProofContext)
}

func (s *CommandContext) Cmd_getUnsatAssumptions() ICmd_getUnsatAssumptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getUnsatAssumptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getUnsatAssumptionsContext)
}

func (s *CommandContext) Cmd_getUnsatCore() ICmd_getUnsatCoreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getUnsatCoreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getUnsatCoreContext)
}

func (s *CommandContext) Cmd_getValue() ICmd_getValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_getValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_getValueContext)
}

func (s *CommandContext) Cmd_pop() ICmd_popContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_popContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_popContext)
}

func (s *CommandContext) Cmd_push() ICmd_pushContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_pushContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_pushContext)
}

func (s *CommandContext) Cmd_reset() ICmd_resetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_resetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_resetContext)
}

func (s *CommandContext) Cmd_resetAssertions() ICmd_resetAssertionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_resetAssertionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_resetAssertionsContext)
}

func (s *CommandContext) Cmd_setInfo() ICmd_setInfoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_setInfoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_setInfoContext)
}

func (s *CommandContext) Cmd_setLogic() ICmd_setLogicContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_setLogicContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_setLogicContext)
}

func (s *CommandContext) Cmd_setOption() ICmd_setOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_setOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_setOptionContext)
}

func (s *CommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCommand(s)
	}
}

func (s *CommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCommand(s)
	}
}

func (s *CommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Command() (localctx ICommandContext) {
	localctx = NewCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SMTLIBv2ParserRULE_command)
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(791)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(792)
			p.Cmd_assert()
		}
		{
			p.SetState(793)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(795)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(796)
			p.Cmd_checkSat()
		}
		{
			p.SetState(797)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(799)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(800)
			p.Cmd_checkSatAssuming()
		}
		{
			p.SetState(801)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(803)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(804)
			p.Cmd_declareConst()
		}
		{
			p.SetState(805)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(807)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(808)
			p.Cmd_declareDatatype()
		}
		{
			p.SetState(809)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(811)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(812)
			p.Cmd_declareDatatypes()
		}
		{
			p.SetState(813)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(815)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(816)
			p.Cmd_declareFun()
		}
		{
			p.SetState(817)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(819)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(820)
			p.Cmd_declareSort()
		}
		{
			p.SetState(821)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(823)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(824)
			p.Cmd_defineFun()
		}
		{
			p.SetState(825)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(827)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(828)
			p.Cmd_defineFunRec()
		}
		{
			p.SetState(829)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(831)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(832)
			p.Cmd_defineFunsRec()
		}
		{
			p.SetState(833)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(835)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(836)
			p.Cmd_defineSort()
		}
		{
			p.SetState(837)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(839)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(840)
			p.Cmd_echo()
		}
		{
			p.SetState(841)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(843)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(844)
			p.Cmd_exit()
		}
		{
			p.SetState(845)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(847)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(848)
			p.Cmd_getAssertions()
		}
		{
			p.SetState(849)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(851)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(852)
			p.Cmd_getAssignment()
		}
		{
			p.SetState(853)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(855)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(856)
			p.Cmd_getInfo()
		}
		{
			p.SetState(857)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(859)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(860)
			p.Cmd_getModel()
		}
		{
			p.SetState(861)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(863)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(864)
			p.Cmd_getOption()
		}
		{
			p.SetState(865)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(867)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(868)
			p.Cmd_getProof()
		}
		{
			p.SetState(869)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(871)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)
			p.Cmd_getUnsatAssumptions()
		}
		{
			p.SetState(873)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(875)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.Cmd_getUnsatCore()
		}
		{
			p.SetState(877)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(879)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(880)
			p.Cmd_getValue()
		}
		{
			p.SetState(881)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(883)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(884)
			p.Cmd_pop()
		}
		{
			p.SetState(885)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(887)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(888)
			p.Cmd_push()
		}
		{
			p.SetState(889)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(891)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(892)
			p.Cmd_reset()
		}
		{
			p.SetState(893)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(895)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(896)
			p.Cmd_resetAssertions()
		}
		{
			p.SetState(897)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(899)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(900)
			p.Cmd_setInfo()
		}
		{
			p.SetState(901)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(903)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(904)
			p.Cmd_setLogic()
		}
		{
			p.SetState(905)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(907)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(908)
			p.Cmd_setOption()
		}
		{
			p.SetState(909)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IB_valueContext is an interface to support dynamic dispatch.
type IB_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PS_True() antlr.TerminalNode
	PS_False() antlr.TerminalNode

	// IsB_valueContext differentiates from other interfaces.
	IsB_valueContext()
}

type B_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyB_valueContext() *B_valueContext {
	var p = new(B_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_b_value
	return p
}

func InitEmptyB_valueContext(p *B_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_b_value
}

func (*B_valueContext) IsB_valueContext() {}

func NewB_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *B_valueContext {
	var p = new(B_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_b_value

	return p
}

func (s *B_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *B_valueContext) PS_True() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_True, 0)
}

func (s *B_valueContext) PS_False() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_False, 0)
}

func (s *B_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *B_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *B_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterB_value(s)
	}
}

func (s *B_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitB_value(s)
	}
}

func (s *B_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitB_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) B_value() (localctx IB_valueContext) {
	localctx = NewB_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SMTLIBv2ParserRULE_b_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SMTLIBv2ParserPS_False || _la == SMTLIBv2ParserPS_True) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionContext is an interface to support dynamic dispatch.
type IOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PK_DiagnosticOutputChannel() antlr.TerminalNode
	String_() IString_Context
	PK_GlobalDeclarations() antlr.TerminalNode
	B_value() IB_valueContext
	PK_InteractiveMode() antlr.TerminalNode
	PK_PrintSuccess() antlr.TerminalNode
	PK_ProduceAssertions() antlr.TerminalNode
	PK_ProduceAssignments() antlr.TerminalNode
	PK_ProduceModels() antlr.TerminalNode
	PK_ProduceProofs() antlr.TerminalNode
	PK_ProduceUnsatAssumptions() antlr.TerminalNode
	PK_ProduceUnsatCores() antlr.TerminalNode
	PK_RandomSeed() antlr.TerminalNode
	Numeral() INumeralContext
	PK_RegularOutputChannel() antlr.TerminalNode
	PK_ReproducibleResourceLimit() antlr.TerminalNode
	PK_Verbosity() antlr.TerminalNode
	Attribute() IAttributeContext

	// IsOptionContext differentiates from other interfaces.
	IsOptionContext()
}

type OptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionContext() *OptionContext {
	var p = new(OptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_option
	return p
}

func InitEmptyOptionContext(p *OptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_option
}

func (*OptionContext) IsOptionContext() {}

func NewOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionContext {
	var p = new(OptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_option

	return p
}

func (s *OptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionContext) PK_DiagnosticOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_DiagnosticOutputChannel, 0)
}

func (s *OptionContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *OptionContext) PK_GlobalDeclarations() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_GlobalDeclarations, 0)
}

func (s *OptionContext) B_value() IB_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IB_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IB_valueContext)
}

func (s *OptionContext) PK_InteractiveMode() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_InteractiveMode, 0)
}

func (s *OptionContext) PK_PrintSuccess() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_PrintSuccess, 0)
}

func (s *OptionContext) PK_ProduceAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssertions, 0)
}

func (s *OptionContext) PK_ProduceAssignments() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssignments, 0)
}

func (s *OptionContext) PK_ProduceModels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceModels, 0)
}

func (s *OptionContext) PK_ProduceProofs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceProofs, 0)
}

func (s *OptionContext) PK_ProduceUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatAssumptions, 0)
}

func (s *OptionContext) PK_ProduceUnsatCores() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatCores, 0)
}

func (s *OptionContext) PK_RandomSeed() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RandomSeed, 0)
}

func (s *OptionContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *OptionContext) PK_RegularOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RegularOutputChannel, 0)
}

func (s *OptionContext) PK_ReproducibleResourceLimit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReproducibleResourceLimit, 0)
}

func (s *OptionContext) PK_Verbosity() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Verbosity, 0)
}

func (s *OptionContext) Attribute() IAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *OptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterOption(s)
	}
}

func (s *OptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitOption(s)
	}
}

func (s *OptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Option() (localctx IOptionContext) {
	localctx = NewOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SMTLIBv2ParserRULE_option)
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.Match(SMTLIBv2ParserPK_DiagnosticOutputChannel)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(916)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.Match(SMTLIBv2ParserPK_GlobalDeclarations)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(918)
			p.B_value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(919)
			p.Match(SMTLIBv2ParserPK_InteractiveMode)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(920)
			p.B_value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(921)
			p.Match(SMTLIBv2ParserPK_PrintSuccess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(922)
			p.B_value()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(923)
			p.Match(SMTLIBv2ParserPK_ProduceAssertions)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(924)
			p.B_value()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(925)
			p.Match(SMTLIBv2ParserPK_ProduceAssignments)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(926)
			p.B_value()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(927)
			p.Match(SMTLIBv2ParserPK_ProduceModels)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(928)
			p.B_value()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(929)
			p.Match(SMTLIBv2ParserPK_ProduceProofs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.B_value()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(931)
			p.Match(SMTLIBv2ParserPK_ProduceUnsatAssumptions)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(932)
			p.B_value()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(933)
			p.Match(SMTLIBv2ParserPK_ProduceUnsatCores)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.B_value()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(935)
			p.Match(SMTLIBv2ParserPK_RandomSeed)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)
			p.Numeral()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(937)
			p.Match(SMTLIBv2ParserPK_RegularOutputChannel)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(938)
			p.String_()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(939)
			p.Match(SMTLIBv2ParserPK_ReproducibleResourceLimit)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(940)
			p.Numeral()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(941)
			p.Match(SMTLIBv2ParserPK_Verbosity)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(942)
			p.Numeral()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(943)
			p.Attribute()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInfo_flagContext is an interface to support dynamic dispatch.
type IInfo_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PK_AllStatistics() antlr.TerminalNode
	PK_AssertionStackLevels() antlr.TerminalNode
	PK_Authors() antlr.TerminalNode
	PK_ErrorBehaviour() antlr.TerminalNode
	PK_Name() antlr.TerminalNode
	PK_ReasonUnknown() antlr.TerminalNode
	PK_Version() antlr.TerminalNode
	Keyword() IKeywordContext

	// IsInfo_flagContext differentiates from other interfaces.
	IsInfo_flagContext()
}

type Info_flagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_flagContext() *Info_flagContext {
	var p = new(Info_flagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag
	return p
}

func InitEmptyInfo_flagContext(p *Info_flagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag
}

func (*Info_flagContext) IsInfo_flagContext() {}

func NewInfo_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_flagContext {
	var p = new(Info_flagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag

	return p
}

func (s *Info_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_flagContext) PK_AllStatistics() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AllStatistics, 0)
}

func (s *Info_flagContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *Info_flagContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *Info_flagContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *Info_flagContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *Info_flagContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *Info_flagContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *Info_flagContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *Info_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterInfo_flag(s)
	}
}

func (s *Info_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitInfo_flag(s)
	}
}

func (s *Info_flagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitInfo_flag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Info_flag() (localctx IInfo_flagContext) {
	localctx = NewInfo_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SMTLIBv2ParserRULE_info_flag)
	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(946)
			p.Match(SMTLIBv2ParserPK_AllStatistics)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(947)
			p.Match(SMTLIBv2ParserPK_AssertionStackLevels)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(948)
			p.Match(SMTLIBv2ParserPK_Authors)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(949)
			p.Match(SMTLIBv2ParserPK_ErrorBehaviour)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(950)
			p.Match(SMTLIBv2ParserPK_Name)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(951)
			p.Match(SMTLIBv2ParserPK_ReasonUnknown)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(952)
			p.Match(SMTLIBv2ParserPK_Version)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(953)
			p.Keyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IError_behaviourContext is an interface to support dynamic dispatch.
type IError_behaviourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PS_ImmediateExit() antlr.TerminalNode
	PS_ContinuedExecution() antlr.TerminalNode

	// IsError_behaviourContext differentiates from other interfaces.
	IsError_behaviourContext()
}

type Error_behaviourContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_behaviourContext() *Error_behaviourContext {
	var p = new(Error_behaviourContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour
	return p
}

func InitEmptyError_behaviourContext(p *Error_behaviourContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour
}

func (*Error_behaviourContext) IsError_behaviourContext() {}

func NewError_behaviourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_behaviourContext {
	var p = new(Error_behaviourContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour

	return p
}

func (s *Error_behaviourContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_behaviourContext) PS_ImmediateExit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ImmediateExit, 0)
}

func (s *Error_behaviourContext) PS_ContinuedExecution() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ContinuedExecution, 0)
}

func (s *Error_behaviourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_behaviourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_behaviourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterError_behaviour(s)
	}
}

func (s *Error_behaviourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitError_behaviour(s)
	}
}

func (s *Error_behaviourContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitError_behaviour(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Error_behaviour() (localctx IError_behaviourContext) {
	localctx = NewError_behaviourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SMTLIBv2ParserRULE_error_behaviour)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SMTLIBv2ParserPS_ContinuedExecution || _la == SMTLIBv2ParserPS_ImmediateExit) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReason_unknownContext is an interface to support dynamic dispatch.
type IReason_unknownContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PS_Memout() antlr.TerminalNode
	PS_Incomplete() antlr.TerminalNode
	S_expr() IS_exprContext

	// IsReason_unknownContext differentiates from other interfaces.
	IsReason_unknownContext()
}

type Reason_unknownContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReason_unknownContext() *Reason_unknownContext {
	var p = new(Reason_unknownContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown
	return p
}

func InitEmptyReason_unknownContext(p *Reason_unknownContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown
}

func (*Reason_unknownContext) IsReason_unknownContext() {}

func NewReason_unknownContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reason_unknownContext {
	var p = new(Reason_unknownContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown

	return p
}

func (s *Reason_unknownContext) GetParser() antlr.Parser { return s.parser }

func (s *Reason_unknownContext) PS_Memout() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Memout, 0)
}

func (s *Reason_unknownContext) PS_Incomplete() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Incomplete, 0)
}

func (s *Reason_unknownContext) S_expr() IS_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IS_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Reason_unknownContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reason_unknownContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reason_unknownContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterReason_unknown(s)
	}
}

func (s *Reason_unknownContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitReason_unknown(s)
	}
}

func (s *Reason_unknownContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitReason_unknown(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Reason_unknown() (localctx IReason_unknownContext) {
	localctx = NewReason_unknownContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SMTLIBv2ParserRULE_reason_unknown)
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(958)
			p.Match(SMTLIBv2ParserPS_Memout)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(959)
			p.Match(SMTLIBv2ParserPS_Incomplete)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(960)
			p.S_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModel_responseContext is an interface to support dynamic dispatch.
type IModel_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Cmd_defineFun() ICmd_defineFunContext
	ParClose() antlr.TerminalNode
	Cmd_defineFunRec() ICmd_defineFunRecContext
	Cmd_defineFunsRec() ICmd_defineFunsRecContext

	// IsModel_responseContext differentiates from other interfaces.
	IsModel_responseContext()
}

type Model_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_responseContext() *Model_responseContext {
	var p = new(Model_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_model_response
	return p
}

func InitEmptyModel_responseContext(p *Model_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_model_response
}

func (*Model_responseContext) IsModel_responseContext() {}

func NewModel_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_responseContext {
	var p = new(Model_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_model_response

	return p
}

func (s *Model_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Model_responseContext) Cmd_defineFun() ICmd_defineFunContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineFunContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunContext)
}

func (s *Model_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Model_responseContext) Cmd_defineFunRec() ICmd_defineFunRecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineFunRecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunRecContext)
}

func (s *Model_responseContext) Cmd_defineFunsRec() ICmd_defineFunsRecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmd_defineFunsRecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunsRecContext)
}

func (s *Model_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterModel_response(s)
	}
}

func (s *Model_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitModel_response(s)
	}
}

func (s *Model_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitModel_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Model_response() (localctx IModel_responseContext) {
	localctx = NewModel_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SMTLIBv2ParserRULE_model_response)
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(963)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(964)
			p.Cmd_defineFun()
		}
		{
			p.SetState(965)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(967)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)
			p.Cmd_defineFunRec()
		}
		{
			p.SetState(969)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(971)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(972)
			p.Cmd_defineFunsRec()
		}
		{
			p.SetState(973)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInfo_responseContext is an interface to support dynamic dispatch.
type IInfo_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PK_AssertionStackLevels() antlr.TerminalNode
	Numeral() INumeralContext
	PK_Authors() antlr.TerminalNode
	String_() IString_Context
	PK_ErrorBehaviour() antlr.TerminalNode
	Error_behaviour() IError_behaviourContext
	PK_Name() antlr.TerminalNode
	PK_ReasonUnknown() antlr.TerminalNode
	Reason_unknown() IReason_unknownContext
	PK_Version() antlr.TerminalNode
	Attribute() IAttributeContext

	// IsInfo_responseContext differentiates from other interfaces.
	IsInfo_responseContext()
}

type Info_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_responseContext() *Info_responseContext {
	var p = new(Info_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_response
	return p
}

func InitEmptyInfo_responseContext(p *Info_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_response
}

func (*Info_responseContext) IsInfo_responseContext() {}

func NewInfo_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_responseContext {
	var p = new(Info_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_info_response

	return p
}

func (s *Info_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_responseContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *Info_responseContext) Numeral() INumeralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumeralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Info_responseContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *Info_responseContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Info_responseContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *Info_responseContext) Error_behaviour() IError_behaviourContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IError_behaviourContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IError_behaviourContext)
}

func (s *Info_responseContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *Info_responseContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *Info_responseContext) Reason_unknown() IReason_unknownContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReason_unknownContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReason_unknownContext)
}

func (s *Info_responseContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *Info_responseContext) Attribute() IAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Info_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterInfo_response(s)
	}
}

func (s *Info_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitInfo_response(s)
	}
}

func (s *Info_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitInfo_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Info_response() (localctx IInfo_responseContext) {
	localctx = NewInfo_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SMTLIBv2ParserRULE_info_response)
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Match(SMTLIBv2ParserPK_AssertionStackLevels)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(978)
			p.Numeral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(979)
			p.Match(SMTLIBv2ParserPK_Authors)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(980)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(981)
			p.Match(SMTLIBv2ParserPK_ErrorBehaviour)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(982)
			p.Error_behaviour()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(983)
			p.Match(SMTLIBv2ParserPK_Name)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(984)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(985)
			p.Match(SMTLIBv2ParserPK_ReasonUnknown)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(986)
			p.Reason_unknown()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(987)
			p.Match(SMTLIBv2ParserPK_Version)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.String_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(989)
			p.Attribute()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuation_pairContext is an interface to support dynamic dispatch.
type IValuation_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	AllTerm() []ITermContext
	Term(i int) ITermContext
	ParClose() antlr.TerminalNode

	// IsValuation_pairContext differentiates from other interfaces.
	IsValuation_pairContext()
}

type Valuation_pairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuation_pairContext() *Valuation_pairContext {
	var p = new(Valuation_pairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair
	return p
}

func InitEmptyValuation_pairContext(p *Valuation_pairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair
}

func (*Valuation_pairContext) IsValuation_pairContext() {}

func NewValuation_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Valuation_pairContext {
	var p = new(Valuation_pairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair

	return p
}

func (s *Valuation_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Valuation_pairContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Valuation_pairContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *Valuation_pairContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Valuation_pairContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Valuation_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Valuation_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Valuation_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterValuation_pair(s)
	}
}

func (s *Valuation_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitValuation_pair(s)
	}
}

func (s *Valuation_pairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitValuation_pair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Valuation_pair() (localctx IValuation_pairContext) {
	localctx = NewValuation_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SMTLIBv2ParserRULE_valuation_pair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(993)
		p.Term()
	}
	{
		p.SetState(994)
		p.Term()
	}
	{
		p.SetState(995)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IT_valuation_pairContext is an interface to support dynamic dispatch.
type IT_valuation_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	Symbol() ISymbolContext
	B_value() IB_valueContext
	ParClose() antlr.TerminalNode

	// IsT_valuation_pairContext differentiates from other interfaces.
	IsT_valuation_pairContext()
}

type T_valuation_pairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_valuation_pairContext() *T_valuation_pairContext {
	var p = new(T_valuation_pairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair
	return p
}

func InitEmptyT_valuation_pairContext(p *T_valuation_pairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair
}

func (*T_valuation_pairContext) IsT_valuation_pairContext() {}

func NewT_valuation_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_valuation_pairContext {
	var p = new(T_valuation_pairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair

	return p
}

func (s *T_valuation_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *T_valuation_pairContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *T_valuation_pairContext) Symbol() ISymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *T_valuation_pairContext) B_value() IB_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IB_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IB_valueContext)
}

func (s *T_valuation_pairContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *T_valuation_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_valuation_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_valuation_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterT_valuation_pair(s)
	}
}

func (s *T_valuation_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitT_valuation_pair(s)
	}
}

func (s *T_valuation_pairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitT_valuation_pair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) T_valuation_pair() (localctx IT_valuation_pairContext) {
	localctx = NewT_valuation_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SMTLIBv2ParserRULE_t_valuation_pair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(998)
		p.Symbol()
	}
	{
		p.SetState(999)
		p.B_value()
	}
	{
		p.SetState(1000)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheck_sat_responseContext is an interface to support dynamic dispatch.
type ICheck_sat_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PS_Sat() antlr.TerminalNode
	PS_Unsat() antlr.TerminalNode
	PS_Unknown() antlr.TerminalNode

	// IsCheck_sat_responseContext differentiates from other interfaces.
	IsCheck_sat_responseContext()
}

type Check_sat_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheck_sat_responseContext() *Check_sat_responseContext {
	var p = new(Check_sat_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response
	return p
}

func InitEmptyCheck_sat_responseContext(p *Check_sat_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response
}

func (*Check_sat_responseContext) IsCheck_sat_responseContext() {}

func NewCheck_sat_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Check_sat_responseContext {
	var p = new(Check_sat_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response

	return p
}

func (s *Check_sat_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Check_sat_responseContext) PS_Sat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Sat, 0)
}

func (s *Check_sat_responseContext) PS_Unsat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsat, 0)
}

func (s *Check_sat_responseContext) PS_Unknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unknown, 0)
}

func (s *Check_sat_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Check_sat_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Check_sat_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCheck_sat_response(s)
	}
}

func (s *Check_sat_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCheck_sat_response(s)
	}
}

func (s *Check_sat_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCheck_sat_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Check_sat_response() (localctx ICheck_sat_responseContext) {
	localctx = NewCheck_sat_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SMTLIBv2ParserRULE_check_sat_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5308416) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEcho_responseContext is an interface to support dynamic dispatch.
type IEcho_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_() IString_Context

	// IsEcho_responseContext differentiates from other interfaces.
	IsEcho_responseContext()
}

type Echo_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEcho_responseContext() *Echo_responseContext {
	var p = new(Echo_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response
	return p
}

func InitEmptyEcho_responseContext(p *Echo_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response
}

func (*Echo_responseContext) IsEcho_responseContext() {}

func NewEcho_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Echo_responseContext {
	var p = new(Echo_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response

	return p
}

func (s *Echo_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Echo_responseContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Echo_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Echo_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Echo_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterEcho_response(s)
	}
}

func (s *Echo_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitEcho_response(s)
	}
}

func (s *Echo_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitEcho_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Echo_response() (localctx IEcho_responseContext) {
	localctx = NewEcho_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SMTLIBv2ParserRULE_echo_response)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_assertions_responseContext is an interface to support dynamic dispatch.
type IGet_assertions_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllTerm() []ITermContext
	Term(i int) ITermContext

	// IsGet_assertions_responseContext differentiates from other interfaces.
	IsGet_assertions_responseContext()
}

type Get_assertions_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_assertions_responseContext() *Get_assertions_responseContext {
	var p = new(Get_assertions_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response
	return p
}

func InitEmptyGet_assertions_responseContext(p *Get_assertions_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response
}

func (*Get_assertions_responseContext) IsGet_assertions_responseContext() {}

func NewGet_assertions_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_assertions_responseContext {
	var p = new(Get_assertions_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response

	return p
}

func (s *Get_assertions_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_assertions_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_assertions_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_assertions_responseContext) AllTerm() []ITermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITermContext); ok {
			len++
		}
	}

	tst := make([]ITermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITermContext); ok {
			tst[i] = t.(ITermContext)
			i++
		}
	}

	return tst
}

func (s *Get_assertions_responseContext) Term(i int) ITermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Get_assertions_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_assertions_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_assertions_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_assertions_response(s)
	}
}

func (s *Get_assertions_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_assertions_response(s)
	}
}

func (s *Get_assertions_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_assertions_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_assertions_response() (localctx IGet_assertions_responseContext) {
	localctx = NewGet_assertions_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SMTLIBv2ParserRULE_get_assertions_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388580) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&140737488355343) != 0) {
		{
			p.SetState(1007)
			p.Term()
		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1013)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_assignment_responseContext is an interface to support dynamic dispatch.
type IGet_assignment_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllT_valuation_pair() []IT_valuation_pairContext
	T_valuation_pair(i int) IT_valuation_pairContext

	// IsGet_assignment_responseContext differentiates from other interfaces.
	IsGet_assignment_responseContext()
}

type Get_assignment_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_assignment_responseContext() *Get_assignment_responseContext {
	var p = new(Get_assignment_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response
	return p
}

func InitEmptyGet_assignment_responseContext(p *Get_assignment_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response
}

func (*Get_assignment_responseContext) IsGet_assignment_responseContext() {}

func NewGet_assignment_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_assignment_responseContext {
	var p = new(Get_assignment_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response

	return p
}

func (s *Get_assignment_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_assignment_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_assignment_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_assignment_responseContext) AllT_valuation_pair() []IT_valuation_pairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IT_valuation_pairContext); ok {
			len++
		}
	}

	tst := make([]IT_valuation_pairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IT_valuation_pairContext); ok {
			tst[i] = t.(IT_valuation_pairContext)
			i++
		}
	}

	return tst
}

func (s *Get_assignment_responseContext) T_valuation_pair(i int) IT_valuation_pairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IT_valuation_pairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IT_valuation_pairContext)
}

func (s *Get_assignment_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_assignment_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_assignment_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_assignment_response(s)
	}
}

func (s *Get_assignment_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_assignment_response(s)
	}
}

func (s *Get_assignment_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_assignment_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_assignment_response() (localctx IGet_assignment_responseContext) {
	localctx = NewGet_assignment_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SMTLIBv2ParserRULE_get_assignment_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(1016)
			p.T_valuation_pair()
		}

		p.SetState(1021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1022)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_info_responseContext is an interface to support dynamic dispatch.
type IGet_info_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllInfo_response() []IInfo_responseContext
	Info_response(i int) IInfo_responseContext

	// IsGet_info_responseContext differentiates from other interfaces.
	IsGet_info_responseContext()
}

type Get_info_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_info_responseContext() *Get_info_responseContext {
	var p = new(Get_info_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response
	return p
}

func InitEmptyGet_info_responseContext(p *Get_info_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response
}

func (*Get_info_responseContext) IsGet_info_responseContext() {}

func NewGet_info_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_info_responseContext {
	var p = new(Get_info_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response

	return p
}

func (s *Get_info_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_info_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_info_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_info_responseContext) AllInfo_response() []IInfo_responseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInfo_responseContext); ok {
			len++
		}
	}

	tst := make([]IInfo_responseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInfo_responseContext); ok {
			tst[i] = t.(IInfo_responseContext)
			i++
		}
	}

	return tst
}

func (s *Get_info_responseContext) Info_response(i int) IInfo_responseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfo_responseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfo_responseContext)
}

func (s *Get_info_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_info_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_info_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_info_response(s)
	}
}

func (s *Get_info_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_info_response(s)
	}
}

func (s *Get_info_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_info_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_info_response() (localctx IGet_info_responseContext) {
	localctx = NewGet_info_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SMTLIBv2ParserRULE_get_info_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4398046511103) != 0) {
		{
			p.SetState(1025)
			p.Info_response()
		}

		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1030)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_model_responseContext is an interface to support dynamic dispatch.
type IGet_model_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	RS_Model() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllModel_response() []IModel_responseContext
	Model_response(i int) IModel_responseContext

	// IsGet_model_responseContext differentiates from other interfaces.
	IsGet_model_responseContext()
}

type Get_model_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_model_responseContext() *Get_model_responseContext {
	var p = new(Get_model_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response
	return p
}

func InitEmptyGet_model_responseContext(p *Get_model_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response
}

func (*Get_model_responseContext) IsGet_model_responseContext() {}

func NewGet_model_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_model_responseContext {
	var p = new(Get_model_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response

	return p
}

func (s *Get_model_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_model_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_model_responseContext) RS_Model() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserRS_Model, 0)
}

func (s *Get_model_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_model_responseContext) AllModel_response() []IModel_responseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModel_responseContext); ok {
			len++
		}
	}

	tst := make([]IModel_responseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModel_responseContext); ok {
			tst[i] = t.(IModel_responseContext)
			i++
		}
	}

	return tst
}

func (s *Get_model_responseContext) Model_response(i int) IModel_responseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModel_responseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModel_responseContext)
}

func (s *Get_model_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_model_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_model_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_model_response(s)
	}
}

func (s *Get_model_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_model_response(s)
	}
}

func (s *Get_model_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_model_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_model_response() (localctx IGet_model_responseContext) {
	localctx = NewGet_model_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SMTLIBv2ParserRULE_get_model_response)
	var _la int

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1032)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1033)
			p.Match(SMTLIBv2ParserRS_Model)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(1034)
				p.Model_response()
			}

			p.SetState(1039)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1040)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1041)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(1042)
				p.Model_response()
			}

			p.SetState(1047)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1048)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_option_responseContext is an interface to support dynamic dispatch.
type IGet_option_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Attribute_value() IAttribute_valueContext

	// IsGet_option_responseContext differentiates from other interfaces.
	IsGet_option_responseContext()
}

type Get_option_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_option_responseContext() *Get_option_responseContext {
	var p = new(Get_option_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response
	return p
}

func InitEmptyGet_option_responseContext(p *Get_option_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response
}

func (*Get_option_responseContext) IsGet_option_responseContext() {}

func NewGet_option_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_option_responseContext {
	var p = new(Get_option_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response

	return p
}

func (s *Get_option_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_option_responseContext) Attribute_value() IAttribute_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribute_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *Get_option_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_option_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_option_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_option_response(s)
	}
}

func (s *Get_option_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_option_response(s)
	}
}

func (s *Get_option_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_option_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_option_response() (localctx IGet_option_responseContext) {
	localctx = NewGet_option_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SMTLIBv2ParserRULE_get_option_response)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Attribute_value()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_proof_responseContext is an interface to support dynamic dispatch.
type IGet_proof_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	S_expr() IS_exprContext

	// IsGet_proof_responseContext differentiates from other interfaces.
	IsGet_proof_responseContext()
}

type Get_proof_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_proof_responseContext() *Get_proof_responseContext {
	var p = new(Get_proof_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response
	return p
}

func InitEmptyGet_proof_responseContext(p *Get_proof_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response
}

func (*Get_proof_responseContext) IsGet_proof_responseContext() {}

func NewGet_proof_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_proof_responseContext {
	var p = new(Get_proof_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response

	return p
}

func (s *Get_proof_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_proof_responseContext) S_expr() IS_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IS_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Get_proof_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_proof_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_proof_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_proof_response(s)
	}
}

func (s *Get_proof_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_proof_response(s)
	}
}

func (s *Get_proof_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_proof_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_proof_response() (localctx IGet_proof_responseContext) {
	localctx = NewGet_proof_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SMTLIBv2ParserRULE_get_proof_response)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.S_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_unsat_assump_responseContext is an interface to support dynamic dispatch.
type IGet_unsat_assump_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext

	// IsGet_unsat_assump_responseContext differentiates from other interfaces.
	IsGet_unsat_assump_responseContext()
}

type Get_unsat_assump_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_unsat_assump_responseContext() *Get_unsat_assump_responseContext {
	var p = new(Get_unsat_assump_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response
	return p
}

func InitEmptyGet_unsat_assump_responseContext(p *Get_unsat_assump_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response
}

func (*Get_unsat_assump_responseContext) IsGet_unsat_assump_responseContext() {}

func NewGet_unsat_assump_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_unsat_assump_responseContext {
	var p = new(Get_unsat_assump_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response

	return p
}

func (s *Get_unsat_assump_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_unsat_assump_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_unsat_assump_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_unsat_assump_responseContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *Get_unsat_assump_responseContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Get_unsat_assump_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_unsat_assump_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_unsat_assump_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_unsat_assump_response(s)
	}
}

func (s *Get_unsat_assump_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_unsat_assump_response(s)
	}
}

func (s *Get_unsat_assump_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_unsat_assump_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_unsat_assump_response() (localctx IGet_unsat_assump_responseContext) {
	localctx = NewGet_unsat_assump_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SMTLIBv2ParserRULE_get_unsat_assump_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1056)
			p.Symbol()
		}

		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1062)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_unsat_core_responseContext is an interface to support dynamic dispatch.
type IGet_unsat_core_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllSymbol() []ISymbolContext
	Symbol(i int) ISymbolContext

	// IsGet_unsat_core_responseContext differentiates from other interfaces.
	IsGet_unsat_core_responseContext()
}

type Get_unsat_core_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_unsat_core_responseContext() *Get_unsat_core_responseContext {
	var p = new(Get_unsat_core_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response
	return p
}

func InitEmptyGet_unsat_core_responseContext(p *Get_unsat_core_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response
}

func (*Get_unsat_core_responseContext) IsGet_unsat_core_responseContext() {}

func NewGet_unsat_core_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_unsat_core_responseContext {
	var p = new(Get_unsat_core_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response

	return p
}

func (s *Get_unsat_core_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_unsat_core_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_unsat_core_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_unsat_core_responseContext) AllSymbol() []ISymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolContext); ok {
			len++
		}
	}

	tst := make([]ISymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolContext); ok {
			tst[i] = t.(ISymbolContext)
			i++
		}
	}

	return tst
}

func (s *Get_unsat_core_responseContext) Symbol(i int) ISymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Get_unsat_core_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_unsat_core_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_unsat_core_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_unsat_core_response(s)
	}
}

func (s *Get_unsat_core_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_unsat_core_response(s)
	}
}

func (s *Get_unsat_core_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_unsat_core_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_unsat_core_response() (localctx IGet_unsat_core_responseContext) {
	localctx = NewGet_unsat_core_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SMTLIBv2ParserRULE_get_unsat_core_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1064)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8388544) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1065)
			p.Symbol()
		}

		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1071)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_value_responseContext is an interface to support dynamic dispatch.
type IGet_value_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParOpen() antlr.TerminalNode
	ParClose() antlr.TerminalNode
	AllValuation_pair() []IValuation_pairContext
	Valuation_pair(i int) IValuation_pairContext

	// IsGet_value_responseContext differentiates from other interfaces.
	IsGet_value_responseContext()
}

type Get_value_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_value_responseContext() *Get_value_responseContext {
	var p = new(Get_value_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response
	return p
}

func InitEmptyGet_value_responseContext(p *Get_value_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response
}

func (*Get_value_responseContext) IsGet_value_responseContext() {}

func NewGet_value_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_value_responseContext {
	var p = new(Get_value_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response

	return p
}

func (s *Get_value_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_value_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_value_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_value_responseContext) AllValuation_pair() []IValuation_pairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValuation_pairContext); ok {
			len++
		}
	}

	tst := make([]IValuation_pairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValuation_pairContext); ok {
			tst[i] = t.(IValuation_pairContext)
			i++
		}
	}

	return tst
}

func (s *Get_value_responseContext) Valuation_pair(i int) IValuation_pairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuation_pairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuation_pairContext)
}

func (s *Get_value_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_value_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_value_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_value_response(s)
	}
}

func (s *Get_value_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_value_response(s)
	}
}

func (s *Get_value_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_value_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_value_response() (localctx IGet_value_responseContext) {
	localctx = NewGet_value_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SMTLIBv2ParserRULE_get_value_response)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(SMTLIBv2ParserParOpen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(1074)
			p.Valuation_pair()
		}

		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1079)
		p.Match(SMTLIBv2ParserParClose)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecific_success_responseContext is an interface to support dynamic dispatch.
type ISpecific_success_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Check_sat_response() ICheck_sat_responseContext
	Echo_response() IEcho_responseContext
	Get_assertions_response() IGet_assertions_responseContext
	Get_assignment_response() IGet_assignment_responseContext
	Get_info_response() IGet_info_responseContext
	Get_model_response() IGet_model_responseContext
	Get_option_response() IGet_option_responseContext
	Get_proof_response() IGet_proof_responseContext
	Get_unsat_assump_response() IGet_unsat_assump_responseContext
	Get_unsat_core_response() IGet_unsat_core_responseContext
	Get_value_response() IGet_value_responseContext

	// IsSpecific_success_responseContext differentiates from other interfaces.
	IsSpecific_success_responseContext()
}

type Specific_success_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecific_success_responseContext() *Specific_success_responseContext {
	var p = new(Specific_success_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response
	return p
}

func InitEmptySpecific_success_responseContext(p *Specific_success_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response
}

func (*Specific_success_responseContext) IsSpecific_success_responseContext() {}

func NewSpecific_success_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specific_success_responseContext {
	var p = new(Specific_success_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response

	return p
}

func (s *Specific_success_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Specific_success_responseContext) Check_sat_response() ICheck_sat_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheck_sat_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheck_sat_responseContext)
}

func (s *Specific_success_responseContext) Echo_response() IEcho_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEcho_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEcho_responseContext)
}

func (s *Specific_success_responseContext) Get_assertions_response() IGet_assertions_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_assertions_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_assertions_responseContext)
}

func (s *Specific_success_responseContext) Get_assignment_response() IGet_assignment_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_assignment_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_assignment_responseContext)
}

func (s *Specific_success_responseContext) Get_info_response() IGet_info_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_info_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_info_responseContext)
}

func (s *Specific_success_responseContext) Get_model_response() IGet_model_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_model_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_model_responseContext)
}

func (s *Specific_success_responseContext) Get_option_response() IGet_option_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_option_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_option_responseContext)
}

func (s *Specific_success_responseContext) Get_proof_response() IGet_proof_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_proof_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_proof_responseContext)
}

func (s *Specific_success_responseContext) Get_unsat_assump_response() IGet_unsat_assump_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_unsat_assump_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_unsat_assump_responseContext)
}

func (s *Specific_success_responseContext) Get_unsat_core_response() IGet_unsat_core_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_unsat_core_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_unsat_core_responseContext)
}

func (s *Specific_success_responseContext) Get_value_response() IGet_value_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_value_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_value_responseContext)
}

func (s *Specific_success_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specific_success_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specific_success_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSpecific_success_response(s)
	}
}

func (s *Specific_success_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSpecific_success_response(s)
	}
}

func (s *Specific_success_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSpecific_success_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Specific_success_response() (localctx ISpecific_success_responseContext) {
	localctx = NewSpecific_success_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SMTLIBv2ParserRULE_specific_success_response)
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1081)
			p.Check_sat_response()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1082)
			p.Echo_response()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1083)
			p.Get_assertions_response()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1084)
			p.Get_assignment_response()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1085)
			p.Get_info_response()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1086)
			p.Get_model_response()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1087)
			p.Get_option_response()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1088)
			p.Get_proof_response()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1089)
			p.Get_unsat_assump_response()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1090)
			p.Get_unsat_core_response()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1091)
			p.Get_value_response()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneral_responseContext is an interface to support dynamic dispatch.
type IGeneral_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PS_Success() antlr.TerminalNode
	Specific_success_response() ISpecific_success_responseContext
	PS_Unsupported() antlr.TerminalNode
	ParOpen() antlr.TerminalNode
	PS_Error() antlr.TerminalNode
	String_() IString_Context
	ParClose() antlr.TerminalNode

	// IsGeneral_responseContext differentiates from other interfaces.
	IsGeneral_responseContext()
}

type General_responseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_responseContext() *General_responseContext {
	var p = new(General_responseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_general_response
	return p
}

func InitEmptyGeneral_responseContext(p *General_responseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_general_response
}

func (*General_responseContext) IsGeneral_responseContext() {}

func NewGeneral_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_responseContext {
	var p = new(General_responseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_general_response

	return p
}

func (s *General_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *General_responseContext) PS_Success() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Success, 0)
}

func (s *General_responseContext) Specific_success_response() ISpecific_success_responseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecific_success_responseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecific_success_responseContext)
}

func (s *General_responseContext) PS_Unsupported() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsupported, 0)
}

func (s *General_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *General_responseContext) PS_Error() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Error, 0)
}

func (s *General_responseContext) String_() IString_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *General_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *General_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGeneral_response(s)
	}
}

func (s *General_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGeneral_response(s)
	}
}

func (s *General_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGeneral_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) General_response() (localctx IGeneral_responseContext) {
	localctx = NewGeneral_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SMTLIBv2ParserRULE_general_response)
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1094)
			p.Match(SMTLIBv2ParserPS_Success)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1095)
			p.Specific_success_response()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1096)
			p.Match(SMTLIBv2ParserPS_Unsupported)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1097)
			p.Match(SMTLIBv2ParserParOpen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1098)
			p.Match(SMTLIBv2ParserPS_Error)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1099)
			p.String_()
		}
		{
			p.SetState(1100)
			p.Match(SMTLIBv2ParserParClose)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
