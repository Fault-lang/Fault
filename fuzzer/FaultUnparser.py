# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import FaultUnlexer


class FaultUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(FaultUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def spec(self):
        current = self.create_node(UnparserRule(name='spec'))
        current += self.specClause()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.importDecl()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.declaration()

        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.forStmt()

        current += self.eos()
        return current
    spec.min_depth = 3

    @depthcontrol
    def specClause(self):
        current = self.create_node(UnparserRule(name='specClause'))
        current += self.create_node(UnlexerRule(src='spec'))
        current += self.unlexer.IDENT()
        current += self.eos()
        return current
    specClause.min_depth = 2

    @depthcontrol
    def importDecl(self):
        current = self.create_node(UnparserRule(name='importDecl'))
        current += self.create_node(UnlexerRule(src='import'))
        choice = self.choice([0 if [4, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_398', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_398', choice)] = self.unlexer.weights.get(('alt_398', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.importSpec()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_more():
                    current += self.importSpec()

            current += self.create_node(UnlexerRule(src=')'))
        current += self.eos()
        return current
    importDecl.min_depth = 1

    @depthcontrol
    def importSpec(self):
        current = self.create_node(UnparserRule(name='importSpec'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [0, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_405', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_405', choice)] = self.unlexer.weights.get(('alt_405', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.create_node(UnlexerRule(src='.'))
                elif choice == 1:
                    current += self.unlexer.IDENT()

        current += self.importPath()
        return current
    importSpec.min_depth = 3

    @depthcontrol
    def importPath(self):
        current = self.create_node(UnparserRule(name='importPath'))
        current += self.string_()
        return current
    importPath.min_depth = 2

    @depthcontrol
    def declaration(self):
        current = self.create_node(UnparserRule(name='declaration'))
        choice = self.choice([0 if [1, 4, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_409', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_409', choice)] = self.unlexer.weights.get(('alt_409', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.constDecl()
        elif choice == 1:
            current += self.structDecl()
        elif choice == 2:
            current += self.assertion()
        return current
    declaration.min_depth = 1

    @depthcontrol
    def constDecl(self):
        current = self.create_node(UnparserRule(name='constDecl'))
        current += self.create_node(UnlexerRule(src='const'))
        choice = self.choice([0 if [4, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_414', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_414', choice)] = self.unlexer.weights.get(('alt_414', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.constSpec()
            current += self.eos()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_more():
                    current += self.constSpec()
                    current += self.eos()

            current += self.create_node(UnlexerRule(src=')'))
        return current
    constDecl.min_depth = 0

    @depthcontrol
    def constSpec(self):
        current = self.create_node(UnparserRule(name='constSpec'))
        current += self.identList()
        if self.unlexer.max_depth >= 5:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='='))
                current += self.expressionList()

        return current
    constSpec.min_depth = 3

    @depthcontrol
    def identList(self):
        current = self.create_node(UnparserRule(name='identList'))
        current += self.operandName()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.operandName()

        return current
    identList.min_depth = 2

    @depthcontrol
    def expressionList(self):
        current = self.create_node(UnparserRule(name='expressionList'))
        current += self.expression()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.expression()

        return current
    expressionList.min_depth = 4

    @depthcontrol
    def structDecl(self):
        current = self.create_node(UnparserRule(name='structDecl'))
        current += self.create_node(UnlexerRule(src='def'))
        current += self.identList()
        current += self.create_node(UnlexerRule(src='='))
        current += self.structType()
        current += self.eos()
        return current
    structDecl.min_depth = 3

    @depthcontrol
    def structType(self):
        current = self.create_node(UnparserRule(name='structType'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_428', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_428', choice)] = self.unlexer.weights.get(('alt_428', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.structType_Flow()
        elif choice == 1:
            current = self.structType_Stock()
        return current
    structType.min_depth = 1

    @depthcontrol
    def structType_Flow(self):
        current = self.create_node(UnparserRule(name='structType_Flow'))
        current += self.create_node(UnlexerRule(src='flow'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.structProperties()
                current += self.create_node(UnlexerRule(src=','))

        current += self.create_node(UnlexerRule(src='}'))
        return current
    structType_Flow.min_depth = 0

    @depthcontrol
    def structType_Stock(self):
        current = self.create_node(UnparserRule(name='structType_Stock'))
        current += self.create_node(UnlexerRule(src='stock'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.structProperties()
                current += self.create_node(UnlexerRule(src=','))

        current += self.create_node(UnlexerRule(src='}'))
        return current
    structType_Stock.min_depth = 0

    @depthcontrol
    def structProperties(self):
        current = self.create_node(UnparserRule(name='structProperties'))
        choice = self.choice([0 if [4, 3, 3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_441', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_441', choice)] = self.unlexer.weights.get(('alt_441', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.structProperties_PropInt()
        elif choice == 1:
            current = self.structProperties_PropString()
        elif choice == 2:
            current = self.structProperties_PropFunc()
        elif choice == 3:
            current = self.structProperties_PropVar()
        return current
    structProperties.min_depth = 3

    @depthcontrol
    def structProperties_PropInt(self):
        current = self.create_node(UnparserRule(name='structProperties_PropInt'))
        current += self.unlexer.IDENT()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.numeric()
        return current
    structProperties_PropInt.min_depth = 3

    @depthcontrol
    def structProperties_PropString(self):
        current = self.create_node(UnparserRule(name='structProperties_PropString'))
        current += self.unlexer.IDENT()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.string_()
        return current
    structProperties_PropString.min_depth = 2

    @depthcontrol
    def structProperties_PropFunc(self):
        current = self.create_node(UnparserRule(name='structProperties_PropFunc'))
        current += self.unlexer.IDENT()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.functionLit()
        return current
    structProperties_PropFunc.min_depth = 2

    @depthcontrol
    def structProperties_PropVar(self):
        current = self.create_node(UnparserRule(name='structProperties_PropVar'))
        current += self.unlexer.IDENT()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.instance()
        return current
    structProperties_PropVar.min_depth = 3

    @depthcontrol
    def instance(self):
        current = self.create_node(UnparserRule(name='instance'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src='new'))

        current += self.operandName()
        return current
    instance.min_depth = 2

    @depthcontrol
    def initDecl(self):
        current = self.create_node(UnparserRule(name='initDecl'))
        current += self.create_node(UnlexerRule(src='init'))
        current += self.operand()
        current += self.eos()
        return current
    initDecl.min_depth = 2

    @depthcontrol
    def block(self):
        current = self.create_node(UnparserRule(name='block'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        current += self.create_node(UnlexerRule(src='}'))
        return current
    block.min_depth = 0

    @depthcontrol
    def statementList(self):
        current = self.create_node(UnparserRule(name='statementList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.statement()

        return current
    statementList.min_depth = 2

    @depthcontrol
    def statement(self):
        current = self.create_node(UnparserRule(name='statement'))
        choice = self.choice([0 if [1, 3, 2, 1, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_456', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_456', choice)] = self.unlexer.weights.get(('alt_456', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.constDecl()
        elif choice == 1:
            current += self.initDecl()
        elif choice == 2:
            current += self.simpleStmt()
            current += self.eos()
        elif choice == 3:
            current += self.block()
        elif choice == 4:
            current += self.ifStmt()
        return current
    statement.min_depth = 1

    @depthcontrol
    def simpleStmt(self):
        current = self.create_node(UnparserRule(name='simpleStmt'))
        choice = self.choice([0 if [4, 5, 7, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_462', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_462', choice)] = self.unlexer.weights.get(('alt_462', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.expression()
        elif choice == 1:
            current += self.incDecStmt()
        elif choice == 2:
            current += self.assignment()
        elif choice == 3:
            current += self.emptyStmt()
        return current
    simpleStmt.min_depth = 1

    @depthcontrol
    def incDecStmt(self):
        current = self.create_node(UnparserRule(name='incDecStmt'))
        current += self.expression()
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_467', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_467', choice)] = self.unlexer.weights.get(('alt_467', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.PLUS_PLUS()
        elif choice == 1:
            current += self.unlexer.MINUS_MINUS()
        return current
    incDecStmt.min_depth = 4

    @depthcontrol
    def accessHistory(self):
        current = self.create_node(UnparserRule(name='accessHistory'))
        current += self.operandName()
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src='['))
                current += self.expression()
                current += self.create_node(UnlexerRule(src=']'))

        return current
    accessHistory.min_depth = 4

    @depthcontrol
    def assertion(self):
        current = self.create_node(UnparserRule(name='assertion'))
        current += self.create_node(UnlexerRule(src='assert'))
        current += self.expression()
        return current
    assertion.min_depth = 4

    @depthcontrol
    def assignment(self):
        current = self.create_node(UnparserRule(name='assignment'))
        choice = self.choice([0 if [6, 6][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_473', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_473', choice)] = self.unlexer.weights.get(('alt_473', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.assignment_MiscAssign()
        elif choice == 1:
            current = self.assignment_FaultAssign()
        return current
    assignment.min_depth = 6

    @depthcontrol
    def assignment_MiscAssign(self):
        current = self.create_node(UnparserRule(name='assignment_MiscAssign'))
        current += self.expressionList()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_477', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
                self.unlexer.weights[('alt_477', choice)] = self.unlexer.weights.get(('alt_477', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.create_node(UnlexerRule(src='+'))
                elif choice == 1:
                    current += self.create_node(UnlexerRule(src='-'))
                elif choice == 2:
                    current += self.create_node(UnlexerRule(src='^'))
                elif choice == 3:
                    current += self.create_node(UnlexerRule(src='*'))
                elif choice == 4:
                    current += self.create_node(UnlexerRule(src='/'))
                elif choice == 5:
                    current += self.create_node(UnlexerRule(src='%'))
                elif choice == 6:
                    current += self.create_node(UnlexerRule(src='<<'))
                elif choice == 7:
                    current += self.create_node(UnlexerRule(src='>>'))
                elif choice == 8:
                    current += self.create_node(UnlexerRule(src='&'))
                elif choice == 9:
                    current += self.create_node(UnlexerRule(src='&^'))

        current += self.create_node(UnlexerRule(src='='))
        current += self.expressionList()
        return current
    assignment_MiscAssign.min_depth = 5

    @depthcontrol
    def assignment_FaultAssign(self):
        current = self.create_node(UnparserRule(name='assignment_FaultAssign'))
        current += self.expressionList()
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_499', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_499', choice)] = self.unlexer.weights.get(('alt_499', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='->'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='<-'))
        current += self.expressionList()
        return current
    assignment_FaultAssign.min_depth = 5

    @depthcontrol
    def emptyStmt(self):
        current = self.create_node(UnparserRule(name='emptyStmt'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    emptyStmt.min_depth = 0

    @depthcontrol
    def ifStmt(self):
        current = self.create_node(UnparserRule(name='ifStmt'))
        current += self.create_node(UnlexerRule(src='if'))
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.simpleStmt()
                current += self.create_node(UnlexerRule(src=';'))

        current += self.expression()
        current += self.block()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='else'))
                choice = self.choice([0 if [5, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_510', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_510', choice)] = self.unlexer.weights.get(('alt_510', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.ifStmt()
                elif choice == 1:
                    current += self.block()

        return current
    ifStmt.min_depth = 4

    @depthcontrol
    def forStmt(self):
        current = self.create_node(UnparserRule(name='forStmt'))
        current += self.create_node(UnlexerRule(src='for'))
        current += self.integer()
        current += self.create_node(UnlexerRule(src='run'))
        current += self.block()
        current += self.eos()
        return current
    forStmt.min_depth = 2

    @depthcontrol
    def faultType(self):
        current = self.create_node(UnparserRule(name='faultType'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_515', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_515', choice)] = self.unlexer.weights.get(('alt_515', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.TY_STRING()
        elif choice == 1:
            current += self.unlexer.TY_BOOL()
        elif choice == 2:
            current += self.unlexer.TY_INT()
        elif choice == 3:
            current += self.unlexer.TY_FLOAT()
        elif choice == 4:
            current += self.unlexer.TY_NATURAL()
        elif choice == 5:
            current += self.unlexer.TY_UNCERTAIN()
        return current
    faultType.min_depth = 1

    @depthcontrol
    def expression(self):
        current = self.create_node(UnparserRule(name='expression'))
        choice = self.choice([0 if [3, 3, 5, 5, 5, 5, 5, 5, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_522', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_522', choice)] = self.unlexer.weights.get(('alt_522', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.expression_Expr()
        elif choice == 1:
            current = self.expression_Typed()
        elif choice == 2:
            current = self.expression_Prefix()
        elif choice == 3:
            current = self.expression_lrExpr()
        elif choice == 4:
            current = self.expression_lrExpr()
        elif choice == 5:
            current = self.expression_lrExpr()
        elif choice == 6:
            current = self.expression_lrExpr()
        elif choice == 7:
            current = self.expression_lrExpr()
        elif choice == 8:
            current = self.expression_lrExpr()
        return current
    expression.min_depth = 3

    @depthcontrol
    def expression_Expr(self):
        current = self.create_node(UnparserRule(name='expression_Expr'))
        current += self.operand()
        return current
    expression_Expr.min_depth = 2

    @depthcontrol
    def expression_Typed(self):
        current = self.create_node(UnparserRule(name='expression_Typed'))
        current += self.faultType()
        current += self.create_node(UnlexerRule(src='('))
        current += self.operand()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.operand()

        current += self.create_node(UnlexerRule(src=')'))
        return current
    expression_Typed.min_depth = 2

    @depthcontrol
    def expression_Prefix(self):
        current = self.create_node(UnparserRule(name='expression_Prefix'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_536', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_536', choice)] = self.unlexer.weights.get(('alt_536', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='!'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='^'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='*'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='&'))
        current += self.expression()
        return current
    expression_Prefix.min_depth = 4

    @depthcontrol
    def expression_lrExpr(self):
        current = self.create_node(UnparserRule(name='expression_lrExpr'))
        current += self.expression()
        current += self.create_node(UnlexerRule(src='**'))
        current += self.expression()
        return current
    expression_lrExpr.min_depth = 4

    @depthcontrol
    def expression_lrExpr(self):
        current = self.create_node(UnparserRule(name='expression_lrExpr'))
        current += self.expression()
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_550', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_550', choice)] = self.unlexer.weights.get(('alt_550', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='/'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='%'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='<<'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='>>'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='&'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='&^'))
        current += self.expression()
        return current
    expression_lrExpr.min_depth = 4

    @depthcontrol
    def expression_lrExpr(self):
        current = self.create_node(UnparserRule(name='expression_lrExpr'))
        current += self.expression()
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_565', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_565', choice)] = self.unlexer.weights.get(('alt_565', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='^'))
        current += self.expression()
        return current
    expression_lrExpr.min_depth = 4

    @depthcontrol
    def expression_lrExpr(self):
        current = self.create_node(UnparserRule(name='expression_lrExpr'))
        current += self.expression()
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_572', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_572', choice)] = self.unlexer.weights.get(('alt_572', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='=='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='!='))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='<'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='<='))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='>'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='>='))
        current += self.expression()
        return current
    expression_lrExpr.min_depth = 4

    @depthcontrol
    def expression_lrExpr(self):
        current = self.create_node(UnparserRule(name='expression_lrExpr'))
        current += self.expression()
        current += self.create_node(UnlexerRule(src='&&'))
        current += self.expression()
        return current
    expression_lrExpr.min_depth = 4

    @depthcontrol
    def expression_lrExpr(self):
        current = self.create_node(UnparserRule(name='expression_lrExpr'))
        current += self.expression()
        current += self.create_node(UnlexerRule(src='||'))
        current += self.expression()
        return current
    expression_lrExpr.min_depth = 4

    @depthcontrol
    def operand(self):
        current = self.create_node(UnparserRule(name='operand'))
        choice = self.choice([0 if [1, 3, 2, 2, 3, 2, 5, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_587', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_587', choice)] = self.unlexer.weights.get(('alt_587', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NIL()
        elif choice == 1:
            current += self.numeric()
        elif choice == 2:
            current += self.string_()
        elif choice == 3:
            current += self.bool_()
        elif choice == 4:
            current += self.instance()
        elif choice == 5:
            current += self.operandName()
        elif choice == 6:
            current += self.accessHistory()
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='('))
            current += self.expression()
            current += self.create_node(UnlexerRule(src=')'))
        return current
    operand.min_depth = 1

    @depthcontrol
    def operandName(self):
        current = self.create_node(UnparserRule(name='operandName'))
        choice = self.choice([0 if [2, 2, 2, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_598', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_598', choice)] = self.unlexer.weights.get(('alt_598', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.IDENT()
        elif choice == 1:
            current += self.unlexer.IDENT()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='.'))
                    current += self.unlexer.IDENT()

        elif choice == 2:
            current += self.create_node(UnlexerRule(src='new'))
            current += self.unlexer.IDENT()
        elif choice == 3:
            current += self.unlexer.THIS()
        elif choice == 4:
            current += self.unlexer.CLOCK()
        return current
    operandName.min_depth = 1

    @depthcontrol
    def numeric(self):
        current = self.create_node(UnparserRule(name='numeric'))
        choice = self.choice([0 if [2, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_607', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_607', choice)] = self.unlexer.weights.get(('alt_607', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.integer()
        elif choice == 1:
            current += self.negative()
        elif choice == 2:
            current += self.float_()
        return current
    numeric.min_depth = 2

    @depthcontrol
    def integer(self):
        current = self.create_node(UnparserRule(name='integer'))
        choice = self.choice([0 if [1, 1, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_611', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_611', choice)] = self.unlexer.weights.get(('alt_611', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.DECIMAL_LIT()
        elif choice == 1:
            current += self.unlexer.OCTAL_LIT()
        elif choice == 2:
            current += self.unlexer.HEX_LIT()
        return current
    integer.min_depth = 1

    @depthcontrol
    def negative(self):
        current = self.create_node(UnparserRule(name='negative'))
        choice = self.choice([0 if [2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_615', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_615', choice)] = self.unlexer.weights.get(('alt_615', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='-'))
            current += self.integer()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
            current += self.float_()
        return current
    negative.min_depth = 2

    @depthcontrol
    def float_(self):
        current = self.create_node(UnparserRule(name='float_'))
        current += self.unlexer.FLOAT_LIT()
        return current
    float_.min_depth = 2

    @depthcontrol
    def string_(self):
        current = self.create_node(UnparserRule(name='string_'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_620', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_620', choice)] = self.unlexer.weights.get(('alt_620', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.RAW_STRING_LIT()
        elif choice == 1:
            current += self.unlexer.INTERPRETED_STRING_LIT()
        return current
    string_.min_depth = 1

    @depthcontrol
    def bool_(self):
        current = self.create_node(UnparserRule(name='bool_'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_623', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_623', choice)] = self.unlexer.weights.get(('alt_623', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.TRUE()
        elif choice == 1:
            current += self.unlexer.FALSE()
        return current
    bool_.min_depth = 1

    @depthcontrol
    def functionLit(self):
        current = self.create_node(UnparserRule(name='functionLit'))
        current += self.create_node(UnlexerRule(src='func'))
        current += self.block()
        return current
    functionLit.min_depth = 1

    @depthcontrol
    def eos(self):
        current = self.create_node(UnparserRule(name='eos'))
        choice = self.choice([0 if [0, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_627', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_627', choice)] = self.unlexer.weights.get(('alt_627', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=';'))
        elif choice == 1:
            current += self.unlexer.EOF()
        return current
    eos.min_depth = 0

    default_rule = spec

