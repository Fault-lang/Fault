// Code generated from SMTLIBv2.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // SMTLIBv2

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 116, 1103,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2,
	205, 10, 2, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 211, 10, 4, 3, 5, 3, 5, 3, 6,
	3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 5, 8, 221, 10, 8, 3, 9, 3, 9, 3, 10, 3, 10,
	3, 11, 3, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 5, 14, 236,
	10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 243, 10, 15, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 7, 16, 250, 10, 16, 12, 16, 14, 16, 253, 11, 16,
	3, 16, 5, 16, 256, 10, 16, 3, 17, 3, 17, 5, 17, 260, 10, 17, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 6, 18, 267, 10, 18, 13, 18, 14, 18, 268, 3, 18,
	3, 18, 5, 18, 273, 10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 7, 19, 279, 10,
	19, 12, 19, 14, 19, 282, 11, 19, 3, 19, 5, 19, 285, 10, 19, 3, 20, 3, 20,
	3, 20, 3, 20, 5, 20, 291, 10, 20, 3, 21, 3, 21, 3, 21, 3, 21, 6, 21, 297,
	10, 21, 13, 21, 14, 21, 298, 3, 21, 3, 21, 5, 21, 303, 10, 21, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 312, 10, 22, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3,
	25, 3, 25, 6, 25, 328, 10, 25, 13, 25, 14, 25, 329, 3, 25, 3, 25, 5, 25,
	334, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3,
	27, 3, 27, 6, 27, 346, 10, 27, 13, 27, 14, 27, 347, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 6, 27, 356, 10, 27, 13, 27, 14, 27, 357, 3, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 6, 27, 368, 10, 27, 13, 27,
	14, 27, 369, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 6,
	27, 380, 10, 27, 13, 27, 14, 27, 381, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 6, 27, 393, 10, 27, 13, 27, 14, 27, 394, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 6, 27, 404, 10, 27, 13, 27,
	14, 27, 405, 3, 27, 3, 27, 5, 27, 410, 10, 27, 3, 28, 3, 28, 3, 28, 3,
	28, 7, 28, 416, 10, 28, 12, 28, 14, 28, 419, 11, 28, 3, 28, 3, 28, 3, 29,
	3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 429, 10, 30, 12, 30, 14, 30,
	432, 11, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 440, 10,
	30, 12, 30, 14, 30, 443, 11, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 6,
	30, 450, 10, 30, 13, 30, 14, 30, 451, 3, 30, 7, 30, 455, 10, 30, 12, 30,
	14, 30, 458, 11, 30, 3, 30, 3, 30, 5, 30, 462, 10, 30, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 6, 31, 469, 10, 31, 13, 31, 14, 31, 470, 3, 31, 3, 31,
	3, 31, 3, 31, 6, 31, 477, 10, 31, 13, 31, 14, 31, 478, 3, 31, 7, 31, 482,
	10, 31, 12, 31, 14, 31, 485, 11, 31, 3, 31, 3, 31, 3, 31, 5, 31, 490, 10,
	31, 3, 32, 3, 32, 3, 32, 6, 32, 495, 10, 32, 13, 32, 14, 32, 496, 3, 32,
	3, 32, 3, 32, 3, 32, 3, 32, 6, 32, 504, 10, 32, 13, 32, 14, 32, 505, 3,
	32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 3, 32, 5, 32, 521, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 6, 33, 527,
	10, 33, 13, 33, 14, 33, 528, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 6, 34,
	536, 10, 34, 13, 34, 14, 34, 537, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 551, 10, 34, 3, 35, 3, 35,
	3, 35, 3, 35, 6, 35, 557, 10, 35, 13, 35, 14, 35, 558, 3, 35, 3, 35, 3,
	36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38,
	3, 38, 3, 38, 7, 38, 576, 10, 38, 12, 38, 14, 38, 579, 11, 38, 3, 38, 3,
	38, 3, 39, 3, 39, 6, 39, 585, 10, 39, 13, 39, 14, 39, 586, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 6, 39, 595, 10, 39, 13, 39, 14, 39, 596, 3,
	39, 3, 39, 3, 39, 6, 39, 602, 10, 39, 13, 39, 14, 39, 603, 3, 39, 3, 39,
	3, 39, 5, 39, 609, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 7, 40, 615, 10,
	40, 12, 40, 14, 40, 618, 11, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3,
	41, 3, 41, 7, 41, 627, 10, 41, 12, 41, 14, 41, 630, 11, 41, 3, 41, 3, 41,
	3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 642, 10,
	42, 3, 43, 7, 43, 645, 10, 43, 12, 43, 14, 43, 648, 11, 43, 3, 44, 3, 44,
	3, 44, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 7, 46, 658, 10, 46, 12, 46, 14,
	46, 661, 11, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 6, 49, 676, 10, 49, 13, 49, 14, 49,
	677, 3, 49, 3, 49, 3, 49, 6, 49, 683, 10, 49, 13, 49, 14, 49, 684, 3, 49,
	3, 49, 3, 50, 3, 50, 3, 50, 3, 50, 7, 50, 693, 10, 50, 12, 50, 14, 50,
	696, 11, 50, 3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3,
	52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 6, 54, 714, 10, 54,
	13, 54, 14, 54, 715, 3, 54, 3, 54, 3, 54, 6, 54, 721, 10, 54, 13, 54, 14,
	54, 722, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 731, 10, 55,
	12, 55, 14, 55, 734, 11, 55, 3, 55, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56,
	3, 57, 3, 57, 3, 58, 3, 58, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 61, 3,
	61, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3, 66,
	3, 66, 3, 66, 6, 66, 765, 10, 66, 13, 66, 14, 66, 766, 3, 66, 3, 66, 3,
	67, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 71,
	3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 5, 74, 910, 10, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3,
	76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76,
	3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3,
	76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 943, 10, 76, 3, 77, 3, 77, 3, 77,
	3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 953, 10, 77, 3, 78, 3, 78, 3,
	79, 3, 79, 3, 79, 5, 79, 960, 10, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80,
	3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 974, 10, 80, 3,
	81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 5, 81, 989, 10, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 85, 3, 85, 3, 86, 3, 86,
	7, 86, 1007, 10, 86, 12, 86, 14, 86, 1010, 11, 86, 3, 86, 3, 86, 3, 87,
	3, 87, 7, 87, 1016, 10, 87, 12, 87, 14, 87, 1019, 11, 87, 3, 87, 3, 87,
	3, 88, 3, 88, 6, 88, 1025, 10, 88, 13, 88, 14, 88, 1026, 3, 88, 3, 88,
	3, 89, 3, 89, 3, 89, 7, 89, 1034, 10, 89, 12, 89, 14, 89, 1037, 11, 89,
	3, 89, 3, 89, 3, 89, 7, 89, 1042, 10, 89, 12, 89, 14, 89, 1045, 11, 89,
	3, 89, 5, 89, 1048, 10, 89, 3, 90, 3, 90, 3, 91, 3, 91, 3, 92, 3, 92, 7,
	92, 1056, 10, 92, 12, 92, 14, 92, 1059, 11, 92, 3, 92, 3, 92, 3, 93, 3,
	93, 7, 93, 1065, 10, 93, 12, 93, 14, 93, 1068, 11, 93, 3, 93, 3, 93, 3,
	94, 3, 94, 6, 94, 1074, 10, 94, 13, 94, 14, 94, 1075, 3, 94, 3, 94, 3,
	95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95,
	5, 95, 1091, 10, 95, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3,
	96, 5, 96, 1101, 10, 96, 3, 96, 2, 2, 97, 2, 4, 6, 8, 10, 12, 14, 16, 18,
	20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
	56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90,
	92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
	182, 184, 186, 188, 190, 2, 9, 4, 2, 55, 67, 114, 114, 3, 2, 9, 24, 3,
	2, 73, 113, 5, 2, 59, 59, 65, 65, 67, 67, 4, 2, 13, 13, 21, 21, 4, 2, 11,
	11, 14, 14, 5, 2, 18, 18, 22, 22, 24, 24, 2, 1173, 2, 204, 3, 2, 2, 2,
	4, 206, 3, 2, 2, 2, 6, 210, 3, 2, 2, 2, 8, 212, 3, 2, 2, 2, 10, 214, 3,
	2, 2, 2, 12, 216, 3, 2, 2, 2, 14, 220, 3, 2, 2, 2, 16, 222, 3, 2, 2, 2,
	18, 224, 3, 2, 2, 2, 20, 226, 3, 2, 2, 2, 22, 228, 3, 2, 2, 2, 24, 230,
	3, 2, 2, 2, 26, 235, 3, 2, 2, 2, 28, 242, 3, 2, 2, 2, 30, 255, 3, 2, 2,
	2, 32, 259, 3, 2, 2, 2, 34, 272, 3, 2, 2, 2, 36, 284, 3, 2, 2, 2, 38, 290,
	3, 2, 2, 2, 40, 302, 3, 2, 2, 2, 42, 311, 3, 2, 2, 2, 44, 313, 3, 2, 2,
	2, 46, 318, 3, 2, 2, 2, 48, 333, 3, 2, 2, 2, 50, 335, 3, 2, 2, 2, 52, 409,
	3, 2, 2, 2, 54, 411, 3, 2, 2, 2, 56, 422, 3, 2, 2, 2, 58, 461, 3, 2, 2,
	2, 60, 489, 3, 2, 2, 2, 62, 520, 3, 2, 2, 2, 64, 522, 3, 2, 2, 2, 66, 550,
	3, 2, 2, 2, 68, 552, 3, 2, 2, 2, 70, 562, 3, 2, 2, 2, 72, 567, 3, 2, 2,
	2, 74, 572, 3, 2, 2, 2, 76, 608, 3, 2, 2, 2, 78, 610, 3, 2, 2, 2, 80, 623,
	3, 2, 2, 2, 82, 641, 3, 2, 2, 2, 84, 646, 3, 2, 2, 2, 86, 649, 3, 2, 2,
	2, 88, 652, 3, 2, 2, 2, 90, 654, 3, 2, 2, 2, 92, 664, 3, 2, 2, 2, 94, 668,
	3, 2, 2, 2, 96, 672, 3, 2, 2, 2, 98, 688, 3, 2, 2, 2, 100, 700, 3, 2, 2,
	2, 102, 704, 3, 2, 2, 2, 104, 707, 3, 2, 2, 2, 106, 710, 3, 2, 2, 2, 108,
	726, 3, 2, 2, 2, 110, 738, 3, 2, 2, 2, 112, 741, 3, 2, 2, 2, 114, 743,
	3, 2, 2, 2, 116, 745, 3, 2, 2, 2, 118, 747, 3, 2, 2, 2, 120, 750, 3, 2,
	2, 2, 122, 752, 3, 2, 2, 2, 124, 755, 3, 2, 2, 2, 126, 757, 3, 2, 2, 2,
	128, 759, 3, 2, 2, 2, 130, 761, 3, 2, 2, 2, 132, 770, 3, 2, 2, 2, 134,
	773, 3, 2, 2, 2, 136, 776, 3, 2, 2, 2, 138, 778, 3, 2, 2, 2, 140, 780,
	3, 2, 2, 2, 142, 783, 3, 2, 2, 2, 144, 786, 3, 2, 2, 2, 146, 909, 3, 2,
	2, 2, 148, 911, 3, 2, 2, 2, 150, 942, 3, 2, 2, 2, 152, 952, 3, 2, 2, 2,
	154, 954, 3, 2, 2, 2, 156, 959, 3, 2, 2, 2, 158, 973, 3, 2, 2, 2, 160,
	988, 3, 2, 2, 2, 162, 990, 3, 2, 2, 2, 164, 995, 3, 2, 2, 2, 166, 1000,
	3, 2, 2, 2, 168, 1002, 3, 2, 2, 2, 170, 1004, 3, 2, 2, 2, 172, 1013, 3,
	2, 2, 2, 174, 1022, 3, 2, 2, 2, 176, 1047, 3, 2, 2, 2, 178, 1049, 3, 2,
	2, 2, 180, 1051, 3, 2, 2, 2, 182, 1053, 3, 2, 2, 2, 184, 1062, 3, 2, 2,
	2, 186, 1071, 3, 2, 2, 2, 188, 1090, 3, 2, 2, 2, 190, 1100, 3, 2, 2, 2,
	192, 193, 5, 68, 35, 2, 193, 194, 7, 2, 2, 3, 194, 205, 3, 2, 2, 2, 195,
	196, 5, 64, 33, 2, 196, 197, 7, 2, 2, 3, 197, 205, 3, 2, 2, 2, 198, 199,
	5, 84, 43, 2, 199, 200, 7, 2, 2, 3, 200, 205, 3, 2, 2, 2, 201, 202, 5,
	190, 96, 2, 202, 203, 7, 2, 2, 3, 203, 205, 3, 2, 2, 2, 204, 192, 3, 2,
	2, 2, 204, 195, 3, 2, 2, 2, 204, 198, 3, 2, 2, 2, 204, 201, 3, 2, 2, 2,
	205, 3, 3, 2, 2, 2, 206, 207, 9, 2, 2, 2, 207, 5, 3, 2, 2, 2, 208, 211,
	5, 10, 6, 2, 209, 211, 7, 115, 2, 2, 210, 208, 3, 2, 2, 2, 210, 209, 3,
	2, 2, 2, 211, 7, 3, 2, 2, 2, 212, 213, 7, 8, 2, 2, 213, 9, 3, 2, 2, 2,
	214, 215, 9, 3, 2, 2, 215, 11, 3, 2, 2, 2, 216, 217, 9, 4, 2, 2, 217, 13,
	3, 2, 2, 2, 218, 221, 5, 6, 4, 2, 219, 221, 5, 8, 5, 2, 220, 218, 3, 2,
	2, 2, 220, 219, 3, 2, 2, 2, 221, 15, 3, 2, 2, 2, 222, 223, 7, 68, 2, 2,
	223, 17, 3, 2, 2, 2, 224, 225, 7, 71, 2, 2, 225, 19, 3, 2, 2, 2, 226, 227,
	7, 70, 2, 2, 227, 21, 3, 2, 2, 2, 228, 229, 7, 69, 2, 2, 229, 23, 3, 2,
	2, 2, 230, 231, 7, 7, 2, 2, 231, 25, 3, 2, 2, 2, 232, 236, 5, 12, 7, 2,
	233, 234, 7, 72, 2, 2, 234, 236, 5, 6, 4, 2, 235, 232, 3, 2, 2, 2, 235,
	233, 3, 2, 2, 2, 236, 27, 3, 2, 2, 2, 237, 243, 5, 16, 9, 2, 238, 243,
	5, 18, 10, 2, 239, 243, 5, 20, 11, 2, 240, 243, 5, 22, 12, 2, 241, 243,
	5, 24, 13, 2, 242, 237, 3, 2, 2, 2, 242, 238, 3, 2, 2, 2, 242, 239, 3,
	2, 2, 2, 242, 240, 3, 2, 2, 2, 242, 241, 3, 2, 2, 2, 243, 29, 3, 2, 2,
	2, 244, 256, 5, 28, 15, 2, 245, 256, 5, 14, 8, 2, 246, 256, 5, 26, 14,
	2, 247, 251, 7, 4, 2, 2, 248, 250, 5, 30, 16, 2, 249, 248, 3, 2, 2, 2,
	250, 253, 3, 2, 2, 2, 251, 249, 3, 2, 2, 2, 251, 252, 3, 2, 2, 2, 252,
	254, 3, 2, 2, 2, 253, 251, 3, 2, 2, 2, 254, 256, 7, 5, 2, 2, 255, 244,
	3, 2, 2, 2, 255, 245, 3, 2, 2, 2, 255, 246, 3, 2, 2, 2, 255, 247, 3, 2,
	2, 2, 256, 31, 3, 2, 2, 2, 257, 260, 5, 16, 9, 2, 258, 260, 5, 14, 8, 2,
	259, 257, 3, 2, 2, 2, 259, 258, 3, 2, 2, 2, 260, 33, 3, 2, 2, 2, 261, 273,
	5, 14, 8, 2, 262, 263, 7, 4, 2, 2, 263, 264, 7, 56, 2, 2, 264, 266, 5,
	14, 8, 2, 265, 267, 5, 32, 17, 2, 266, 265, 3, 2, 2, 2, 267, 268, 3, 2,
	2, 2, 268, 266, 3, 2, 2, 2, 268, 269, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2,
	270, 271, 7, 5, 2, 2, 271, 273, 3, 2, 2, 2, 272, 261, 3, 2, 2, 2, 272,
	262, 3, 2, 2, 2, 273, 35, 3, 2, 2, 2, 274, 285, 5, 28, 15, 2, 275, 285,
	5, 14, 8, 2, 276, 280, 7, 4, 2, 2, 277, 279, 5, 30, 16, 2, 278, 277, 3,
	2, 2, 2, 279, 282, 3, 2, 2, 2, 280, 278, 3, 2, 2, 2, 280, 281, 3, 2, 2,
	2, 281, 283, 3, 2, 2, 2, 282, 280, 3, 2, 2, 2, 283, 285, 7, 5, 2, 2, 284,
	274, 3, 2, 2, 2, 284, 275, 3, 2, 2, 2, 284, 276, 3, 2, 2, 2, 285, 37, 3,
	2, 2, 2, 286, 291, 5, 26, 14, 2, 287, 288, 5, 26, 14, 2, 288, 289, 5, 36,
	19, 2, 289, 291, 3, 2, 2, 2, 290, 286, 3, 2, 2, 2, 290, 287, 3, 2, 2, 2,
	291, 39, 3, 2, 2, 2, 292, 303, 5, 34, 18, 2, 293, 294, 7, 4, 2, 2, 294,
	296, 5, 34, 18, 2, 295, 297, 5, 40, 21, 2, 296, 295, 3, 2, 2, 2, 297, 298,
	3, 2, 2, 2, 298, 296, 3, 2, 2, 2, 298, 299, 3, 2, 2, 2, 299, 300, 3, 2,
	2, 2, 300, 301, 7, 5, 2, 2, 301, 303, 3, 2, 2, 2, 302, 292, 3, 2, 2, 2,
	302, 293, 3, 2, 2, 2, 303, 41, 3, 2, 2, 2, 304, 312, 5, 34, 18, 2, 305,
	306, 7, 4, 2, 2, 306, 307, 7, 57, 2, 2, 307, 308, 5, 34, 18, 2, 308, 309,
	5, 40, 21, 2, 309, 310, 7, 5, 2, 2, 310, 312, 3, 2, 2, 2, 311, 304, 3,
	2, 2, 2, 311, 305, 3, 2, 2, 2, 312, 43, 3, 2, 2, 2, 313, 314, 7, 4, 2,
	2, 314, 315, 5, 14, 8, 2, 315, 316, 5, 52, 27, 2, 316, 317, 7, 5, 2, 2,
	317, 45, 3, 2, 2, 2, 318, 319, 7, 4, 2, 2, 319, 320, 5, 14, 8, 2, 320,
	321, 5, 40, 21, 2, 321, 322, 7, 5, 2, 2, 322, 47, 3, 2, 2, 2, 323, 334,
	5, 14, 8, 2, 324, 325, 7, 4, 2, 2, 325, 327, 5, 14, 8, 2, 326, 328, 5,
	14, 8, 2, 327, 326, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 327, 3, 2, 2,
	2, 329, 330, 3, 2, 2, 2, 330, 331, 3, 2, 2, 2, 331, 332, 7, 5, 2, 2, 332,
	334, 3, 2, 2, 2, 333, 323, 3, 2, 2, 2, 333, 324, 3, 2, 2, 2, 334, 49, 3,
	2, 2, 2, 335, 336, 7, 4, 2, 2, 336, 337, 5, 48, 25, 2, 337, 338, 5, 52,
	27, 2, 338, 339, 7, 5, 2, 2, 339, 51, 3, 2, 2, 2, 340, 410, 5, 28, 15,
	2, 341, 410, 5, 42, 22, 2, 342, 343, 7, 4, 2, 2, 343, 345, 5, 42, 22, 2,
	344, 346, 5, 52, 27, 2, 345, 344, 3, 2, 2, 2, 346, 347, 3, 2, 2, 2, 347,
	345, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 350,
	7, 5, 2, 2, 350, 410, 3, 2, 2, 2, 351, 352, 7, 4, 2, 2, 352, 353, 7, 63,
	2, 2, 353, 355, 7, 4, 2, 2, 354, 356, 5, 44, 23, 2, 355, 354, 3, 2, 2,
	2, 356, 357, 3, 2, 2, 2, 357, 355, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358,
	359, 3, 2, 2, 2, 359, 360, 7, 5, 2, 2, 360, 361, 5, 52, 27, 2, 361, 362,
	7, 5, 2, 2, 362, 410, 3, 2, 2, 2, 363, 364, 7, 4, 2, 2, 364, 365, 7, 62,
	2, 2, 365, 367, 7, 4, 2, 2, 366, 368, 5, 46, 24, 2, 367, 366, 3, 2, 2,
	2, 368, 369, 3, 2, 2, 2, 369, 367, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370,
	371, 3, 2, 2, 2, 371, 372, 7, 5, 2, 2, 372, 373, 5, 52, 27, 2, 373, 374,
	7, 5, 2, 2, 374, 410, 3, 2, 2, 2, 375, 376, 7, 4, 2, 2, 376, 377, 7, 60,
	2, 2, 377, 379, 7, 4, 2, 2, 378, 380, 5, 46, 24, 2, 379, 378, 3, 2, 2,
	2, 380, 381, 3, 2, 2, 2, 381, 379, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382,
	383, 3, 2, 2, 2, 383, 384, 7, 5, 2, 2, 384, 385, 5, 52, 27, 2, 385, 386,
	7, 5, 2, 2, 386, 410, 3, 2, 2, 2, 387, 388, 7, 4, 2, 2, 388, 389, 7, 64,
	2, 2, 389, 390, 5, 52, 27, 2, 390, 392, 7, 4, 2, 2, 391, 393, 5, 50, 26,
	2, 392, 391, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2, 394, 392, 3, 2, 2, 2, 394,
	395, 3, 2, 2, 2, 395, 396, 3, 2, 2, 2, 396, 397, 7, 5, 2, 2, 397, 398,
	7, 5, 2, 2, 398, 410, 3, 2, 2, 2, 399, 400, 7, 4, 2, 2, 400, 401, 7, 55,
	2, 2, 401, 403, 5, 52, 27, 2, 402, 404, 5, 38, 20, 2, 403, 402, 3, 2, 2,
	2, 404, 405, 3, 2, 2, 2, 405, 403, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406,
	407, 3, 2, 2, 2, 407, 408, 7, 5, 2, 2, 408, 410, 3, 2, 2, 2, 409, 340,
	3, 2, 2, 2, 409, 341, 3, 2, 2, 2, 409, 342, 3, 2, 2, 2, 409, 351, 3, 2,
	2, 2, 409, 363, 3, 2, 2, 2, 409, 375, 3, 2, 2, 2, 409, 387, 3, 2, 2, 2,
	409, 399, 3, 2, 2, 2, 410, 53, 3, 2, 2, 2, 411, 412, 7, 4, 2, 2, 412, 413,
	5, 34, 18, 2, 413, 417, 5, 16, 9, 2, 414, 416, 5, 38, 20, 2, 415, 414,
	3, 2, 2, 2, 416, 419, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 417, 418, 3, 2,
	2, 2, 418, 420, 3, 2, 2, 2, 419, 417, 3, 2, 2, 2, 420, 421, 7, 5, 2, 2,
	421, 55, 3, 2, 2, 2, 422, 423, 9, 5, 2, 2, 423, 57, 3, 2, 2, 2, 424, 425,
	7, 4, 2, 2, 425, 426, 5, 28, 15, 2, 426, 430, 5, 40, 21, 2, 427, 429, 5,
	38, 20, 2, 428, 427, 3, 2, 2, 2, 429, 432, 3, 2, 2, 2, 430, 428, 3, 2,
	2, 2, 430, 431, 3, 2, 2, 2, 431, 433, 3, 2, 2, 2, 432, 430, 3, 2, 2, 2,
	433, 434, 7, 5, 2, 2, 434, 462, 3, 2, 2, 2, 435, 436, 7, 4, 2, 2, 436,
	437, 5, 56, 29, 2, 437, 441, 5, 40, 21, 2, 438, 440, 5, 38, 20, 2, 439,
	438, 3, 2, 2, 2, 440, 443, 3, 2, 2, 2, 441, 439, 3, 2, 2, 2, 441, 442,
	3, 2, 2, 2, 442, 444, 3, 2, 2, 2, 443, 441, 3, 2, 2, 2, 444, 445, 7, 5,
	2, 2, 445, 462, 3, 2, 2, 2, 446, 447, 7, 4, 2, 2, 447, 449, 5, 34, 18,
	2, 448, 450, 5, 40, 21, 2, 449, 448, 3, 2, 2, 2, 450, 451, 3, 2, 2, 2,
	451, 449, 3, 2, 2, 2, 451, 452, 3, 2, 2, 2, 452, 456, 3, 2, 2, 2, 453,
	455, 5, 38, 20, 2, 454, 453, 3, 2, 2, 2, 455, 458, 3, 2, 2, 2, 456, 454,
	3, 2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 459, 3, 2, 2, 2, 458, 456, 3, 2,
	2, 2, 459, 460, 7, 5, 2, 2, 460, 462, 3, 2, 2, 2, 461, 424, 3, 2, 2, 2,
	461, 435, 3, 2, 2, 2, 461, 446, 3, 2, 2, 2, 462, 59, 3, 2, 2, 2, 463, 490,
	5, 58, 30, 2, 464, 465, 7, 4, 2, 2, 465, 466, 7, 66, 2, 2, 466, 468, 7,
	4, 2, 2, 467, 469, 5, 14, 8, 2, 468, 467, 3, 2, 2, 2, 469, 470, 3, 2, 2,
	2, 470, 468, 3, 2, 2, 2, 470, 471, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 472,
	473, 7, 5, 2, 2, 473, 474, 7, 4, 2, 2, 474, 476, 5, 34, 18, 2, 475, 477,
	5, 40, 21, 2, 476, 475, 3, 2, 2, 2, 477, 478, 3, 2, 2, 2, 478, 476, 3,
	2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 483, 3, 2, 2, 2, 480, 482, 5, 38, 20,
	2, 481, 480, 3, 2, 2, 2, 482, 485, 3, 2, 2, 2, 483, 481, 3, 2, 2, 2, 483,
	484, 3, 2, 2, 2, 484, 486, 3, 2, 2, 2, 485, 483, 3, 2, 2, 2, 486, 487,
	7, 5, 2, 2, 487, 488, 7, 5, 2, 2, 488, 490, 3, 2, 2, 2, 489, 463, 3, 2,
	2, 2, 489, 464, 3, 2, 2, 2, 490, 61, 3, 2, 2, 2, 491, 492, 7, 106, 2, 2,
	492, 494, 7, 4, 2, 2, 493, 495, 5, 54, 28, 2, 494, 493, 3, 2, 2, 2, 495,
	496, 3, 2, 2, 2, 496, 494, 3, 2, 2, 2, 496, 497, 3, 2, 2, 2, 497, 498,
	3, 2, 2, 2, 498, 499, 7, 5, 2, 2, 499, 521, 3, 2, 2, 2, 500, 501, 7, 82,
	2, 2, 501, 503, 7, 4, 2, 2, 502, 504, 5, 60, 31, 2, 503, 502, 3, 2, 2,
	2, 504, 505, 3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 505, 506, 3, 2, 2, 2, 506,
	507, 3, 2, 2, 2, 507, 508, 7, 5, 2, 2, 508, 521, 3, 2, 2, 2, 509, 510,
	7, 107, 2, 2, 510, 521, 5, 24, 13, 2, 511, 512, 7, 83, 2, 2, 512, 521,
	5, 24, 13, 2, 513, 514, 7, 78, 2, 2, 514, 521, 5, 24, 13, 2, 515, 516,
	7, 111, 2, 2, 516, 521, 5, 24, 13, 2, 517, 518, 7, 91, 2, 2, 518, 521,
	5, 24, 13, 2, 519, 521, 5, 38, 20, 2, 520, 491, 3, 2, 2, 2, 520, 500, 3,
	2, 2, 2, 520, 509, 3, 2, 2, 2, 520, 511, 3, 2, 2, 2, 520, 513, 3, 2, 2,
	2, 520, 515, 3, 2, 2, 2, 520, 517, 3, 2, 2, 2, 520, 519, 3, 2, 2, 2, 521,
	63, 3, 2, 2, 2, 522, 523, 7, 4, 2, 2, 523, 524, 7, 20, 2, 2, 524, 526,
	5, 14, 8, 2, 525, 527, 5, 62, 32, 2, 526, 525, 3, 2, 2, 2, 527, 528, 3,
	2, 2, 2, 528, 526, 3, 2, 2, 2, 528, 529, 3, 2, 2, 2, 529, 530, 3, 2, 2,
	2, 530, 531, 7, 5, 2, 2, 531, 65, 3, 2, 2, 2, 532, 533, 7, 110, 2, 2, 533,
	535, 7, 4, 2, 2, 534, 536, 5, 14, 8, 2, 535, 534, 3, 2, 2, 2, 536, 537,
	3, 2, 2, 2, 537, 535, 3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 539, 3, 2,
	2, 2, 539, 540, 7, 5, 2, 2, 540, 551, 3, 2, 2, 2, 541, 542, 7, 86, 2, 2,
	542, 551, 5, 24, 13, 2, 543, 544, 7, 81, 2, 2, 544, 551, 5, 24, 13, 2,
	545, 546, 7, 111, 2, 2, 546, 551, 5, 24, 13, 2, 547, 548, 7, 91, 2, 2,
	548, 551, 5, 24, 13, 2, 549, 551, 5, 38, 20, 2, 550, 532, 3, 2, 2, 2, 550,
	541, 3, 2, 2, 2, 550, 543, 3, 2, 2, 2, 550, 545, 3, 2, 2, 2, 550, 547,
	3, 2, 2, 2, 550, 549, 3, 2, 2, 2, 551, 67, 3, 2, 2, 2, 552, 553, 7, 4,
	2, 2, 553, 554, 7, 16, 2, 2, 554, 556, 5, 14, 8, 2, 555, 557, 5, 66, 34,
	2, 556, 555, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 556, 3, 2, 2, 2, 558,
	559, 3, 2, 2, 2, 559, 560, 3, 2, 2, 2, 560, 561, 7, 5, 2, 2, 561, 69, 3,
	2, 2, 2, 562, 563, 7, 4, 2, 2, 563, 564, 5, 14, 8, 2, 564, 565, 5, 16,
	9, 2, 565, 566, 7, 5, 2, 2, 566, 71, 3, 2, 2, 2, 567, 568, 7, 4, 2, 2,
	568, 569, 5, 14, 8, 2, 569, 570, 5, 40, 21, 2, 570, 571, 7, 5, 2, 2, 571,
	73, 3, 2, 2, 2, 572, 573, 7, 4, 2, 2, 573, 577, 5, 14, 8, 2, 574, 576,
	5, 72, 37, 2, 575, 574, 3, 2, 2, 2, 576, 579, 3, 2, 2, 2, 577, 575, 3,
	2, 2, 2, 577, 578, 3, 2, 2, 2, 578, 580, 3, 2, 2, 2, 579, 577, 3, 2, 2,
	2, 580, 581, 7, 5, 2, 2, 581, 75, 3, 2, 2, 2, 582, 584, 7, 4, 2, 2, 583,
	585, 5, 74, 38, 2, 584, 583, 3, 2, 2, 2, 585, 586, 3, 2, 2, 2, 586, 584,
	3, 2, 2, 2, 586, 587, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 589, 7, 5,
	2, 2, 589, 609, 3, 2, 2, 2, 590, 591, 7, 4, 2, 2, 591, 592, 7, 66, 2, 2,
	592, 594, 7, 4, 2, 2, 593, 595, 5, 14, 8, 2, 594, 593, 3, 2, 2, 2, 595,
	596, 3, 2, 2, 2, 596, 594, 3, 2, 2, 2, 596, 597, 3, 2, 2, 2, 597, 598,
	3, 2, 2, 2, 598, 599, 7, 5, 2, 2, 599, 601, 7, 4, 2, 2, 600, 602, 5, 74,
	38, 2, 601, 600, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 601, 3, 2, 2, 2,
	603, 604, 3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 606, 7, 5, 2, 2, 606,
	607, 7, 5, 2, 2, 607, 609, 3, 2, 2, 2, 608, 582, 3, 2, 2, 2, 608, 590,
	3, 2, 2, 2, 609, 77, 3, 2, 2, 2, 610, 611, 7, 4, 2, 2, 611, 612, 5, 14,
	8, 2, 612, 616, 7, 4, 2, 2, 613, 615, 5, 46, 24, 2, 614, 613, 3, 2, 2,
	2, 615, 618, 3, 2, 2, 2, 616, 614, 3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617,
	619, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2, 619, 620, 7, 5, 2, 2, 620, 621,
	5, 40, 21, 2, 621, 622, 7, 5, 2, 2, 622, 79, 3, 2, 2, 2, 623, 624, 5, 14,
	8, 2, 624, 628, 7, 4, 2, 2, 625, 627, 5, 46, 24, 2, 626, 625, 3, 2, 2,
	2, 627, 630, 3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629,
	631, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 631, 632, 7, 5, 2, 2, 632, 633,
	5, 40, 21, 2, 633, 634, 5, 52, 27, 2, 634, 81, 3, 2, 2, 2, 635, 642, 5,
	14, 8, 2, 636, 637, 7, 4, 2, 2, 637, 638, 7, 9, 2, 2, 638, 639, 5, 14,
	8, 2, 639, 640, 7, 5, 2, 2, 640, 642, 3, 2, 2, 2, 641, 635, 3, 2, 2, 2,
	641, 636, 3, 2, 2, 2, 642, 83, 3, 2, 2, 2, 643, 645, 5, 146, 74, 2, 644,
	643, 3, 2, 2, 2, 645, 648, 3, 2, 2, 2, 646, 644, 3, 2, 2, 2, 646, 647,
	3, 2, 2, 2, 647, 85, 3, 2, 2, 2, 648, 646, 3, 2, 2, 2, 649, 650, 7, 25,
	2, 2, 650, 651, 5, 52, 27, 2, 651, 87, 3, 2, 2, 2, 652, 653, 7, 26, 2,
	2, 653, 89, 3, 2, 2, 2, 654, 655, 7, 27, 2, 2, 655, 659, 7, 4, 2, 2, 656,
	658, 5, 82, 42, 2, 657, 656, 3, 2, 2, 2, 658, 661, 3, 2, 2, 2, 659, 657,
	3, 2, 2, 2, 659, 660, 3, 2, 2, 2, 660, 662, 3, 2, 2, 2, 661, 659, 3, 2,
	2, 2, 662, 663, 7, 5, 2, 2, 663, 91, 3, 2, 2, 2, 664, 665, 7, 28, 2, 2,
	665, 666, 5, 14, 8, 2, 666, 667, 5, 40, 21, 2, 667, 93, 3, 2, 2, 2, 668,
	669, 7, 29, 2, 2, 669, 670, 5, 14, 8, 2, 670, 671, 5, 76, 39, 2, 671, 95,
	3, 2, 2, 2, 672, 673, 7, 30, 2, 2, 673, 675, 7, 4, 2, 2, 674, 676, 5, 70,
	36, 2, 675, 674, 3, 2, 2, 2, 676, 677, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2,
	677, 678, 3, 2, 2, 2, 678, 679, 3, 2, 2, 2, 679, 680, 7, 5, 2, 2, 680,
	682, 7, 4, 2, 2, 681, 683, 5, 76, 39, 2, 682, 681, 3, 2, 2, 2, 683, 684,
	3, 2, 2, 2, 684, 682, 3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 686, 3, 2,
	2, 2, 686, 687, 7, 5, 2, 2, 687, 97, 3, 2, 2, 2, 688, 689, 7, 31, 2, 2,
	689, 690, 5, 14, 8, 2, 690, 694, 7, 4, 2, 2, 691, 693, 5, 40, 21, 2, 692,
	691, 3, 2, 2, 2, 693, 696, 3, 2, 2, 2, 694, 692, 3, 2, 2, 2, 694, 695,
	3, 2, 2, 2, 695, 697, 3, 2, 2, 2, 696, 694, 3, 2, 2, 2, 697, 698, 7, 5,
	2, 2, 698, 699, 5, 40, 21, 2, 699, 99, 3, 2, 2, 2, 700, 701, 7, 32, 2,
	2, 701, 702, 5, 14, 8, 2, 702, 703, 5, 16, 9, 2, 703, 101, 3, 2, 2, 2,
	704, 705, 7, 33, 2, 2, 705, 706, 5, 80, 41, 2, 706, 103, 3, 2, 2, 2, 707,
	708, 7, 34, 2, 2, 708, 709, 5, 80, 41, 2, 709, 105, 3, 2, 2, 2, 710, 711,
	7, 35, 2, 2, 711, 713, 7, 4, 2, 2, 712, 714, 5, 78, 40, 2, 713, 712, 3,
	2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 713, 3, 2, 2, 2, 715, 716, 3, 2, 2,
	2, 716, 717, 3, 2, 2, 2, 717, 718, 7, 5, 2, 2, 718, 720, 7, 4, 2, 2, 719,
	721, 5, 52, 27, 2, 720, 719, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 720,
	3, 2, 2, 2, 722, 723, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2, 724, 725, 7, 5,
	2, 2, 725, 107, 3, 2, 2, 2, 726, 727, 7, 36, 2, 2, 727, 728, 5, 14, 8,
	2, 728, 732, 7, 4, 2, 2, 729, 731, 5, 14, 8, 2, 730, 729, 3, 2, 2, 2, 731,
	734, 3, 2, 2, 2, 732, 730, 3, 2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 735,
	3, 2, 2, 2, 734, 732, 3, 2, 2, 2, 735, 736, 7, 5, 2, 2, 736, 737, 5, 40,
	21, 2, 737, 109, 3, 2, 2, 2, 738, 739, 7, 37, 2, 2, 739, 740, 5, 24, 13,
	2, 740, 111, 3, 2, 2, 2, 741, 742, 7, 38, 2, 2, 742, 113, 3, 2, 2, 2, 743,
	744, 7, 39, 2, 2, 744, 115, 3, 2, 2, 2, 745, 746, 7, 40, 2, 2, 746, 117,
	3, 2, 2, 2, 747, 748, 7, 41, 2, 2, 748, 749, 5, 152, 77, 2, 749, 119, 3,
	2, 2, 2, 750, 751, 7, 42, 2, 2, 751, 121, 3, 2, 2, 2, 752, 753, 7, 43,
	2, 2, 753, 754, 5, 26, 14, 2, 754, 123, 3, 2, 2, 2, 755, 756, 7, 44, 2,
	2, 756, 125, 3, 2, 2, 2, 757, 758, 7, 45, 2, 2, 758, 127, 3, 2, 2, 2, 759,
	760, 7, 46, 2, 2, 760, 129, 3, 2, 2, 2, 761, 762, 7, 47, 2, 2, 762, 764,
	7, 4, 2, 2, 763, 765, 5, 52, 27, 2, 764, 763, 3, 2, 2, 2, 765, 766, 3,
	2, 2, 2, 766, 764, 3, 2, 2, 2, 766, 767, 3, 2, 2, 2, 767, 768, 3, 2, 2,
	2, 768, 769, 7, 5, 2, 2, 769, 131, 3, 2, 2, 2, 770, 771, 7, 48, 2, 2, 771,
	772, 5, 16, 9, 2, 772, 133, 3, 2, 2, 2, 773, 774, 7, 49, 2, 2, 774, 775,
	5, 16, 9, 2, 775, 135, 3, 2, 2, 2, 776, 777, 7, 50, 2, 2, 777, 137, 3,
	2, 2, 2, 778, 779, 7, 51, 2, 2, 779, 139, 3, 2, 2, 2, 780, 781, 7, 52,
	2, 2, 781, 782, 5, 38, 20, 2, 782, 141, 3, 2, 2, 2, 783, 784, 7, 53, 2,
	2, 784, 785, 5, 14, 8, 2, 785, 143, 3, 2, 2, 2, 786, 787, 7, 54, 2, 2,
	787, 788, 5, 150, 76, 2, 788, 145, 3, 2, 2, 2, 789, 790, 7, 4, 2, 2, 790,
	791, 5, 86, 44, 2, 791, 792, 7, 5, 2, 2, 792, 910, 3, 2, 2, 2, 793, 794,
	7, 4, 2, 2, 794, 795, 5, 88, 45, 2, 795, 796, 7, 5, 2, 2, 796, 910, 3,
	2, 2, 2, 797, 798, 7, 4, 2, 2, 798, 799, 5, 90, 46, 2, 799, 800, 7, 5,
	2, 2, 800, 910, 3, 2, 2, 2, 801, 802, 7, 4, 2, 2, 802, 803, 5, 92, 47,
	2, 803, 804, 7, 5, 2, 2, 804, 910, 3, 2, 2, 2, 805, 806, 7, 4, 2, 2, 806,
	807, 5, 94, 48, 2, 807, 808, 7, 5, 2, 2, 808, 910, 3, 2, 2, 2, 809, 810,
	7, 4, 2, 2, 810, 811, 5, 96, 49, 2, 811, 812, 7, 5, 2, 2, 812, 910, 3,
	2, 2, 2, 813, 814, 7, 4, 2, 2, 814, 815, 5, 98, 50, 2, 815, 816, 7, 5,
	2, 2, 816, 910, 3, 2, 2, 2, 817, 818, 7, 4, 2, 2, 818, 819, 5, 100, 51,
	2, 819, 820, 7, 5, 2, 2, 820, 910, 3, 2, 2, 2, 821, 822, 7, 4, 2, 2, 822,
	823, 5, 102, 52, 2, 823, 824, 7, 5, 2, 2, 824, 910, 3, 2, 2, 2, 825, 826,
	7, 4, 2, 2, 826, 827, 5, 104, 53, 2, 827, 828, 7, 5, 2, 2, 828, 910, 3,
	2, 2, 2, 829, 830, 7, 4, 2, 2, 830, 831, 5, 106, 54, 2, 831, 832, 7, 5,
	2, 2, 832, 910, 3, 2, 2, 2, 833, 834, 7, 4, 2, 2, 834, 835, 5, 108, 55,
	2, 835, 836, 7, 5, 2, 2, 836, 910, 3, 2, 2, 2, 837, 838, 7, 4, 2, 2, 838,
	839, 5, 110, 56, 2, 839, 840, 7, 5, 2, 2, 840, 910, 3, 2, 2, 2, 841, 842,
	7, 4, 2, 2, 842, 843, 5, 112, 57, 2, 843, 844, 7, 5, 2, 2, 844, 910, 3,
	2, 2, 2, 845, 846, 7, 4, 2, 2, 846, 847, 5, 114, 58, 2, 847, 848, 7, 5,
	2, 2, 848, 910, 3, 2, 2, 2, 849, 850, 7, 4, 2, 2, 850, 851, 5, 116, 59,
	2, 851, 852, 7, 5, 2, 2, 852, 910, 3, 2, 2, 2, 853, 854, 7, 4, 2, 2, 854,
	855, 5, 118, 60, 2, 855, 856, 7, 5, 2, 2, 856, 910, 3, 2, 2, 2, 857, 858,
	7, 4, 2, 2, 858, 859, 5, 120, 61, 2, 859, 860, 7, 5, 2, 2, 860, 910, 3,
	2, 2, 2, 861, 862, 7, 4, 2, 2, 862, 863, 5, 122, 62, 2, 863, 864, 7, 5,
	2, 2, 864, 910, 3, 2, 2, 2, 865, 866, 7, 4, 2, 2, 866, 867, 5, 124, 63,
	2, 867, 868, 7, 5, 2, 2, 868, 910, 3, 2, 2, 2, 869, 870, 7, 4, 2, 2, 870,
	871, 5, 126, 64, 2, 871, 872, 7, 5, 2, 2, 872, 910, 3, 2, 2, 2, 873, 874,
	7, 4, 2, 2, 874, 875, 5, 128, 65, 2, 875, 876, 7, 5, 2, 2, 876, 910, 3,
	2, 2, 2, 877, 878, 7, 4, 2, 2, 878, 879, 5, 130, 66, 2, 879, 880, 7, 5,
	2, 2, 880, 910, 3, 2, 2, 2, 881, 882, 7, 4, 2, 2, 882, 883, 5, 132, 67,
	2, 883, 884, 7, 5, 2, 2, 884, 910, 3, 2, 2, 2, 885, 886, 7, 4, 2, 2, 886,
	887, 5, 134, 68, 2, 887, 888, 7, 5, 2, 2, 888, 910, 3, 2, 2, 2, 889, 890,
	7, 4, 2, 2, 890, 891, 5, 136, 69, 2, 891, 892, 7, 5, 2, 2, 892, 910, 3,
	2, 2, 2, 893, 894, 7, 4, 2, 2, 894, 895, 5, 138, 70, 2, 895, 896, 7, 5,
	2, 2, 896, 910, 3, 2, 2, 2, 897, 898, 7, 4, 2, 2, 898, 899, 5, 140, 71,
	2, 899, 900, 7, 5, 2, 2, 900, 910, 3, 2, 2, 2, 901, 902, 7, 4, 2, 2, 902,
	903, 5, 142, 72, 2, 903, 904, 7, 5, 2, 2, 904, 910, 3, 2, 2, 2, 905, 906,
	7, 4, 2, 2, 906, 907, 5, 144, 73, 2, 907, 908, 7, 5, 2, 2, 908, 910, 3,
	2, 2, 2, 909, 789, 3, 2, 2, 2, 909, 793, 3, 2, 2, 2, 909, 797, 3, 2, 2,
	2, 909, 801, 3, 2, 2, 2, 909, 805, 3, 2, 2, 2, 909, 809, 3, 2, 2, 2, 909,
	813, 3, 2, 2, 2, 909, 817, 3, 2, 2, 2, 909, 821, 3, 2, 2, 2, 909, 825,
	3, 2, 2, 2, 909, 829, 3, 2, 2, 2, 909, 833, 3, 2, 2, 2, 909, 837, 3, 2,
	2, 2, 909, 841, 3, 2, 2, 2, 909, 845, 3, 2, 2, 2, 909, 849, 3, 2, 2, 2,
	909, 853, 3, 2, 2, 2, 909, 857, 3, 2, 2, 2, 909, 861, 3, 2, 2, 2, 909,
	865, 3, 2, 2, 2, 909, 869, 3, 2, 2, 2, 909, 873, 3, 2, 2, 2, 909, 877,
	3, 2, 2, 2, 909, 881, 3, 2, 2, 2, 909, 885, 3, 2, 2, 2, 909, 889, 3, 2,
	2, 2, 909, 893, 3, 2, 2, 2, 909, 897, 3, 2, 2, 2, 909, 901, 3, 2, 2, 2,
	909, 905, 3, 2, 2, 2, 910, 147, 3, 2, 2, 2, 911, 912, 9, 6, 2, 2, 912,
	149, 3, 2, 2, 2, 913, 914, 7, 79, 2, 2, 914, 943, 5, 24, 13, 2, 915, 916,
	7, 84, 2, 2, 916, 943, 5, 148, 75, 2, 917, 918, 7, 85, 2, 2, 918, 943,
	5, 148, 75, 2, 919, 920, 7, 93, 2, 2, 920, 943, 5, 148, 75, 2, 921, 922,
	7, 94, 2, 2, 922, 943, 5, 148, 75, 2, 923, 924, 7, 95, 2, 2, 924, 943,
	5, 148, 75, 2, 925, 926, 7, 96, 2, 2, 926, 943, 5, 148, 75, 2, 927, 928,
	7, 97, 2, 2, 928, 943, 5, 148, 75, 2, 929, 930, 7, 98, 2, 2, 930, 943,
	5, 148, 75, 2, 931, 932, 7, 99, 2, 2, 932, 943, 5, 148, 75, 2, 933, 934,
	7, 100, 2, 2, 934, 943, 5, 16, 9, 2, 935, 936, 7, 102, 2, 2, 936, 943,
	5, 24, 13, 2, 937, 938, 7, 103, 2, 2, 938, 943, 5, 16, 9, 2, 939, 940,
	7, 112, 2, 2, 940, 943, 5, 16, 9, 2, 941, 943, 5, 38, 20, 2, 942, 913,
	3, 2, 2, 2, 942, 915, 3, 2, 2, 2, 942, 917, 3, 2, 2, 2, 942, 919, 3, 2,
	2, 2, 942, 921, 3, 2, 2, 2, 942, 923, 3, 2, 2, 2, 942, 925, 3, 2, 2, 2,
	942, 927, 3, 2, 2, 2, 942, 929, 3, 2, 2, 2, 942, 931, 3, 2, 2, 2, 942,
	933, 3, 2, 2, 2, 942, 935, 3, 2, 2, 2, 942, 937, 3, 2, 2, 2, 942, 939,
	3, 2, 2, 2, 942, 941, 3, 2, 2, 2, 943, 151, 3, 2, 2, 2, 944, 953, 7, 73,
	2, 2, 945, 953, 7, 74, 2, 2, 946, 953, 7, 75, 2, 2, 947, 953, 7, 80, 2,
	2, 948, 953, 7, 90, 2, 2, 949, 953, 7, 101, 2, 2, 950, 953, 7, 113, 2,
	2, 951, 953, 5, 26, 14, 2, 952, 944, 3, 2, 2, 2, 952, 945, 3, 2, 2, 2,
	952, 946, 3, 2, 2, 2, 952, 947, 3, 2, 2, 2, 952, 948, 3, 2, 2, 2, 952,
	949, 3, 2, 2, 2, 952, 950, 3, 2, 2, 2, 952, 951, 3, 2, 2, 2, 953, 153,
	3, 2, 2, 2, 954, 955, 9, 7, 2, 2, 955, 155, 3, 2, 2, 2, 956, 960, 7, 17,
	2, 2, 957, 960, 7, 15, 2, 2, 958, 960, 5, 30, 16, 2, 959, 956, 3, 2, 2,
	2, 959, 957, 3, 2, 2, 2, 959, 958, 3, 2, 2, 2, 960, 157, 3, 2, 2, 2, 961,
	962, 7, 4, 2, 2, 962, 963, 5, 102, 52, 2, 963, 964, 7, 5, 2, 2, 964, 974,
	3, 2, 2, 2, 965, 966, 7, 4, 2, 2, 966, 967, 5, 104, 53, 2, 967, 968, 7,
	5, 2, 2, 968, 974, 3, 2, 2, 2, 969, 970, 7, 4, 2, 2, 970, 971, 5, 106,
	54, 2, 971, 972, 7, 5, 2, 2, 972, 974, 3, 2, 2, 2, 973, 961, 3, 2, 2, 2,
	973, 965, 3, 2, 2, 2, 973, 969, 3, 2, 2, 2, 974, 159, 3, 2, 2, 2, 975,
	976, 7, 74, 2, 2, 976, 989, 5, 16, 9, 2, 977, 978, 7, 75, 2, 2, 978, 989,
	5, 24, 13, 2, 979, 980, 7, 80, 2, 2, 980, 989, 5, 154, 78, 2, 981, 982,
	7, 90, 2, 2, 982, 989, 5, 24, 13, 2, 983, 984, 7, 101, 2, 2, 984, 989,
	5, 156, 79, 2, 985, 986, 7, 113, 2, 2, 986, 989, 5, 24, 13, 2, 987, 989,
	5, 38, 20, 2, 988, 975, 3, 2, 2, 2, 988, 977, 3, 2, 2, 2, 988, 979, 3,
	2, 2, 2, 988, 981, 3, 2, 2, 2, 988, 983, 3, 2, 2, 2, 988, 985, 3, 2, 2,
	2, 988, 987, 3, 2, 2, 2, 989, 161, 3, 2, 2, 2, 990, 991, 7, 4, 2, 2, 991,
	992, 5, 52, 27, 2, 992, 993, 5, 52, 27, 2, 993, 994, 7, 5, 2, 2, 994, 163,
	3, 2, 2, 2, 995, 996, 7, 4, 2, 2, 996, 997, 5, 14, 8, 2, 997, 998, 5, 148,
	75, 2, 998, 999, 7, 5, 2, 2, 999, 165, 3, 2, 2, 2, 1000, 1001, 9, 8, 2,
	2, 1001, 167, 3, 2, 2, 2, 1002, 1003, 5, 24, 13, 2, 1003, 169, 3, 2, 2,
	2, 1004, 1008, 7, 4, 2, 2, 1005, 1007, 5, 52, 27, 2, 1006, 1005, 3, 2,
	2, 2, 1007, 1010, 3, 2, 2, 2, 1008, 1006, 3, 2, 2, 2, 1008, 1009, 3, 2,
	2, 2, 1009, 1011, 3, 2, 2, 2, 1010, 1008, 3, 2, 2, 2, 1011, 1012, 7, 5,
	2, 2, 1012, 171, 3, 2, 2, 2, 1013, 1017, 7, 4, 2, 2, 1014, 1016, 5, 164,
	83, 2, 1015, 1014, 3, 2, 2, 2, 1016, 1019, 3, 2, 2, 2, 1017, 1015, 3, 2,
	2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 1020, 3, 2, 2, 2, 1019, 1017, 3, 2,
	2, 2, 1020, 1021, 7, 5, 2, 2, 1021, 173, 3, 2, 2, 2, 1022, 1024, 7, 4,
	2, 2, 1023, 1025, 5, 160, 81, 2, 1024, 1023, 3, 2, 2, 2, 1025, 1026, 3,
	2, 2, 2, 1026, 1024, 3, 2, 2, 2, 1026, 1027, 3, 2, 2, 2, 1027, 1028, 3,
	2, 2, 2, 1028, 1029, 7, 5, 2, 2, 1029, 175, 3, 2, 2, 2, 1030, 1031, 7,
	4, 2, 2, 1031, 1035, 7, 114, 2, 2, 1032, 1034, 5, 158, 80, 2, 1033, 1032,
	3, 2, 2, 2, 1034, 1037, 3, 2, 2, 2, 1035, 1033, 3, 2, 2, 2, 1035, 1036,
	3, 2, 2, 2, 1036, 1038, 3, 2, 2, 2, 1037, 1035, 3, 2, 2, 2, 1038, 1048,
	7, 5, 2, 2, 1039, 1043, 7, 4, 2, 2, 1040, 1042, 5, 158, 80, 2, 1041, 1040,
	3, 2, 2, 2, 1042, 1045, 3, 2, 2, 2, 1043, 1041, 3, 2, 2, 2, 1043, 1044,
	3, 2, 2, 2, 1044, 1046, 3, 2, 2, 2, 1045, 1043, 3, 2, 2, 2, 1046, 1048,
	7, 5, 2, 2, 1047, 1030, 3, 2, 2, 2, 1047, 1039, 3, 2, 2, 2, 1048, 177,
	3, 2, 2, 2, 1049, 1050, 5, 36, 19, 2, 1050, 179, 3, 2, 2, 2, 1051, 1052,
	5, 30, 16, 2, 1052, 181, 3, 2, 2, 2, 1053, 1057, 7, 4, 2, 2, 1054, 1056,
	5, 14, 8, 2, 1055, 1054, 3, 2, 2, 2, 1056, 1059, 3, 2, 2, 2, 1057, 1055,
	3, 2, 2, 2, 1057, 1058, 3, 2, 2, 2, 1058, 1060, 3, 2, 2, 2, 1059, 1057,
	3, 2, 2, 2, 1060, 1061, 7, 5, 2, 2, 1061, 183, 3, 2, 2, 2, 1062, 1066,
	7, 4, 2, 2, 1063, 1065, 5, 14, 8, 2, 1064, 1063, 3, 2, 2, 2, 1065, 1068,
	3, 2, 2, 2, 1066, 1064, 3, 2, 2, 2, 1066, 1067, 3, 2, 2, 2, 1067, 1069,
	3, 2, 2, 2, 1068, 1066, 3, 2, 2, 2, 1069, 1070, 7, 5, 2, 2, 1070, 185,
	3, 2, 2, 2, 1071, 1073, 7, 4, 2, 2, 1072, 1074, 5, 162, 82, 2, 1073, 1072,
	3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 1073, 3, 2, 2, 2, 1075, 1076,
	3, 2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1078, 7, 5, 2, 2, 1078, 187,
	3, 2, 2, 2, 1079, 1091, 5, 166, 84, 2, 1080, 1091, 5, 168, 85, 2, 1081,
	1091, 5, 170, 86, 2, 1082, 1091, 5, 172, 87, 2, 1083, 1091, 5, 174, 88,
	2, 1084, 1091, 5, 176, 89, 2, 1085, 1091, 5, 178, 90, 2, 1086, 1091, 5,
	180, 91, 2, 1087, 1091, 5, 182, 92, 2, 1088, 1091, 5, 184, 93, 2, 1089,
	1091, 5, 186, 94, 2, 1090, 1079, 3, 2, 2, 2, 1090, 1080, 3, 2, 2, 2, 1090,
	1081, 3, 2, 2, 2, 1090, 1082, 3, 2, 2, 2, 1090, 1083, 3, 2, 2, 2, 1090,
	1084, 3, 2, 2, 2, 1090, 1085, 3, 2, 2, 2, 1090, 1086, 3, 2, 2, 2, 1090,
	1087, 3, 2, 2, 2, 1090, 1088, 3, 2, 2, 2, 1090, 1089, 3, 2, 2, 2, 1091,
	189, 3, 2, 2, 2, 1092, 1101, 7, 19, 2, 2, 1093, 1101, 5, 188, 95, 2, 1094,
	1101, 7, 23, 2, 2, 1095, 1096, 7, 4, 2, 2, 1096, 1097, 7, 12, 2, 2, 1097,
	1098, 5, 24, 13, 2, 1098, 1099, 7, 5, 2, 2, 1099, 1101, 3, 2, 2, 2, 1100,
	1092, 3, 2, 2, 2, 1100, 1093, 3, 2, 2, 2, 1100, 1094, 3, 2, 2, 2, 1100,
	1095, 3, 2, 2, 2, 1101, 191, 3, 2, 2, 2, 78, 204, 210, 220, 235, 242, 251,
	255, 259, 268, 272, 280, 284, 290, 298, 302, 311, 329, 333, 347, 357, 369,
	381, 394, 405, 409, 417, 430, 441, 451, 456, 461, 470, 478, 483, 489, 496,
	505, 520, 528, 537, 550, 558, 577, 586, 596, 603, 608, 616, 628, 641, 646,
	659, 677, 684, 694, 715, 722, 732, 766, 909, 942, 952, 959, 973, 988, 1008,
	1017, 1026, 1035, 1043, 1047, 1057, 1066, 1075, 1090, 1100,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "'('", "')'", "';'", "", "", "'not'", "'Bool'", "'continued-execution'",
	"'error'", "'false'", "'immediate-exit'", "'incomplete'", "'logic'", "'memout'",
	"'sat'", "'success'", "'theory'", "'true'", "'unknown'", "'unsupported'",
	"'unsat'", "'assert'", "'check-sat'", "'check-sat-assuming'", "'declare-const'",
	"'declare-datatype'", "'declare-datatypes'", "'declare-fun'", "'declare-sort'",
	"'define-fun'", "'define-fun-rec'", "'define-funs-rec'", "'define-sort'",
	"'echo'", "'exit'", "'get-assertions'", "'get-assignment'", "'get-info'",
	"'get-model'", "'get-option'", "'get-proof'", "'get-unsat-assumptions'",
	"'get-unsat-core'", "'get-value'", "'pop'", "'push'", "'reset'", "'reset-assertions'",
	"'set-info'", "'set-logic'", "'set-option'", "'!'", "'_'", "'as'", "'BINARY'",
	"'DECIMAL'", "'exists'", "'HEXADECIMAL'", "'forall'", "'let'", "'match'",
	"'NUMERAL'", "'par'", "'string'", "", "", "", "", "':'", "':all-statistics'",
	"':assertion-stack-levels'", "':authors'", "':category'", "':chainable'",
	"':definition'", "':diagnostic-output-channel'", "':error-behavior'", "':extensions'",
	"':funs'", "':funs-description'", "':global-declarations'", "':interactive-mode'",
	"':language'", "':left-assoc'", "':license'", "':named'", "':name'", "':notes'",
	"':pattern'", "':print-success'", "':produce-assertions'", "':produce-assignments'",
	"':produce-models'", "':produce-proofs'", "':produce-unsat-assumptions'",
	"':produce-unsat-cores'", "':random-seed'", "':reason-unknown'", "':regular-output-channel'",
	"':reproducible-resource-limit'", "':right-assoc'", "':smt-lib-version'",
	"':sorts'", "':sorts-description'", "':source'", "':status'", "':theories'",
	"':values'", "':verbosity'", "':version'", "'model'",
}
var symbolicNames = []string{
	"", "Comment", "ParOpen", "ParClose", "Semicolon", "String_", "QuotedSymbol",
	"PS_Not", "PS_Bool", "PS_ContinuedExecution", "PS_Error", "PS_False", "PS_ImmediateExit",
	"PS_Incomplete", "PS_Logic", "PS_Memout", "PS_Sat", "PS_Success", "PS_Theory",
	"PS_True", "PS_Unknown", "PS_Unsupported", "PS_Unsat", "CMD_Assert", "CMD_CheckSat",
	"CMD_CheckSatAssuming", "CMD_DeclareConst", "CMD_DeclareDatatype", "CMD_DeclareDatatypes",
	"CMD_DeclareFun", "CMD_DeclareSort", "CMD_DefineFun", "CMD_DefineFunRec",
	"CMD_DefineFunsRec", "CMD_DefineSort", "CMD_Echo", "CMD_Exit", "CMD_GetAssertions",
	"CMD_GetAssignment", "CMD_GetInfo", "CMD_GetModel", "CMD_GetOption", "CMD_GetProof",
	"CMD_GetUnsatAssumptions", "CMD_GetUnsatCore", "CMD_GetValue", "CMD_Pop",
	"CMD_Push", "CMD_Reset", "CMD_ResetAssertions", "CMD_SetInfo", "CMD_SetLogic",
	"CMD_SetOption", "GRW_Exclamation", "GRW_Underscore", "GRW_As", "GRW_Binary",
	"GRW_Decimal", "GRW_Exists", "GRW_Hexadecimal", "GRW_Forall", "GRW_Let",
	"GRW_Match", "GRW_Numeral", "GRW_Par", "GRW_String", "Numeral", "Binary",
	"HexDecimal", "Decimal", "Colon", "PK_AllStatistics", "PK_AssertionStackLevels",
	"PK_Authors", "PK_Category", "PK_Chainable", "PK_Definition", "PK_DiagnosticOutputChannel",
	"PK_ErrorBehaviour", "PK_Extension", "PK_Funs", "PK_FunsDescription", "PK_GlobalDeclarations",
	"PK_InteractiveMode", "PK_Language", "PK_LeftAssoc", "PK_License", "PK_Named",
	"PK_Name", "PK_Notes", "PK_Pattern", "PK_PrintSuccess", "PK_ProduceAssertions",
	"PK_ProduceAssignments", "PK_ProduceModels", "PK_ProduceProofs", "PK_ProduceUnsatAssumptions",
	"PK_ProduceUnsatCores", "PK_RandomSeed", "PK_ReasonUnknown", "PK_RegularOutputChannel",
	"PK_ReproducibleResourceLimit", "PK_RightAssoc", "PK_SmtLibVersion", "PK_Sorts",
	"PK_SortsDescription", "PK_Source", "PK_Status", "PK_Theories", "PK_Values",
	"PK_Verbosity", "PK_Version", "RS_Model", "UndefinedSymbol", "WS",
}

var ruleNames = []string{
	"start", "generalReservedWord", "simpleSymbol", "quotedSymbol", "predefSymbol",
	"predefKeyword", "symbol", "numeral", "decimal", "hexadecimal", "binary",
	"string_", "keyword", "spec_constant", "s_expr", "index", "identifier",
	"attribute_value", "attribute", "sort", "qual_identifer", "var_binding",
	"sorted_var", "pattern", "match_case", "term", "sort_symbol_decl", "meta_spec_constant",
	"fun_symbol_decl", "par_fun_symbol_decl", "theory_attribute", "theory_decl",
	"logic_attribue", "logic", "sort_dec", "selector_dec", "constructor_dec",
	"datatype_dec", "function_dec", "function_def", "prop_literal", "script",
	"cmd_assert", "cmd_checkSat", "cmd_checkSatAssuming", "cmd_declareConst",
	"cmd_declareDatatype", "cmd_declareDatatypes", "cmd_declareFun", "cmd_declareSort",
	"cmd_defineFun", "cmd_defineFunRec", "cmd_defineFunsRec", "cmd_defineSort",
	"cmd_echo", "cmd_exit", "cmd_getAssertions", "cmd_getAssignment", "cmd_getInfo",
	"cmd_getModel", "cmd_getOption", "cmd_getProof", "cmd_getUnsatAssumptions",
	"cmd_getUnsatCore", "cmd_getValue", "cmd_pop", "cmd_push", "cmd_reset",
	"cmd_resetAssertions", "cmd_setInfo", "cmd_setLogic", "cmd_setOption",
	"command", "b_value", "option", "info_flag", "error_behaviour", "reason_unknown",
	"model_response", "info_response", "valuation_pair", "t_valuation_pair",
	"check_sat_response", "echo_response", "get_assertions_response", "get_assignment_response",
	"get_info_response", "get_model_response", "get_option_response", "get_proof_response",
	"get_unsat_assump_response", "get_unsat_core_response", "get_value_response",
	"specific_success_response", "general_response",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SMTLIBv2Parser struct {
	*antlr.BaseParser
}

func NewSMTLIBv2Parser(input antlr.TokenStream) *SMTLIBv2Parser {
	this := new(SMTLIBv2Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SMTLIBv2.g4"

	return this
}

// SMTLIBv2Parser tokens.
const (
	SMTLIBv2ParserEOF                          = antlr.TokenEOF
	SMTLIBv2ParserComment                      = 1
	SMTLIBv2ParserParOpen                      = 2
	SMTLIBv2ParserParClose                     = 3
	SMTLIBv2ParserSemicolon                    = 4
	SMTLIBv2ParserString_                      = 5
	SMTLIBv2ParserQuotedSymbol                 = 6
	SMTLIBv2ParserPS_Not                       = 7
	SMTLIBv2ParserPS_Bool                      = 8
	SMTLIBv2ParserPS_ContinuedExecution        = 9
	SMTLIBv2ParserPS_Error                     = 10
	SMTLIBv2ParserPS_False                     = 11
	SMTLIBv2ParserPS_ImmediateExit             = 12
	SMTLIBv2ParserPS_Incomplete                = 13
	SMTLIBv2ParserPS_Logic                     = 14
	SMTLIBv2ParserPS_Memout                    = 15
	SMTLIBv2ParserPS_Sat                       = 16
	SMTLIBv2ParserPS_Success                   = 17
	SMTLIBv2ParserPS_Theory                    = 18
	SMTLIBv2ParserPS_True                      = 19
	SMTLIBv2ParserPS_Unknown                   = 20
	SMTLIBv2ParserPS_Unsupported               = 21
	SMTLIBv2ParserPS_Unsat                     = 22
	SMTLIBv2ParserCMD_Assert                   = 23
	SMTLIBv2ParserCMD_CheckSat                 = 24
	SMTLIBv2ParserCMD_CheckSatAssuming         = 25
	SMTLIBv2ParserCMD_DeclareConst             = 26
	SMTLIBv2ParserCMD_DeclareDatatype          = 27
	SMTLIBv2ParserCMD_DeclareDatatypes         = 28
	SMTLIBv2ParserCMD_DeclareFun               = 29
	SMTLIBv2ParserCMD_DeclareSort              = 30
	SMTLIBv2ParserCMD_DefineFun                = 31
	SMTLIBv2ParserCMD_DefineFunRec             = 32
	SMTLIBv2ParserCMD_DefineFunsRec            = 33
	SMTLIBv2ParserCMD_DefineSort               = 34
	SMTLIBv2ParserCMD_Echo                     = 35
	SMTLIBv2ParserCMD_Exit                     = 36
	SMTLIBv2ParserCMD_GetAssertions            = 37
	SMTLIBv2ParserCMD_GetAssignment            = 38
	SMTLIBv2ParserCMD_GetInfo                  = 39
	SMTLIBv2ParserCMD_GetModel                 = 40
	SMTLIBv2ParserCMD_GetOption                = 41
	SMTLIBv2ParserCMD_GetProof                 = 42
	SMTLIBv2ParserCMD_GetUnsatAssumptions      = 43
	SMTLIBv2ParserCMD_GetUnsatCore             = 44
	SMTLIBv2ParserCMD_GetValue                 = 45
	SMTLIBv2ParserCMD_Pop                      = 46
	SMTLIBv2ParserCMD_Push                     = 47
	SMTLIBv2ParserCMD_Reset                    = 48
	SMTLIBv2ParserCMD_ResetAssertions          = 49
	SMTLIBv2ParserCMD_SetInfo                  = 50
	SMTLIBv2ParserCMD_SetLogic                 = 51
	SMTLIBv2ParserCMD_SetOption                = 52
	SMTLIBv2ParserGRW_Exclamation              = 53
	SMTLIBv2ParserGRW_Underscore               = 54
	SMTLIBv2ParserGRW_As                       = 55
	SMTLIBv2ParserGRW_Binary                   = 56
	SMTLIBv2ParserGRW_Decimal                  = 57
	SMTLIBv2ParserGRW_Exists                   = 58
	SMTLIBv2ParserGRW_Hexadecimal              = 59
	SMTLIBv2ParserGRW_Forall                   = 60
	SMTLIBv2ParserGRW_Let                      = 61
	SMTLIBv2ParserGRW_Match                    = 62
	SMTLIBv2ParserGRW_Numeral                  = 63
	SMTLIBv2ParserGRW_Par                      = 64
	SMTLIBv2ParserGRW_String                   = 65
	SMTLIBv2ParserNumeral                      = 66
	SMTLIBv2ParserBinary                       = 67
	SMTLIBv2ParserHexDecimal                   = 68
	SMTLIBv2ParserDecimal                      = 69
	SMTLIBv2ParserColon                        = 70
	SMTLIBv2ParserPK_AllStatistics             = 71
	SMTLIBv2ParserPK_AssertionStackLevels      = 72
	SMTLIBv2ParserPK_Authors                   = 73
	SMTLIBv2ParserPK_Category                  = 74
	SMTLIBv2ParserPK_Chainable                 = 75
	SMTLIBv2ParserPK_Definition                = 76
	SMTLIBv2ParserPK_DiagnosticOutputChannel   = 77
	SMTLIBv2ParserPK_ErrorBehaviour            = 78
	SMTLIBv2ParserPK_Extension                 = 79
	SMTLIBv2ParserPK_Funs                      = 80
	SMTLIBv2ParserPK_FunsDescription           = 81
	SMTLIBv2ParserPK_GlobalDeclarations        = 82
	SMTLIBv2ParserPK_InteractiveMode           = 83
	SMTLIBv2ParserPK_Language                  = 84
	SMTLIBv2ParserPK_LeftAssoc                 = 85
	SMTLIBv2ParserPK_License                   = 86
	SMTLIBv2ParserPK_Named                     = 87
	SMTLIBv2ParserPK_Name                      = 88
	SMTLIBv2ParserPK_Notes                     = 89
	SMTLIBv2ParserPK_Pattern                   = 90
	SMTLIBv2ParserPK_PrintSuccess              = 91
	SMTLIBv2ParserPK_ProduceAssertions         = 92
	SMTLIBv2ParserPK_ProduceAssignments        = 93
	SMTLIBv2ParserPK_ProduceModels             = 94
	SMTLIBv2ParserPK_ProduceProofs             = 95
	SMTLIBv2ParserPK_ProduceUnsatAssumptions   = 96
	SMTLIBv2ParserPK_ProduceUnsatCores         = 97
	SMTLIBv2ParserPK_RandomSeed                = 98
	SMTLIBv2ParserPK_ReasonUnknown             = 99
	SMTLIBv2ParserPK_RegularOutputChannel      = 100
	SMTLIBv2ParserPK_ReproducibleResourceLimit = 101
	SMTLIBv2ParserPK_RightAssoc                = 102
	SMTLIBv2ParserPK_SmtLibVersion             = 103
	SMTLIBv2ParserPK_Sorts                     = 104
	SMTLIBv2ParserPK_SortsDescription          = 105
	SMTLIBv2ParserPK_Source                    = 106
	SMTLIBv2ParserPK_Status                    = 107
	SMTLIBv2ParserPK_Theories                  = 108
	SMTLIBv2ParserPK_Values                    = 109
	SMTLIBv2ParserPK_Verbosity                 = 110
	SMTLIBv2ParserPK_Version                   = 111
	SMTLIBv2ParserRS_Model                     = 112
	SMTLIBv2ParserUndefinedSymbol              = 113
	SMTLIBv2ParserWS                           = 114
)

// SMTLIBv2Parser rules.
const (
	SMTLIBv2ParserRULE_start                     = 0
	SMTLIBv2ParserRULE_generalReservedWord       = 1
	SMTLIBv2ParserRULE_simpleSymbol              = 2
	SMTLIBv2ParserRULE_quotedSymbol              = 3
	SMTLIBv2ParserRULE_predefSymbol              = 4
	SMTLIBv2ParserRULE_predefKeyword             = 5
	SMTLIBv2ParserRULE_symbol                    = 6
	SMTLIBv2ParserRULE_numeral                   = 7
	SMTLIBv2ParserRULE_decimal                   = 8
	SMTLIBv2ParserRULE_hexadecimal               = 9
	SMTLIBv2ParserRULE_binary                    = 10
	SMTLIBv2ParserRULE_string_                   = 11
	SMTLIBv2ParserRULE_keyword                   = 12
	SMTLIBv2ParserRULE_spec_constant             = 13
	SMTLIBv2ParserRULE_s_expr                    = 14
	SMTLIBv2ParserRULE_index                     = 15
	SMTLIBv2ParserRULE_identifier                = 16
	SMTLIBv2ParserRULE_attribute_value           = 17
	SMTLIBv2ParserRULE_attribute                 = 18
	SMTLIBv2ParserRULE_sort                      = 19
	SMTLIBv2ParserRULE_qual_identifer            = 20
	SMTLIBv2ParserRULE_var_binding               = 21
	SMTLIBv2ParserRULE_sorted_var                = 22
	SMTLIBv2ParserRULE_pattern                   = 23
	SMTLIBv2ParserRULE_match_case                = 24
	SMTLIBv2ParserRULE_term                      = 25
	SMTLIBv2ParserRULE_sort_symbol_decl          = 26
	SMTLIBv2ParserRULE_meta_spec_constant        = 27
	SMTLIBv2ParserRULE_fun_symbol_decl           = 28
	SMTLIBv2ParserRULE_par_fun_symbol_decl       = 29
	SMTLIBv2ParserRULE_theory_attribute          = 30
	SMTLIBv2ParserRULE_theory_decl               = 31
	SMTLIBv2ParserRULE_logic_attribue            = 32
	SMTLIBv2ParserRULE_logic                     = 33
	SMTLIBv2ParserRULE_sort_dec                  = 34
	SMTLIBv2ParserRULE_selector_dec              = 35
	SMTLIBv2ParserRULE_constructor_dec           = 36
	SMTLIBv2ParserRULE_datatype_dec              = 37
	SMTLIBv2ParserRULE_function_dec              = 38
	SMTLIBv2ParserRULE_function_def              = 39
	SMTLIBv2ParserRULE_prop_literal              = 40
	SMTLIBv2ParserRULE_script                    = 41
	SMTLIBv2ParserRULE_cmd_assert                = 42
	SMTLIBv2ParserRULE_cmd_checkSat              = 43
	SMTLIBv2ParserRULE_cmd_checkSatAssuming      = 44
	SMTLIBv2ParserRULE_cmd_declareConst          = 45
	SMTLIBv2ParserRULE_cmd_declareDatatype       = 46
	SMTLIBv2ParserRULE_cmd_declareDatatypes      = 47
	SMTLIBv2ParserRULE_cmd_declareFun            = 48
	SMTLIBv2ParserRULE_cmd_declareSort           = 49
	SMTLIBv2ParserRULE_cmd_defineFun             = 50
	SMTLIBv2ParserRULE_cmd_defineFunRec          = 51
	SMTLIBv2ParserRULE_cmd_defineFunsRec         = 52
	SMTLIBv2ParserRULE_cmd_defineSort            = 53
	SMTLIBv2ParserRULE_cmd_echo                  = 54
	SMTLIBv2ParserRULE_cmd_exit                  = 55
	SMTLIBv2ParserRULE_cmd_getAssertions         = 56
	SMTLIBv2ParserRULE_cmd_getAssignment         = 57
	SMTLIBv2ParserRULE_cmd_getInfo               = 58
	SMTLIBv2ParserRULE_cmd_getModel              = 59
	SMTLIBv2ParserRULE_cmd_getOption             = 60
	SMTLIBv2ParserRULE_cmd_getProof              = 61
	SMTLIBv2ParserRULE_cmd_getUnsatAssumptions   = 62
	SMTLIBv2ParserRULE_cmd_getUnsatCore          = 63
	SMTLIBv2ParserRULE_cmd_getValue              = 64
	SMTLIBv2ParserRULE_cmd_pop                   = 65
	SMTLIBv2ParserRULE_cmd_push                  = 66
	SMTLIBv2ParserRULE_cmd_reset                 = 67
	SMTLIBv2ParserRULE_cmd_resetAssertions       = 68
	SMTLIBv2ParserRULE_cmd_setInfo               = 69
	SMTLIBv2ParserRULE_cmd_setLogic              = 70
	SMTLIBv2ParserRULE_cmd_setOption             = 71
	SMTLIBv2ParserRULE_command                   = 72
	SMTLIBv2ParserRULE_b_value                   = 73
	SMTLIBv2ParserRULE_option                    = 74
	SMTLIBv2ParserRULE_info_flag                 = 75
	SMTLIBv2ParserRULE_error_behaviour           = 76
	SMTLIBv2ParserRULE_reason_unknown            = 77
	SMTLIBv2ParserRULE_model_response            = 78
	SMTLIBv2ParserRULE_info_response             = 79
	SMTLIBv2ParserRULE_valuation_pair            = 80
	SMTLIBv2ParserRULE_t_valuation_pair          = 81
	SMTLIBv2ParserRULE_check_sat_response        = 82
	SMTLIBv2ParserRULE_echo_response             = 83
	SMTLIBv2ParserRULE_get_assertions_response   = 84
	SMTLIBv2ParserRULE_get_assignment_response   = 85
	SMTLIBv2ParserRULE_get_info_response         = 86
	SMTLIBv2ParserRULE_get_model_response        = 87
	SMTLIBv2ParserRULE_get_option_response       = 88
	SMTLIBv2ParserRULE_get_proof_response        = 89
	SMTLIBv2ParserRULE_get_unsat_assump_response = 90
	SMTLIBv2ParserRULE_get_unsat_core_response   = 91
	SMTLIBv2ParserRULE_get_value_response        = 92
	SMTLIBv2ParserRULE_specific_success_response = 93
	SMTLIBv2ParserRULE_general_response          = 94
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Logic() ILogicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogicContext)
}

func (s *StartContext) EOF() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserEOF, 0)
}

func (s *StartContext) Theory_decl() ITheory_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITheory_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITheory_declContext)
}

func (s *StartContext) Script() IScriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptContext)
}

func (s *StartContext) General_response() IGeneral_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_responseContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitStart(s)
	}
}

func (s *StartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Start() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SMTLIBv2ParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(190)
			p.Logic()
		}
		{
			p.SetState(191)
			p.Match(SMTLIBv2ParserEOF)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(193)
			p.Theory_decl()
		}
		{
			p.SetState(194)
			p.Match(SMTLIBv2ParserEOF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(196)
			p.Script()
		}
		{
			p.SetState(197)
			p.Match(SMTLIBv2ParserEOF)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(199)
			p.General_response()
		}
		{
			p.SetState(200)
			p.Match(SMTLIBv2ParserEOF)
		}

	}

	return localctx
}

// IGeneralReservedWordContext is an interface to support dynamic dispatch.
type IGeneralReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralReservedWordContext differentiates from other interfaces.
	IsGeneralReservedWordContext()
}

type GeneralReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralReservedWordContext() *GeneralReservedWordContext {
	var p = new(GeneralReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord
	return p
}

func (*GeneralReservedWordContext) IsGeneralReservedWordContext() {}

func NewGeneralReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralReservedWordContext {
	var p = new(GeneralReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord

	return p
}

func (s *GeneralReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralReservedWordContext) GRW_Exclamation() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exclamation, 0)
}

func (s *GeneralReservedWordContext) GRW_Underscore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Underscore, 0)
}

func (s *GeneralReservedWordContext) GRW_As() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_As, 0)
}

func (s *GeneralReservedWordContext) GRW_Binary() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Binary, 0)
}

func (s *GeneralReservedWordContext) GRW_Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Decimal, 0)
}

func (s *GeneralReservedWordContext) GRW_Exists() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exists, 0)
}

func (s *GeneralReservedWordContext) GRW_Hexadecimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Hexadecimal, 0)
}

func (s *GeneralReservedWordContext) GRW_Forall() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Forall, 0)
}

func (s *GeneralReservedWordContext) GRW_Let() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Let, 0)
}

func (s *GeneralReservedWordContext) GRW_Match() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Match, 0)
}

func (s *GeneralReservedWordContext) GRW_Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Numeral, 0)
}

func (s *GeneralReservedWordContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *GeneralReservedWordContext) GRW_String() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_String, 0)
}

func (s *GeneralReservedWordContext) RS_Model() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserRS_Model, 0)
}

func (s *GeneralReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGeneralReservedWord(s)
	}
}

func (s *GeneralReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGeneralReservedWord(s)
	}
}

func (s *GeneralReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGeneralReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) GeneralReservedWord() (localctx IGeneralReservedWordContext) {
	localctx = NewGeneralReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SMTLIBv2ParserRULE_generalReservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(204)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SMTLIBv2ParserGRW_Exclamation-53))|(1<<(SMTLIBv2ParserGRW_Underscore-53))|(1<<(SMTLIBv2ParserGRW_As-53))|(1<<(SMTLIBv2ParserGRW_Binary-53))|(1<<(SMTLIBv2ParserGRW_Decimal-53))|(1<<(SMTLIBv2ParserGRW_Exists-53))|(1<<(SMTLIBv2ParserGRW_Hexadecimal-53))|(1<<(SMTLIBv2ParserGRW_Forall-53))|(1<<(SMTLIBv2ParserGRW_Let-53))|(1<<(SMTLIBv2ParserGRW_Match-53))|(1<<(SMTLIBv2ParserGRW_Numeral-53))|(1<<(SMTLIBv2ParserGRW_Par-53))|(1<<(SMTLIBv2ParserGRW_String-53)))) != 0) || _la == SMTLIBv2ParserRS_Model) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISimpleSymbolContext is an interface to support dynamic dispatch.
type ISimpleSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleSymbolContext differentiates from other interfaces.
	IsSimpleSymbolContext()
}

type SimpleSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleSymbolContext() *SimpleSymbolContext {
	var p = new(SimpleSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol
	return p
}

func (*SimpleSymbolContext) IsSimpleSymbolContext() {}

func NewSimpleSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleSymbolContext {
	var p = new(SimpleSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol

	return p
}

func (s *SimpleSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleSymbolContext) PredefSymbol() IPredefSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredefSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredefSymbolContext)
}

func (s *SimpleSymbolContext) UndefinedSymbol() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserUndefinedSymbol, 0)
}

func (s *SimpleSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSimpleSymbol(s)
	}
}

func (s *SimpleSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSimpleSymbol(s)
	}
}

func (s *SimpleSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSimpleSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) SimpleSymbol() (localctx ISimpleSymbolContext) {
	localctx = NewSimpleSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SMTLIBv2ParserRULE_simpleSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(208)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(206)
			p.PredefSymbol()
		}

	case SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(207)
			p.Match(SMTLIBv2ParserUndefinedSymbol)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedSymbolContext is an interface to support dynamic dispatch.
type IQuotedSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedSymbolContext differentiates from other interfaces.
	IsQuotedSymbolContext()
}

type QuotedSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedSymbolContext() *QuotedSymbolContext {
	var p = new(QuotedSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol
	return p
}

func (*QuotedSymbolContext) IsQuotedSymbolContext() {}

func NewQuotedSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedSymbolContext {
	var p = new(QuotedSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol

	return p
}

func (s *QuotedSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedSymbolContext) QuotedSymbol() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserQuotedSymbol, 0)
}

func (s *QuotedSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterQuotedSymbol(s)
	}
}

func (s *QuotedSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitQuotedSymbol(s)
	}
}

func (s *QuotedSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitQuotedSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) QuotedSymbol() (localctx IQuotedSymbolContext) {
	localctx = NewQuotedSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SMTLIBv2ParserRULE_quotedSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(SMTLIBv2ParserQuotedSymbol)
	}

	return localctx
}

// IPredefSymbolContext is an interface to support dynamic dispatch.
type IPredefSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredefSymbolContext differentiates from other interfaces.
	IsPredefSymbolContext()
}

type PredefSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefSymbolContext() *PredefSymbolContext {
	var p = new(PredefSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol
	return p
}

func (*PredefSymbolContext) IsPredefSymbolContext() {}

func NewPredefSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefSymbolContext {
	var p = new(PredefSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol

	return p
}

func (s *PredefSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefSymbolContext) PS_Not() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Not, 0)
}

func (s *PredefSymbolContext) PS_Bool() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Bool, 0)
}

func (s *PredefSymbolContext) PS_ContinuedExecution() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ContinuedExecution, 0)
}

func (s *PredefSymbolContext) PS_Error() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Error, 0)
}

func (s *PredefSymbolContext) PS_False() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_False, 0)
}

func (s *PredefSymbolContext) PS_ImmediateExit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ImmediateExit, 0)
}

func (s *PredefSymbolContext) PS_Incomplete() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Incomplete, 0)
}

func (s *PredefSymbolContext) PS_Logic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Logic, 0)
}

func (s *PredefSymbolContext) PS_Memout() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Memout, 0)
}

func (s *PredefSymbolContext) PS_Sat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Sat, 0)
}

func (s *PredefSymbolContext) PS_Success() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Success, 0)
}

func (s *PredefSymbolContext) PS_Theory() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Theory, 0)
}

func (s *PredefSymbolContext) PS_True() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_True, 0)
}

func (s *PredefSymbolContext) PS_Unknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unknown, 0)
}

func (s *PredefSymbolContext) PS_Unsupported() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsupported, 0)
}

func (s *PredefSymbolContext) PS_Unsat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsat, 0)
}

func (s *PredefSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPredefSymbol(s)
	}
}

func (s *PredefSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPredefSymbol(s)
	}
}

func (s *PredefSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPredefSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) PredefSymbol() (localctx IPredefSymbolContext) {
	localctx = NewPredefSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SMTLIBv2ParserRULE_predefSymbol)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPredefKeywordContext is an interface to support dynamic dispatch.
type IPredefKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredefKeywordContext differentiates from other interfaces.
	IsPredefKeywordContext()
}

type PredefKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefKeywordContext() *PredefKeywordContext {
	var p = new(PredefKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword
	return p
}

func (*PredefKeywordContext) IsPredefKeywordContext() {}

func NewPredefKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefKeywordContext {
	var p = new(PredefKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword

	return p
}

func (s *PredefKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefKeywordContext) PK_AllStatistics() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AllStatistics, 0)
}

func (s *PredefKeywordContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *PredefKeywordContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *PredefKeywordContext) PK_Category() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Category, 0)
}

func (s *PredefKeywordContext) PK_Chainable() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Chainable, 0)
}

func (s *PredefKeywordContext) PK_Definition() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Definition, 0)
}

func (s *PredefKeywordContext) PK_DiagnosticOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_DiagnosticOutputChannel, 0)
}

func (s *PredefKeywordContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *PredefKeywordContext) PK_Extension() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Extension, 0)
}

func (s *PredefKeywordContext) PK_Funs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Funs, 0)
}

func (s *PredefKeywordContext) PK_FunsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_FunsDescription, 0)
}

func (s *PredefKeywordContext) PK_GlobalDeclarations() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_GlobalDeclarations, 0)
}

func (s *PredefKeywordContext) PK_InteractiveMode() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_InteractiveMode, 0)
}

func (s *PredefKeywordContext) PK_Language() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Language, 0)
}

func (s *PredefKeywordContext) PK_LeftAssoc() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_LeftAssoc, 0)
}

func (s *PredefKeywordContext) PK_License() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_License, 0)
}

func (s *PredefKeywordContext) PK_Named() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Named, 0)
}

func (s *PredefKeywordContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *PredefKeywordContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *PredefKeywordContext) PK_Pattern() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Pattern, 0)
}

func (s *PredefKeywordContext) PK_PrintSuccess() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_PrintSuccess, 0)
}

func (s *PredefKeywordContext) PK_ProduceAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssertions, 0)
}

func (s *PredefKeywordContext) PK_ProduceAssignments() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssignments, 0)
}

func (s *PredefKeywordContext) PK_ProduceModels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceModels, 0)
}

func (s *PredefKeywordContext) PK_ProduceProofs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceProofs, 0)
}

func (s *PredefKeywordContext) PK_ProduceUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatAssumptions, 0)
}

func (s *PredefKeywordContext) PK_ProduceUnsatCores() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatCores, 0)
}

func (s *PredefKeywordContext) PK_RandomSeed() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RandomSeed, 0)
}

func (s *PredefKeywordContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *PredefKeywordContext) PK_RegularOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RegularOutputChannel, 0)
}

func (s *PredefKeywordContext) PK_ReproducibleResourceLimit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReproducibleResourceLimit, 0)
}

func (s *PredefKeywordContext) PK_RightAssoc() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RightAssoc, 0)
}

func (s *PredefKeywordContext) PK_SmtLibVersion() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SmtLibVersion, 0)
}

func (s *PredefKeywordContext) PK_Sorts() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Sorts, 0)
}

func (s *PredefKeywordContext) PK_SortsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SortsDescription, 0)
}

func (s *PredefKeywordContext) PK_Source() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Source, 0)
}

func (s *PredefKeywordContext) PK_Status() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Status, 0)
}

func (s *PredefKeywordContext) PK_Theories() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Theories, 0)
}

func (s *PredefKeywordContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *PredefKeywordContext) PK_Verbosity() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Verbosity, 0)
}

func (s *PredefKeywordContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *PredefKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPredefKeyword(s)
	}
}

func (s *PredefKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPredefKeyword(s)
	}
}

func (s *PredefKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPredefKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) PredefKeyword() (localctx IPredefKeywordContext) {
	localctx = NewPredefKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SMTLIBv2ParserRULE_predefKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(SMTLIBv2ParserPK_AllStatistics-71))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-71))|(1<<(SMTLIBv2ParserPK_Authors-71))|(1<<(SMTLIBv2ParserPK_Category-71))|(1<<(SMTLIBv2ParserPK_Chainable-71))|(1<<(SMTLIBv2ParserPK_Definition-71))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-71))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-71))|(1<<(SMTLIBv2ParserPK_Extension-71))|(1<<(SMTLIBv2ParserPK_Funs-71))|(1<<(SMTLIBv2ParserPK_FunsDescription-71))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-71))|(1<<(SMTLIBv2ParserPK_InteractiveMode-71))|(1<<(SMTLIBv2ParserPK_Language-71))|(1<<(SMTLIBv2ParserPK_LeftAssoc-71))|(1<<(SMTLIBv2ParserPK_License-71))|(1<<(SMTLIBv2ParserPK_Named-71))|(1<<(SMTLIBv2ParserPK_Name-71))|(1<<(SMTLIBv2ParserPK_Notes-71))|(1<<(SMTLIBv2ParserPK_Pattern-71))|(1<<(SMTLIBv2ParserPK_PrintSuccess-71))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-71))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-71))|(1<<(SMTLIBv2ParserPK_ProduceModels-71))|(1<<(SMTLIBv2ParserPK_ProduceProofs-71))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-71))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-71))|(1<<(SMTLIBv2ParserPK_RandomSeed-71))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-71))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-71))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-71))|(1<<(SMTLIBv2ParserPK_RightAssoc-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(SMTLIBv2ParserPK_SmtLibVersion-103))|(1<<(SMTLIBv2ParserPK_Sorts-103))|(1<<(SMTLIBv2ParserPK_SortsDescription-103))|(1<<(SMTLIBv2ParserPK_Source-103))|(1<<(SMTLIBv2ParserPK_Status-103))|(1<<(SMTLIBv2ParserPK_Theories-103))|(1<<(SMTLIBv2ParserPK_Values-103))|(1<<(SMTLIBv2ParserPK_Verbosity-103))|(1<<(SMTLIBv2ParserPK_Version-103)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_symbol
	return p
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) SimpleSymbol() ISimpleSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleSymbolContext)
}

func (s *SymbolContext) QuotedSymbol() IQuotedSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedSymbolContext)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (s *SymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SMTLIBv2ParserRULE_symbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(216)
			p.SimpleSymbol()
		}

	case SMTLIBv2ParserQuotedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(217)
			p.QuotedSymbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumeralContext is an interface to support dynamic dispatch.
type INumeralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeralContext differentiates from other interfaces.
	IsNumeralContext()
}

type NumeralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeralContext() *NumeralContext {
	var p = new(NumeralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_numeral
	return p
}

func (*NumeralContext) IsNumeralContext() {}

func NewNumeralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumeralContext {
	var p = new(NumeralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_numeral

	return p
}

func (s *NumeralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumeralContext) Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserNumeral, 0)
}

func (s *NumeralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumeralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumeralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterNumeral(s)
	}
}

func (s *NumeralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitNumeral(s)
	}
}

func (s *NumeralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitNumeral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Numeral() (localctx INumeralContext) {
	localctx = NewNumeralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SMTLIBv2ParserRULE_numeral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(220)
		p.Match(SMTLIBv2ParserNumeral)
	}

	return localctx
}

// IDecimalContext is an interface to support dynamic dispatch.
type IDecimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalContext differentiates from other interfaces.
	IsDecimalContext()
}

type DecimalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalContext() *DecimalContext {
	var p = new(DecimalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_decimal
	return p
}

func (*DecimalContext) IsDecimalContext() {}

func NewDecimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalContext {
	var p = new(DecimalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_decimal

	return p
}

func (s *DecimalContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalContext) Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserDecimal, 0)
}

func (s *DecimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterDecimal(s)
	}
}

func (s *DecimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitDecimal(s)
	}
}

func (s *DecimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitDecimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Decimal() (localctx IDecimalContext) {
	localctx = NewDecimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SMTLIBv2ParserRULE_decimal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(SMTLIBv2ParserDecimal)
	}

	return localctx
}

// IHexadecimalContext is an interface to support dynamic dispatch.
type IHexadecimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalContext differentiates from other interfaces.
	IsHexadecimalContext()
}

type HexadecimalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalContext() *HexadecimalContext {
	var p = new(HexadecimalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal
	return p
}

func (*HexadecimalContext) IsHexadecimalContext() {}

func NewHexadecimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalContext {
	var p = new(HexadecimalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal

	return p
}

func (s *HexadecimalContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalContext) HexDecimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserHexDecimal, 0)
}

func (s *HexadecimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterHexadecimal(s)
	}
}

func (s *HexadecimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitHexadecimal(s)
	}
}

func (s *HexadecimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitHexadecimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Hexadecimal() (localctx IHexadecimalContext) {
	localctx = NewHexadecimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SMTLIBv2ParserRULE_hexadecimal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(SMTLIBv2ParserHexDecimal)
	}

	return localctx
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_binary
	return p
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) Binary() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserBinary, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitBinary(s)
	}
}

func (s *BinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SMTLIBv2ParserRULE_binary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(SMTLIBv2ParserBinary)
	}

	return localctx
}

// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_string_
	return p
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) String_() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserString_, 0)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterString_(s)
	}
}

func (s *String_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitString_(s)
	}
}

func (s *String_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitString_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SMTLIBv2ParserRULE_string_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(228)
		p.Match(SMTLIBv2ParserString_)
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) PredefKeyword() IPredefKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredefKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredefKeywordContext)
}

func (s *KeywordContext) Colon() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserColon, 0)
}

func (s *KeywordContext) SimpleSymbol() ISimpleSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleSymbolContext)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SMTLIBv2ParserRULE_keyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(233)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPK_AllStatistics, SMTLIBv2ParserPK_AssertionStackLevels, SMTLIBv2ParserPK_Authors, SMTLIBv2ParserPK_Category, SMTLIBv2ParserPK_Chainable, SMTLIBv2ParserPK_Definition, SMTLIBv2ParserPK_DiagnosticOutputChannel, SMTLIBv2ParserPK_ErrorBehaviour, SMTLIBv2ParserPK_Extension, SMTLIBv2ParserPK_Funs, SMTLIBv2ParserPK_FunsDescription, SMTLIBv2ParserPK_GlobalDeclarations, SMTLIBv2ParserPK_InteractiveMode, SMTLIBv2ParserPK_Language, SMTLIBv2ParserPK_LeftAssoc, SMTLIBv2ParserPK_License, SMTLIBv2ParserPK_Named, SMTLIBv2ParserPK_Name, SMTLIBv2ParserPK_Notes, SMTLIBv2ParserPK_Pattern, SMTLIBv2ParserPK_PrintSuccess, SMTLIBv2ParserPK_ProduceAssertions, SMTLIBv2ParserPK_ProduceAssignments, SMTLIBv2ParserPK_ProduceModels, SMTLIBv2ParserPK_ProduceProofs, SMTLIBv2ParserPK_ProduceUnsatAssumptions, SMTLIBv2ParserPK_ProduceUnsatCores, SMTLIBv2ParserPK_RandomSeed, SMTLIBv2ParserPK_ReasonUnknown, SMTLIBv2ParserPK_RegularOutputChannel, SMTLIBv2ParserPK_ReproducibleResourceLimit, SMTLIBv2ParserPK_RightAssoc, SMTLIBv2ParserPK_SmtLibVersion, SMTLIBv2ParserPK_Sorts, SMTLIBv2ParserPK_SortsDescription, SMTLIBv2ParserPK_Source, SMTLIBv2ParserPK_Status, SMTLIBv2ParserPK_Theories, SMTLIBv2ParserPK_Values, SMTLIBv2ParserPK_Verbosity, SMTLIBv2ParserPK_Version:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(230)
			p.PredefKeyword()
		}

	case SMTLIBv2ParserColon:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(231)
			p.Match(SMTLIBv2ParserColon)
		}
		{
			p.SetState(232)
			p.SimpleSymbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpec_constantContext is an interface to support dynamic dispatch.
type ISpec_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpec_constantContext differentiates from other interfaces.
	IsSpec_constantContext()
}

type Spec_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpec_constantContext() *Spec_constantContext {
	var p = new(Spec_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant
	return p
}

func (*Spec_constantContext) IsSpec_constantContext() {}

func NewSpec_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Spec_constantContext {
	var p = new(Spec_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant

	return p
}

func (s *Spec_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Spec_constantContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Spec_constantContext) Decimal() IDecimalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalContext)
}

func (s *Spec_constantContext) Hexadecimal() IHexadecimalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexadecimalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexadecimalContext)
}

func (s *Spec_constantContext) Binary() IBinaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *Spec_constantContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Spec_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Spec_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Spec_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSpec_constant(s)
	}
}

func (s *Spec_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSpec_constant(s)
	}
}

func (s *Spec_constantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSpec_constant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Spec_constant() (localctx ISpec_constantContext) {
	localctx = NewSpec_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SMTLIBv2ParserRULE_spec_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(240)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserNumeral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(235)
			p.Numeral()
		}

	case SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(236)
			p.Decimal()
		}

	case SMTLIBv2ParserHexDecimal:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(237)
			p.Hexadecimal()
		}

	case SMTLIBv2ParserBinary:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(238)
			p.Binary()
		}

	case SMTLIBv2ParserString_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(239)
			p.String_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IS_exprContext is an interface to support dynamic dispatch.
type IS_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsS_exprContext differentiates from other interfaces.
	IsS_exprContext()
}

type S_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyS_exprContext() *S_exprContext {
	var p = new(S_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr
	return p
}

func (*S_exprContext) IsS_exprContext() {}

func NewS_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *S_exprContext {
	var p = new(S_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr

	return p
}

func (s *S_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *S_exprContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *S_exprContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *S_exprContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *S_exprContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *S_exprContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *S_exprContext) AllS_expr() []IS_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IS_exprContext)(nil)).Elem())
	var tst = make([]IS_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IS_exprContext)
		}
	}

	return tst
}

func (s *S_exprContext) S_expr(i int) IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *S_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *S_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *S_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterS_expr(s)
	}
}

func (s *S_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitS_expr(s)
	}
}

func (s *S_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitS_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) S_expr() (localctx IS_exprContext) {
	localctx = NewS_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SMTLIBv2ParserRULE_s_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(253)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserString_, SMTLIBv2ParserNumeral, SMTLIBv2ParserBinary, SMTLIBv2ParserHexDecimal, SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(242)
			p.Spec_constant()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(243)
			p.Symbol()
		}

	case SMTLIBv2ParserColon, SMTLIBv2ParserPK_AllStatistics, SMTLIBv2ParserPK_AssertionStackLevels, SMTLIBv2ParserPK_Authors, SMTLIBv2ParserPK_Category, SMTLIBv2ParserPK_Chainable, SMTLIBv2ParserPK_Definition, SMTLIBv2ParserPK_DiagnosticOutputChannel, SMTLIBv2ParserPK_ErrorBehaviour, SMTLIBv2ParserPK_Extension, SMTLIBv2ParserPK_Funs, SMTLIBv2ParserPK_FunsDescription, SMTLIBv2ParserPK_GlobalDeclarations, SMTLIBv2ParserPK_InteractiveMode, SMTLIBv2ParserPK_Language, SMTLIBv2ParserPK_LeftAssoc, SMTLIBv2ParserPK_License, SMTLIBv2ParserPK_Named, SMTLIBv2ParserPK_Name, SMTLIBv2ParserPK_Notes, SMTLIBv2ParserPK_Pattern, SMTLIBv2ParserPK_PrintSuccess, SMTLIBv2ParserPK_ProduceAssertions, SMTLIBv2ParserPK_ProduceAssignments, SMTLIBv2ParserPK_ProduceModels, SMTLIBv2ParserPK_ProduceProofs, SMTLIBv2ParserPK_ProduceUnsatAssumptions, SMTLIBv2ParserPK_ProduceUnsatCores, SMTLIBv2ParserPK_RandomSeed, SMTLIBv2ParserPK_ReasonUnknown, SMTLIBv2ParserPK_RegularOutputChannel, SMTLIBv2ParserPK_ReproducibleResourceLimit, SMTLIBv2ParserPK_RightAssoc, SMTLIBv2ParserPK_SmtLibVersion, SMTLIBv2ParserPK_Sorts, SMTLIBv2ParserPK_SortsDescription, SMTLIBv2ParserPK_Source, SMTLIBv2ParserPK_Status, SMTLIBv2ParserPK_Theories, SMTLIBv2ParserPK_Values, SMTLIBv2ParserPK_Verbosity, SMTLIBv2ParserPK_Version:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(244)
			p.Keyword()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(245)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66))|(1<<(SMTLIBv2ParserColon-66))|(1<<(SMTLIBv2ParserPK_AllStatistics-66))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-66))|(1<<(SMTLIBv2ParserPK_Authors-66))|(1<<(SMTLIBv2ParserPK_Category-66))|(1<<(SMTLIBv2ParserPK_Chainable-66))|(1<<(SMTLIBv2ParserPK_Definition-66))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-66))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-66))|(1<<(SMTLIBv2ParserPK_Extension-66))|(1<<(SMTLIBv2ParserPK_Funs-66))|(1<<(SMTLIBv2ParserPK_FunsDescription-66))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-66))|(1<<(SMTLIBv2ParserPK_InteractiveMode-66))|(1<<(SMTLIBv2ParserPK_Language-66))|(1<<(SMTLIBv2ParserPK_LeftAssoc-66))|(1<<(SMTLIBv2ParserPK_License-66))|(1<<(SMTLIBv2ParserPK_Named-66))|(1<<(SMTLIBv2ParserPK_Name-66))|(1<<(SMTLIBv2ParserPK_Notes-66))|(1<<(SMTLIBv2ParserPK_Pattern-66))|(1<<(SMTLIBv2ParserPK_PrintSuccess-66))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-66))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-66))|(1<<(SMTLIBv2ParserPK_ProduceModels-66))|(1<<(SMTLIBv2ParserPK_ProduceProofs-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(SMTLIBv2ParserPK_RandomSeed-98))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-98))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-98))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-98))|(1<<(SMTLIBv2ParserPK_RightAssoc-98))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-98))|(1<<(SMTLIBv2ParserPK_Sorts-98))|(1<<(SMTLIBv2ParserPK_SortsDescription-98))|(1<<(SMTLIBv2ParserPK_Source-98))|(1<<(SMTLIBv2ParserPK_Status-98))|(1<<(SMTLIBv2ParserPK_Theories-98))|(1<<(SMTLIBv2ParserPK_Values-98))|(1<<(SMTLIBv2ParserPK_Verbosity-98))|(1<<(SMTLIBv2ParserPK_Version-98))|(1<<(SMTLIBv2ParserUndefinedSymbol-98)))) != 0) {
			{
				p.SetState(246)
				p.S_expr()
			}

			p.SetState(251)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(252)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexContext is an interface to support dynamic dispatch.
type IIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexContext differentiates from other interfaces.
	IsIndexContext()
}

type IndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexContext() *IndexContext {
	var p = new(IndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_index
	return p
}

func (*IndexContext) IsIndexContext() {}

func NewIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexContext {
	var p = new(IndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_index

	return p
}

func (s *IndexContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *IndexContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *IndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterIndex(s)
	}
}

func (s *IndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitIndex(s)
	}
}

func (s *IndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Index() (localctx IIndexContext) {
	localctx = NewIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SMTLIBv2ParserRULE_index)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(257)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserNumeral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(255)
			p.Numeral()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(256)
			p.Symbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *IdentifierContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *IdentifierContext) GRW_Underscore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Underscore, 0)
}

func (s *IdentifierContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *IdentifierContext) AllIndex() []IIndexContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexContext)(nil)).Elem())
	var tst = make([]IIndexContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexContext)
		}
	}

	return tst
}

func (s *IdentifierContext) Index(i int) IIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SMTLIBv2ParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(270)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(259)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(260)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(261)
			p.Match(SMTLIBv2ParserGRW_Underscore)
		}
		{
			p.SetState(262)
			p.Symbol()
		}
		p.SetState(264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserNumeral || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(263)
				p.Index()
			}

			p.SetState(266)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(268)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribute_valueContext is an interface to support dynamic dispatch.
type IAttribute_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_valueContext differentiates from other interfaces.
	IsAttribute_valueContext()
}

type Attribute_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_valueContext() *Attribute_valueContext {
	var p = new(Attribute_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value
	return p
}

func (*Attribute_valueContext) IsAttribute_valueContext() {}

func NewAttribute_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_valueContext {
	var p = new(Attribute_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value

	return p
}

func (s *Attribute_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_valueContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *Attribute_valueContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Attribute_valueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Attribute_valueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Attribute_valueContext) AllS_expr() []IS_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IS_exprContext)(nil)).Elem())
	var tst = make([]IS_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IS_exprContext)
		}
	}

	return tst
}

func (s *Attribute_valueContext) S_expr(i int) IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Attribute_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterAttribute_value(s)
	}
}

func (s *Attribute_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitAttribute_value(s)
	}
}

func (s *Attribute_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitAttribute_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Attribute_value() (localctx IAttribute_valueContext) {
	localctx = NewAttribute_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SMTLIBv2ParserRULE_attribute_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(282)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserString_, SMTLIBv2ParserNumeral, SMTLIBv2ParserBinary, SMTLIBv2ParserHexDecimal, SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.Spec_constant()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(274)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66))|(1<<(SMTLIBv2ParserColon-66))|(1<<(SMTLIBv2ParserPK_AllStatistics-66))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-66))|(1<<(SMTLIBv2ParserPK_Authors-66))|(1<<(SMTLIBv2ParserPK_Category-66))|(1<<(SMTLIBv2ParserPK_Chainable-66))|(1<<(SMTLIBv2ParserPK_Definition-66))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-66))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-66))|(1<<(SMTLIBv2ParserPK_Extension-66))|(1<<(SMTLIBv2ParserPK_Funs-66))|(1<<(SMTLIBv2ParserPK_FunsDescription-66))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-66))|(1<<(SMTLIBv2ParserPK_InteractiveMode-66))|(1<<(SMTLIBv2ParserPK_Language-66))|(1<<(SMTLIBv2ParserPK_LeftAssoc-66))|(1<<(SMTLIBv2ParserPK_License-66))|(1<<(SMTLIBv2ParserPK_Named-66))|(1<<(SMTLIBv2ParserPK_Name-66))|(1<<(SMTLIBv2ParserPK_Notes-66))|(1<<(SMTLIBv2ParserPK_Pattern-66))|(1<<(SMTLIBv2ParserPK_PrintSuccess-66))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-66))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-66))|(1<<(SMTLIBv2ParserPK_ProduceModels-66))|(1<<(SMTLIBv2ParserPK_ProduceProofs-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(SMTLIBv2ParserPK_RandomSeed-98))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-98))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-98))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-98))|(1<<(SMTLIBv2ParserPK_RightAssoc-98))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-98))|(1<<(SMTLIBv2ParserPK_Sorts-98))|(1<<(SMTLIBv2ParserPK_SortsDescription-98))|(1<<(SMTLIBv2ParserPK_Source-98))|(1<<(SMTLIBv2ParserPK_Status-98))|(1<<(SMTLIBv2ParserPK_Theories-98))|(1<<(SMTLIBv2ParserPK_Values-98))|(1<<(SMTLIBv2ParserPK_Verbosity-98))|(1<<(SMTLIBv2ParserPK_Version-98))|(1<<(SMTLIBv2ParserUndefinedSymbol-98)))) != 0) {
			{
				p.SetState(275)
				p.S_expr()
			}

			p.SetState(280)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(281)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *AttributeContext) Attribute_value() IAttribute_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SMTLIBv2ParserRULE_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(284)
			p.Keyword()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(285)
			p.Keyword()
		}
		{
			p.SetState(286)
			p.Attribute_value()
		}

	}

	return localctx
}

// ISortContext is an interface to support dynamic dispatch.
type ISortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortContext differentiates from other interfaces.
	IsSortContext()
}

type SortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortContext() *SortContext {
	var p = new(SortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort
	return p
}

func (*SortContext) IsSortContext() {}

func NewSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortContext {
	var p = new(SortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort

	return p
}

func (s *SortContext) GetParser() antlr.Parser { return s.parser }

func (s *SortContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SortContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *SortContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *SortContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *SortContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *SortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort(s)
	}
}

func (s *SortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort(s)
	}
}

func (s *SortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort() (localctx ISortContext) {
	localctx = NewSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SMTLIBv2ParserRULE_sort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(290)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(291)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(292)
			p.Identifier()
		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(293)
				p.Sort()
			}

			p.SetState(296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(298)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IQual_identiferContext is an interface to support dynamic dispatch.
type IQual_identiferContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQual_identiferContext differentiates from other interfaces.
	IsQual_identiferContext()
}

type Qual_identiferContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQual_identiferContext() *Qual_identiferContext {
	var p = new(Qual_identiferContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer
	return p
}

func (*Qual_identiferContext) IsQual_identiferContext() {}

func NewQual_identiferContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qual_identiferContext {
	var p = new(Qual_identiferContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer

	return p
}

func (s *Qual_identiferContext) GetParser() antlr.Parser { return s.parser }

func (s *Qual_identiferContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Qual_identiferContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Qual_identiferContext) GRW_As() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_As, 0)
}

func (s *Qual_identiferContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Qual_identiferContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Qual_identiferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qual_identiferContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qual_identiferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterQual_identifer(s)
	}
}

func (s *Qual_identiferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitQual_identifer(s)
	}
}

func (s *Qual_identiferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitQual_identifer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Qual_identifer() (localctx IQual_identiferContext) {
	localctx = NewQual_identiferContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SMTLIBv2ParserRULE_qual_identifer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(302)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(303)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(304)
			p.Match(SMTLIBv2ParserGRW_As)
		}
		{
			p.SetState(305)
			p.Identifier()
		}
		{
			p.SetState(306)
			p.Sort()
		}
		{
			p.SetState(307)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IVar_bindingContext is an interface to support dynamic dispatch.
type IVar_bindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_bindingContext differentiates from other interfaces.
	IsVar_bindingContext()
}

type Var_bindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_bindingContext() *Var_bindingContext {
	var p = new(Var_bindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding
	return p
}

func (*Var_bindingContext) IsVar_bindingContext() {}

func NewVar_bindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_bindingContext {
	var p = new(Var_bindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding

	return p
}

func (s *Var_bindingContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_bindingContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Var_bindingContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Var_bindingContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Var_bindingContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Var_bindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_bindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_bindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterVar_binding(s)
	}
}

func (s *Var_bindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitVar_binding(s)
	}
}

func (s *Var_bindingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitVar_binding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Var_binding() (localctx IVar_bindingContext) {
	localctx = NewVar_bindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SMTLIBv2ParserRULE_var_binding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(311)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(312)
		p.Symbol()
	}
	{
		p.SetState(313)
		p.Term()
	}
	{
		p.SetState(314)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISorted_varContext is an interface to support dynamic dispatch.
type ISorted_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSorted_varContext differentiates from other interfaces.
	IsSorted_varContext()
}

type Sorted_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySorted_varContext() *Sorted_varContext {
	var p = new(Sorted_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var
	return p
}

func (*Sorted_varContext) IsSorted_varContext() {}

func NewSorted_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sorted_varContext {
	var p = new(Sorted_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var

	return p
}

func (s *Sorted_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Sorted_varContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sorted_varContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Sorted_varContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Sorted_varContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sorted_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sorted_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sorted_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSorted_var(s)
	}
}

func (s *Sorted_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSorted_var(s)
	}
}

func (s *Sorted_varContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSorted_var(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sorted_var() (localctx ISorted_varContext) {
	localctx = NewSorted_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SMTLIBv2ParserRULE_sorted_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(316)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(317)
		p.Symbol()
	}
	{
		p.SetState(318)
		p.Sort()
	}
	{
		p.SetState(319)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *PatternContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *PatternContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *PatternContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPattern(s)
	}
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SMTLIBv2ParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(331)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(321)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(322)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(323)
			p.Symbol()
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(324)
				p.Symbol()
			}

			p.SetState(327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(329)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatch_caseContext is an interface to support dynamic dispatch.
type IMatch_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatch_caseContext differentiates from other interfaces.
	IsMatch_caseContext()
}

type Match_caseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_caseContext() *Match_caseContext {
	var p = new(Match_caseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_match_case
	return p
}

func (*Match_caseContext) IsMatch_caseContext() {}

func NewMatch_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_caseContext {
	var p = new(Match_caseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_match_case

	return p
}

func (s *Match_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_caseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Match_caseContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Match_caseContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Match_caseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Match_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterMatch_case(s)
	}
}

func (s *Match_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitMatch_case(s)
	}
}

func (s *Match_caseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitMatch_case(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Match_case() (localctx IMatch_caseContext) {
	localctx = NewMatch_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SMTLIBv2ParserRULE_match_case)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(334)
		p.Pattern()
	}
	{
		p.SetState(335)
		p.Term()
	}
	{
		p.SetState(336)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *TermContext) Qual_identifer() IQual_identiferContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQual_identiferContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQual_identiferContext)
}

func (s *TermContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *TermContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *TermContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *TermContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *TermContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *TermContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GRW_Let() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Let, 0)
}

func (s *TermContext) AllVar_binding() []IVar_bindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVar_bindingContext)(nil)).Elem())
	var tst = make([]IVar_bindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVar_bindingContext)
		}
	}

	return tst
}

func (s *TermContext) Var_binding(i int) IVar_bindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_bindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVar_bindingContext)
}

func (s *TermContext) GRW_Forall() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Forall, 0)
}

func (s *TermContext) AllSorted_var() []ISorted_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISorted_varContext)(nil)).Elem())
	var tst = make([]ISorted_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISorted_varContext)
		}
	}

	return tst
}

func (s *TermContext) Sorted_var(i int) ISorted_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISorted_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *TermContext) GRW_Exists() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exists, 0)
}

func (s *TermContext) GRW_Match() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Match, 0)
}

func (s *TermContext) AllMatch_case() []IMatch_caseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMatch_caseContext)(nil)).Elem())
	var tst = make([]IMatch_caseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMatch_caseContext)
		}
	}

	return tst
}

func (s *TermContext) Match_case(i int) IMatch_caseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatch_caseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMatch_caseContext)
}

func (s *TermContext) GRW_Exclamation() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exclamation, 0)
}

func (s *TermContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *TermContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SMTLIBv2ParserRULE_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(338)
			p.Spec_constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(339)
			p.Qual_identifer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(340)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(341)
			p.Qual_identifer()
		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(342)
				p.Term()
			}

			p.SetState(345)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(347)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(349)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(350)
			p.Match(SMTLIBv2ParserGRW_Let)
		}
		{
			p.SetState(351)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(352)
				p.Var_binding()
			}

			p.SetState(355)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(357)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(358)
			p.Term()
		}
		{
			p.SetState(359)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(361)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(362)
			p.Match(SMTLIBv2ParserGRW_Forall)
		}
		{
			p.SetState(363)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(364)
				p.Sorted_var()
			}

			p.SetState(367)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(369)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(370)
			p.Term()
		}
		{
			p.SetState(371)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(373)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(374)
			p.Match(SMTLIBv2ParserGRW_Exists)
		}
		{
			p.SetState(375)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(376)
				p.Sorted_var()
			}

			p.SetState(379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(381)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(382)
			p.Term()
		}
		{
			p.SetState(383)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(385)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(386)
			p.Match(SMTLIBv2ParserGRW_Match)
		}
		{
			p.SetState(387)
			p.Term()
		}
		{
			p.SetState(388)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(389)
				p.Match_case()
			}

			p.SetState(392)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(394)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(395)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(397)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(398)
			p.Match(SMTLIBv2ParserGRW_Exclamation)
		}
		{
			p.SetState(399)
			p.Term()
		}
		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(400)
				p.Attribute()
			}

			p.SetState(403)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(405)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// ISort_symbol_declContext is an interface to support dynamic dispatch.
type ISort_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSort_symbol_declContext differentiates from other interfaces.
	IsSort_symbol_declContext()
}

type Sort_symbol_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_symbol_declContext() *Sort_symbol_declContext {
	var p = new(Sort_symbol_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl
	return p
}

func (*Sort_symbol_declContext) IsSort_symbol_declContext() {}

func NewSort_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_symbol_declContext {
	var p = new(Sort_symbol_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl

	return p
}

func (s *Sort_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_symbol_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sort_symbol_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Sort_symbol_declContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Sort_symbol_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sort_symbol_declContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *Sort_symbol_declContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Sort_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort_symbol_decl(s)
	}
}

func (s *Sort_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort_symbol_decl(s)
	}
}

func (s *Sort_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort_symbol_decl() (localctx ISort_symbol_declContext) {
	localctx = NewSort_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SMTLIBv2ParserRULE_sort_symbol_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(410)
		p.Identifier()
	}
	{
		p.SetState(411)
		p.Numeral()
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(412)
			p.Attribute()
		}

		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(418)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IMeta_spec_constantContext is an interface to support dynamic dispatch.
type IMeta_spec_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMeta_spec_constantContext differentiates from other interfaces.
	IsMeta_spec_constantContext()
}

type Meta_spec_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeta_spec_constantContext() *Meta_spec_constantContext {
	var p = new(Meta_spec_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant
	return p
}

func (*Meta_spec_constantContext) IsMeta_spec_constantContext() {}

func NewMeta_spec_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Meta_spec_constantContext {
	var p = new(Meta_spec_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant

	return p
}

func (s *Meta_spec_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Meta_spec_constantContext) GRW_Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Numeral, 0)
}

func (s *Meta_spec_constantContext) GRW_Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Decimal, 0)
}

func (s *Meta_spec_constantContext) GRW_String() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_String, 0)
}

func (s *Meta_spec_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Meta_spec_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Meta_spec_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterMeta_spec_constant(s)
	}
}

func (s *Meta_spec_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitMeta_spec_constant(s)
	}
}

func (s *Meta_spec_constantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitMeta_spec_constant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Meta_spec_constant() (localctx IMeta_spec_constantContext) {
	localctx = NewMeta_spec_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SMTLIBv2ParserRULE_meta_spec_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SMTLIBv2ParserGRW_Decimal-57))|(1<<(SMTLIBv2ParserGRW_Numeral-57))|(1<<(SMTLIBv2ParserGRW_String-57)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFun_symbol_declContext is an interface to support dynamic dispatch.
type IFun_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFun_symbol_declContext differentiates from other interfaces.
	IsFun_symbol_declContext()
}

type Fun_symbol_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFun_symbol_declContext() *Fun_symbol_declContext {
	var p = new(Fun_symbol_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl
	return p
}

func (*Fun_symbol_declContext) IsFun_symbol_declContext() {}

func NewFun_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fun_symbol_declContext {
	var p = new(Fun_symbol_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl

	return p
}

func (s *Fun_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Fun_symbol_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Fun_symbol_declContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *Fun_symbol_declContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *Fun_symbol_declContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Fun_symbol_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Fun_symbol_declContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *Fun_symbol_declContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Fun_symbol_declContext) Meta_spec_constant() IMeta_spec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMeta_spec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMeta_spec_constantContext)
}

func (s *Fun_symbol_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Fun_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fun_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fun_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFun_symbol_decl(s)
	}
}

func (s *Fun_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFun_symbol_decl(s)
	}
}

func (s *Fun_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFun_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Fun_symbol_decl() (localctx IFun_symbol_declContext) {
	localctx = NewFun_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SMTLIBv2ParserRULE_fun_symbol_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(422)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(423)
			p.Spec_constant()
		}
		{
			p.SetState(424)
			p.Sort()
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(425)
				p.Attribute()
			}

			p.SetState(430)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(431)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(434)
			p.Meta_spec_constant()
		}
		{
			p.SetState(435)
			p.Sort()
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(436)
				p.Attribute()
			}

			p.SetState(441)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(442)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(444)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(445)
			p.Identifier()
		}
		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(446)
				p.Sort()
			}

			p.SetState(449)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(451)
				p.Attribute()
			}

			p.SetState(456)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(457)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IPar_fun_symbol_declContext is an interface to support dynamic dispatch.
type IPar_fun_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_fun_symbol_declContext differentiates from other interfaces.
	IsPar_fun_symbol_declContext()
}

type Par_fun_symbol_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_fun_symbol_declContext() *Par_fun_symbol_declContext {
	var p = new(Par_fun_symbol_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl
	return p
}

func (*Par_fun_symbol_declContext) IsPar_fun_symbol_declContext() {}

func NewPar_fun_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_fun_symbol_declContext {
	var p = new(Par_fun_symbol_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl

	return p
}

func (s *Par_fun_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_fun_symbol_declContext) Fun_symbol_decl() IFun_symbol_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFun_symbol_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFun_symbol_declContext)
}

func (s *Par_fun_symbol_declContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Par_fun_symbol_declContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Par_fun_symbol_declContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *Par_fun_symbol_declContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Par_fun_symbol_declContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Par_fun_symbol_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Par_fun_symbol_declContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Par_fun_symbol_declContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Par_fun_symbol_declContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Par_fun_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_fun_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_fun_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPar_fun_symbol_decl(s)
	}
}

func (s *Par_fun_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPar_fun_symbol_decl(s)
	}
}

func (s *Par_fun_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPar_fun_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Par_fun_symbol_decl() (localctx IPar_fun_symbol_declContext) {
	localctx = NewPar_fun_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SMTLIBv2ParserRULE_par_fun_symbol_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(461)
			p.Fun_symbol_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(462)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(463)
			p.Match(SMTLIBv2ParserGRW_Par)
		}
		{
			p.SetState(464)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(465)
				p.Symbol()
			}

			p.SetState(468)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(470)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(471)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(472)
			p.Identifier()
		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(473)
				p.Sort()
			}

			p.SetState(476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(478)
				p.Attribute()
			}

			p.SetState(483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(484)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(485)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// ITheory_attributeContext is an interface to support dynamic dispatch.
type ITheory_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTheory_attributeContext differentiates from other interfaces.
	IsTheory_attributeContext()
}

type Theory_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_attributeContext() *Theory_attributeContext {
	var p = new(Theory_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute
	return p
}

func (*Theory_attributeContext) IsTheory_attributeContext() {}

func NewTheory_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_attributeContext {
	var p = new(Theory_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute

	return p
}

func (s *Theory_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_attributeContext) PK_Sorts() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Sorts, 0)
}

func (s *Theory_attributeContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Theory_attributeContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Theory_attributeContext) AllSort_symbol_decl() []ISort_symbol_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISort_symbol_declContext)(nil)).Elem())
	var tst = make([]ISort_symbol_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISort_symbol_declContext)
		}
	}

	return tst
}

func (s *Theory_attributeContext) Sort_symbol_decl(i int) ISort_symbol_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISort_symbol_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISort_symbol_declContext)
}

func (s *Theory_attributeContext) PK_Funs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Funs, 0)
}

func (s *Theory_attributeContext) AllPar_fun_symbol_decl() []IPar_fun_symbol_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPar_fun_symbol_declContext)(nil)).Elem())
	var tst = make([]IPar_fun_symbol_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPar_fun_symbol_declContext)
		}
	}

	return tst
}

func (s *Theory_attributeContext) Par_fun_symbol_decl(i int) IPar_fun_symbol_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_fun_symbol_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPar_fun_symbol_declContext)
}

func (s *Theory_attributeContext) PK_SortsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SortsDescription, 0)
}

func (s *Theory_attributeContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Theory_attributeContext) PK_FunsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_FunsDescription, 0)
}

func (s *Theory_attributeContext) PK_Definition() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Definition, 0)
}

func (s *Theory_attributeContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *Theory_attributeContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *Theory_attributeContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Theory_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTheory_attribute(s)
	}
}

func (s *Theory_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTheory_attribute(s)
	}
}

func (s *Theory_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTheory_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Theory_attribute() (localctx ITheory_attributeContext) {
	localctx = NewTheory_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SMTLIBv2ParserRULE_theory_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(489)
			p.Match(SMTLIBv2ParserPK_Sorts)
		}
		{
			p.SetState(490)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(491)
				p.Sort_symbol_decl()
			}

			p.SetState(494)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(496)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(498)
			p.Match(SMTLIBv2ParserPK_Funs)
		}
		{
			p.SetState(499)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(500)
				p.Par_fun_symbol_decl()
			}

			p.SetState(503)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(505)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(507)
			p.Match(SMTLIBv2ParserPK_SortsDescription)
		}
		{
			p.SetState(508)
			p.String_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(509)
			p.Match(SMTLIBv2ParserPK_FunsDescription)
		}
		{
			p.SetState(510)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(511)
			p.Match(SMTLIBv2ParserPK_Definition)
		}
		{
			p.SetState(512)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(513)
			p.Match(SMTLIBv2ParserPK_Values)
		}
		{
			p.SetState(514)
			p.String_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(515)
			p.Match(SMTLIBv2ParserPK_Notes)
		}
		{
			p.SetState(516)
			p.String_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(517)
			p.Attribute()
		}

	}

	return localctx
}

// ITheory_declContext is an interface to support dynamic dispatch.
type ITheory_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTheory_declContext differentiates from other interfaces.
	IsTheory_declContext()
}

type Theory_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_declContext() *Theory_declContext {
	var p = new(Theory_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl
	return p
}

func (*Theory_declContext) IsTheory_declContext() {}

func NewTheory_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_declContext {
	var p = new(Theory_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl

	return p
}

func (s *Theory_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Theory_declContext) PS_Theory() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Theory, 0)
}

func (s *Theory_declContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Theory_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Theory_declContext) AllTheory_attribute() []ITheory_attributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITheory_attributeContext)(nil)).Elem())
	var tst = make([]ITheory_attributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITheory_attributeContext)
		}
	}

	return tst
}

func (s *Theory_declContext) Theory_attribute(i int) ITheory_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITheory_attributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITheory_attributeContext)
}

func (s *Theory_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTheory_decl(s)
	}
}

func (s *Theory_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTheory_decl(s)
	}
}

func (s *Theory_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTheory_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Theory_decl() (localctx ITheory_declContext) {
	localctx = NewTheory_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SMTLIBv2ParserRULE_theory_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(521)
		p.Match(SMTLIBv2ParserPS_Theory)
	}
	{
		p.SetState(522)
		p.Symbol()
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(523)
			p.Theory_attribute()
		}

		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(528)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ILogic_attribueContext is an interface to support dynamic dispatch.
type ILogic_attribueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogic_attribueContext differentiates from other interfaces.
	IsLogic_attribueContext()
}

type Logic_attribueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogic_attribueContext() *Logic_attribueContext {
	var p = new(Logic_attribueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue
	return p
}

func (*Logic_attribueContext) IsLogic_attribueContext() {}

func NewLogic_attribueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logic_attribueContext {
	var p = new(Logic_attribueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue

	return p
}

func (s *Logic_attribueContext) GetParser() antlr.Parser { return s.parser }

func (s *Logic_attribueContext) PK_Theories() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Theories, 0)
}

func (s *Logic_attribueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Logic_attribueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Logic_attribueContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Logic_attribueContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Logic_attribueContext) PK_Language() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Language, 0)
}

func (s *Logic_attribueContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Logic_attribueContext) PK_Extension() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Extension, 0)
}

func (s *Logic_attribueContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *Logic_attribueContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *Logic_attribueContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Logic_attribueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logic_attribueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logic_attribueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterLogic_attribue(s)
	}
}

func (s *Logic_attribueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitLogic_attribue(s)
	}
}

func (s *Logic_attribueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitLogic_attribue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Logic_attribue() (localctx ILogic_attribueContext) {
	localctx = NewLogic_attribueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SMTLIBv2ParserRULE_logic_attribue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(530)
			p.Match(SMTLIBv2ParserPK_Theories)
		}
		{
			p.SetState(531)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(532)
				p.Symbol()
			}

			p.SetState(535)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(537)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(539)
			p.Match(SMTLIBv2ParserPK_Language)
		}
		{
			p.SetState(540)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(541)
			p.Match(SMTLIBv2ParserPK_Extension)
		}
		{
			p.SetState(542)
			p.String_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(543)
			p.Match(SMTLIBv2ParserPK_Values)
		}
		{
			p.SetState(544)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(545)
			p.Match(SMTLIBv2ParserPK_Notes)
		}
		{
			p.SetState(546)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(547)
			p.Attribute()
		}

	}

	return localctx
}

// ILogicContext is an interface to support dynamic dispatch.
type ILogicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicContext differentiates from other interfaces.
	IsLogicContext()
}

type LogicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicContext() *LogicContext {
	var p = new(LogicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic
	return p
}

func (*LogicContext) IsLogicContext() {}

func NewLogicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicContext {
	var p = new(LogicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_logic

	return p
}

func (s *LogicContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *LogicContext) PS_Logic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Logic, 0)
}

func (s *LogicContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *LogicContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *LogicContext) AllLogic_attribue() []ILogic_attribueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogic_attribueContext)(nil)).Elem())
	var tst = make([]ILogic_attribueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogic_attribueContext)
		}
	}

	return tst
}

func (s *LogicContext) Logic_attribue(i int) ILogic_attribueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_attribueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogic_attribueContext)
}

func (s *LogicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterLogic(s)
	}
}

func (s *LogicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitLogic(s)
	}
}

func (s *LogicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitLogic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Logic() (localctx ILogicContext) {
	localctx = NewLogicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SMTLIBv2ParserRULE_logic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(551)
		p.Match(SMTLIBv2ParserPS_Logic)
	}
	{
		p.SetState(552)
		p.Symbol()
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(553)
			p.Logic_attribue()
		}

		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(558)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISort_decContext is an interface to support dynamic dispatch.
type ISort_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSort_decContext differentiates from other interfaces.
	IsSort_decContext()
}

type Sort_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_decContext() *Sort_decContext {
	var p = new(Sort_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec
	return p
}

func (*Sort_decContext) IsSort_decContext() {}

func NewSort_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_decContext {
	var p = new(Sort_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec

	return p
}

func (s *Sort_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sort_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Sort_decContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Sort_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sort_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort_dec(s)
	}
}

func (s *Sort_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort_dec(s)
	}
}

func (s *Sort_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort_dec() (localctx ISort_decContext) {
	localctx = NewSort_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SMTLIBv2ParserRULE_sort_dec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(561)
		p.Symbol()
	}
	{
		p.SetState(562)
		p.Numeral()
	}
	{
		p.SetState(563)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISelector_decContext is an interface to support dynamic dispatch.
type ISelector_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelector_decContext differentiates from other interfaces.
	IsSelector_decContext()
}

type Selector_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_decContext() *Selector_decContext {
	var p = new(Selector_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec
	return p
}

func (*Selector_decContext) IsSelector_decContext() {}

func NewSelector_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_decContext {
	var p = new(Selector_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec

	return p
}

func (s *Selector_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Selector_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Selector_decContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Selector_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Selector_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selector_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSelector_dec(s)
	}
}

func (s *Selector_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSelector_dec(s)
	}
}

func (s *Selector_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSelector_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Selector_dec() (localctx ISelector_decContext) {
	localctx = NewSelector_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SMTLIBv2ParserRULE_selector_dec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(566)
		p.Symbol()
	}
	{
		p.SetState(567)
		p.Sort()
	}
	{
		p.SetState(568)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IConstructor_decContext is an interface to support dynamic dispatch.
type IConstructor_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_decContext differentiates from other interfaces.
	IsConstructor_decContext()
}

type Constructor_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_decContext() *Constructor_decContext {
	var p = new(Constructor_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec
	return p
}

func (*Constructor_decContext) IsConstructor_decContext() {}

func NewConstructor_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_decContext {
	var p = new(Constructor_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec

	return p
}

func (s *Constructor_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Constructor_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Constructor_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Constructor_decContext) AllSelector_dec() []ISelector_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelector_decContext)(nil)).Elem())
	var tst = make([]ISelector_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelector_decContext)
		}
	}

	return tst
}

func (s *Constructor_decContext) Selector_dec(i int) ISelector_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelector_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelector_decContext)
}

func (s *Constructor_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterConstructor_dec(s)
	}
}

func (s *Constructor_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitConstructor_dec(s)
	}
}

func (s *Constructor_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitConstructor_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Constructor_dec() (localctx IConstructor_decContext) {
	localctx = NewConstructor_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SMTLIBv2ParserRULE_constructor_dec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(571)
		p.Symbol()
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(572)
			p.Selector_dec()
		}

		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(578)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IDatatype_decContext is an interface to support dynamic dispatch.
type IDatatype_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatatype_decContext differentiates from other interfaces.
	IsDatatype_decContext()
}

type Datatype_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatype_decContext() *Datatype_decContext {
	var p = new(Datatype_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec
	return p
}

func (*Datatype_decContext) IsDatatype_decContext() {}

func NewDatatype_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datatype_decContext {
	var p = new(Datatype_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec

	return p
}

func (s *Datatype_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Datatype_decContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Datatype_decContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Datatype_decContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Datatype_decContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Datatype_decContext) AllConstructor_dec() []IConstructor_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstructor_decContext)(nil)).Elem())
	var tst = make([]IConstructor_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstructor_decContext)
		}
	}

	return tst
}

func (s *Datatype_decContext) Constructor_dec(i int) IConstructor_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstructor_decContext)
}

func (s *Datatype_decContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *Datatype_decContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Datatype_decContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Datatype_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datatype_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datatype_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterDatatype_dec(s)
	}
}

func (s *Datatype_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitDatatype_dec(s)
	}
}

func (s *Datatype_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitDatatype_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Datatype_dec() (localctx IDatatype_decContext) {
	localctx = NewDatatype_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SMTLIBv2ParserRULE_datatype_dec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(580)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(581)
				p.Constructor_dec()
			}

			p.SetState(584)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(586)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(588)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(589)
			p.Match(SMTLIBv2ParserGRW_Par)
		}
		{
			p.SetState(590)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(591)
				p.Symbol()
			}

			p.SetState(594)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(596)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(597)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(598)
				p.Constructor_dec()
			}

			p.SetState(601)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(603)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(604)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IFunction_decContext is an interface to support dynamic dispatch.
type IFunction_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_decContext differentiates from other interfaces.
	IsFunction_decContext()
}

type Function_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_decContext() *Function_decContext {
	var p = new(Function_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec
	return p
}

func (*Function_decContext) IsFunction_decContext() {}

func NewFunction_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_decContext {
	var p = new(Function_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec

	return p
}

func (s *Function_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_decContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Function_decContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Function_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Function_decContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Function_decContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Function_decContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Function_decContext) AllSorted_var() []ISorted_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISorted_varContext)(nil)).Elem())
	var tst = make([]ISorted_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISorted_varContext)
		}
	}

	return tst
}

func (s *Function_decContext) Sorted_var(i int) ISorted_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISorted_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *Function_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFunction_dec(s)
	}
}

func (s *Function_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFunction_dec(s)
	}
}

func (s *Function_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFunction_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Function_dec() (localctx IFunction_decContext) {
	localctx = NewFunction_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SMTLIBv2ParserRULE_function_dec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(609)
		p.Symbol()
	}
	{
		p.SetState(610)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(611)
			p.Sorted_var()
		}

		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(617)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(618)
		p.Sort()
	}
	{
		p.SetState(619)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IFunction_defContext is an interface to support dynamic dispatch.
type IFunction_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_defContext differentiates from other interfaces.
	IsFunction_defContext()
}

type Function_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_defContext() *Function_defContext {
	var p = new(Function_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_def
	return p
}

func (*Function_defContext) IsFunction_defContext() {}

func NewFunction_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_defContext {
	var p = new(Function_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_function_def

	return p
}

func (s *Function_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_defContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Function_defContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Function_defContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Function_defContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Function_defContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Function_defContext) AllSorted_var() []ISorted_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISorted_varContext)(nil)).Elem())
	var tst = make([]ISorted_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISorted_varContext)
		}
	}

	return tst
}

func (s *Function_defContext) Sorted_var(i int) ISorted_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISorted_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *Function_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFunction_def(s)
	}
}

func (s *Function_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFunction_def(s)
	}
}

func (s *Function_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFunction_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Function_def() (localctx IFunction_defContext) {
	localctx = NewFunction_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SMTLIBv2ParserRULE_function_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Symbol()
	}
	{
		p.SetState(622)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(623)
			p.Sorted_var()
		}

		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(629)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(630)
		p.Sort()
	}
	{
		p.SetState(631)
		p.Term()
	}

	return localctx
}

// IProp_literalContext is an interface to support dynamic dispatch.
type IProp_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProp_literalContext differentiates from other interfaces.
	IsProp_literalContext()
}

type Prop_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProp_literalContext() *Prop_literalContext {
	var p = new(Prop_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal
	return p
}

func (*Prop_literalContext) IsProp_literalContext() {}

func NewProp_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Prop_literalContext {
	var p = new(Prop_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal

	return p
}

func (s *Prop_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Prop_literalContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Prop_literalContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Prop_literalContext) PS_Not() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Not, 0)
}

func (s *Prop_literalContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Prop_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Prop_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Prop_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterProp_literal(s)
	}
}

func (s *Prop_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitProp_literal(s)
	}
}

func (s *Prop_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitProp_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Prop_literal() (localctx IProp_literalContext) {
	localctx = NewProp_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SMTLIBv2ParserRULE_prop_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(633)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(634)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(635)
			p.Match(SMTLIBv2ParserPS_Not)
		}
		{
			p.SetState(636)
			p.Symbol()
		}
		{
			p.SetState(637)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_script
	return p
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) AllCommand() []ICommandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommandContext)(nil)).Elem())
	var tst = make([]ICommandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommandContext)
		}
	}

	return tst
}

func (s *ScriptContext) Command(i int) ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitScript(s)
	}
}

func (s *ScriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitScript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SMTLIBv2ParserRULE_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(641)
			p.Command()
		}

		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICmd_assertContext is an interface to support dynamic dispatch.
type ICmd_assertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_assertContext differentiates from other interfaces.
	IsCmd_assertContext()
}

type Cmd_assertContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_assertContext() *Cmd_assertContext {
	var p = new(Cmd_assertContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert
	return p
}

func (*Cmd_assertContext) IsCmd_assertContext() {}

func NewCmd_assertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_assertContext {
	var p = new(Cmd_assertContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert

	return p
}

func (s *Cmd_assertContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_assertContext) CMD_Assert() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Assert, 0)
}

func (s *Cmd_assertContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_assertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_assertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_assertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_assert(s)
	}
}

func (s *Cmd_assertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_assert(s)
	}
}

func (s *Cmd_assertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_assert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_assert() (localctx ICmd_assertContext) {
	localctx = NewCmd_assertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SMTLIBv2ParserRULE_cmd_assert)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(SMTLIBv2ParserCMD_Assert)
	}
	{
		p.SetState(648)
		p.Term()
	}

	return localctx
}

// ICmd_checkSatContext is an interface to support dynamic dispatch.
type ICmd_checkSatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_checkSatContext differentiates from other interfaces.
	IsCmd_checkSatContext()
}

type Cmd_checkSatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_checkSatContext() *Cmd_checkSatContext {
	var p = new(Cmd_checkSatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat
	return p
}

func (*Cmd_checkSatContext) IsCmd_checkSatContext() {}

func NewCmd_checkSatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_checkSatContext {
	var p = new(Cmd_checkSatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat

	return p
}

func (s *Cmd_checkSatContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_checkSatContext) CMD_CheckSat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_CheckSat, 0)
}

func (s *Cmd_checkSatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_checkSatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_checkSatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_checkSat(s)
	}
}

func (s *Cmd_checkSatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_checkSat(s)
	}
}

func (s *Cmd_checkSatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_checkSat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_checkSat() (localctx ICmd_checkSatContext) {
	localctx = NewCmd_checkSatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SMTLIBv2ParserRULE_cmd_checkSat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(SMTLIBv2ParserCMD_CheckSat)
	}

	return localctx
}

// ICmd_checkSatAssumingContext is an interface to support dynamic dispatch.
type ICmd_checkSatAssumingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_checkSatAssumingContext differentiates from other interfaces.
	IsCmd_checkSatAssumingContext()
}

type Cmd_checkSatAssumingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_checkSatAssumingContext() *Cmd_checkSatAssumingContext {
	var p = new(Cmd_checkSatAssumingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming
	return p
}

func (*Cmd_checkSatAssumingContext) IsCmd_checkSatAssumingContext() {}

func NewCmd_checkSatAssumingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_checkSatAssumingContext {
	var p = new(Cmd_checkSatAssumingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming

	return p
}

func (s *Cmd_checkSatAssumingContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_checkSatAssumingContext) CMD_CheckSatAssuming() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_CheckSatAssuming, 0)
}

func (s *Cmd_checkSatAssumingContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_checkSatAssumingContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_checkSatAssumingContext) AllProp_literal() []IProp_literalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProp_literalContext)(nil)).Elem())
	var tst = make([]IProp_literalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProp_literalContext)
		}
	}

	return tst
}

func (s *Cmd_checkSatAssumingContext) Prop_literal(i int) IProp_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProp_literalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProp_literalContext)
}

func (s *Cmd_checkSatAssumingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_checkSatAssumingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_checkSatAssumingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_checkSatAssuming(s)
	}
}

func (s *Cmd_checkSatAssumingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_checkSatAssuming(s)
	}
}

func (s *Cmd_checkSatAssumingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_checkSatAssuming(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_checkSatAssuming() (localctx ICmd_checkSatAssumingContext) {
	localctx = NewCmd_checkSatAssumingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SMTLIBv2ParserRULE_cmd_checkSatAssuming)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Match(SMTLIBv2ParserCMD_CheckSatAssuming)
	}
	{
		p.SetState(653)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(654)
			p.Prop_literal()
		}

		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(660)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_declareConstContext is an interface to support dynamic dispatch.
type ICmd_declareConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareConstContext differentiates from other interfaces.
	IsCmd_declareConstContext()
}

type Cmd_declareConstContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareConstContext() *Cmd_declareConstContext {
	var p = new(Cmd_declareConstContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst
	return p
}

func (*Cmd_declareConstContext) IsCmd_declareConstContext() {}

func NewCmd_declareConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareConstContext {
	var p = new(Cmd_declareConstContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst

	return p
}

func (s *Cmd_declareConstContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareConstContext) CMD_DeclareConst() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareConst, 0)
}

func (s *Cmd_declareConstContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareConstContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_declareConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareConst(s)
	}
}

func (s *Cmd_declareConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareConst(s)
	}
}

func (s *Cmd_declareConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareConst() (localctx ICmd_declareConstContext) {
	localctx = NewCmd_declareConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SMTLIBv2ParserRULE_cmd_declareConst)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(SMTLIBv2ParserCMD_DeclareConst)
	}
	{
		p.SetState(663)
		p.Symbol()
	}
	{
		p.SetState(664)
		p.Sort()
	}

	return localctx
}

// ICmd_declareDatatypeContext is an interface to support dynamic dispatch.
type ICmd_declareDatatypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareDatatypeContext differentiates from other interfaces.
	IsCmd_declareDatatypeContext()
}

type Cmd_declareDatatypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareDatatypeContext() *Cmd_declareDatatypeContext {
	var p = new(Cmd_declareDatatypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype
	return p
}

func (*Cmd_declareDatatypeContext) IsCmd_declareDatatypeContext() {}

func NewCmd_declareDatatypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareDatatypeContext {
	var p = new(Cmd_declareDatatypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype

	return p
}

func (s *Cmd_declareDatatypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareDatatypeContext) CMD_DeclareDatatype() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareDatatype, 0)
}

func (s *Cmd_declareDatatypeContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareDatatypeContext) Datatype_dec() IDatatype_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatype_decContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatatype_decContext)
}

func (s *Cmd_declareDatatypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareDatatypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareDatatypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareDatatype(s)
	}
}

func (s *Cmd_declareDatatypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareDatatype(s)
	}
}

func (s *Cmd_declareDatatypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareDatatype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareDatatype() (localctx ICmd_declareDatatypeContext) {
	localctx = NewCmd_declareDatatypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SMTLIBv2ParserRULE_cmd_declareDatatype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(SMTLIBv2ParserCMD_DeclareDatatype)
	}
	{
		p.SetState(667)
		p.Symbol()
	}
	{
		p.SetState(668)
		p.Datatype_dec()
	}

	return localctx
}

// ICmd_declareDatatypesContext is an interface to support dynamic dispatch.
type ICmd_declareDatatypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareDatatypesContext differentiates from other interfaces.
	IsCmd_declareDatatypesContext()
}

type Cmd_declareDatatypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareDatatypesContext() *Cmd_declareDatatypesContext {
	var p = new(Cmd_declareDatatypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes
	return p
}

func (*Cmd_declareDatatypesContext) IsCmd_declareDatatypesContext() {}

func NewCmd_declareDatatypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareDatatypesContext {
	var p = new(Cmd_declareDatatypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes

	return p
}

func (s *Cmd_declareDatatypesContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareDatatypesContext) CMD_DeclareDatatypes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareDatatypes, 0)
}

func (s *Cmd_declareDatatypesContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Cmd_declareDatatypesContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Cmd_declareDatatypesContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Cmd_declareDatatypesContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Cmd_declareDatatypesContext) AllSort_dec() []ISort_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISort_decContext)(nil)).Elem())
	var tst = make([]ISort_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISort_decContext)
		}
	}

	return tst
}

func (s *Cmd_declareDatatypesContext) Sort_dec(i int) ISort_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISort_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISort_decContext)
}

func (s *Cmd_declareDatatypesContext) AllDatatype_dec() []IDatatype_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatatype_decContext)(nil)).Elem())
	var tst = make([]IDatatype_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatatype_decContext)
		}
	}

	return tst
}

func (s *Cmd_declareDatatypesContext) Datatype_dec(i int) IDatatype_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatype_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatatype_decContext)
}

func (s *Cmd_declareDatatypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareDatatypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareDatatypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareDatatypes(s)
	}
}

func (s *Cmd_declareDatatypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareDatatypes(s)
	}
}

func (s *Cmd_declareDatatypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareDatatypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareDatatypes() (localctx ICmd_declareDatatypesContext) {
	localctx = NewCmd_declareDatatypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SMTLIBv2ParserRULE_cmd_declareDatatypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(SMTLIBv2ParserCMD_DeclareDatatypes)
	}
	{
		p.SetState(671)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(672)
			p.Sort_dec()
		}

		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(677)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(678)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(679)
			p.Datatype_dec()
		}

		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(684)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_declareFunContext is an interface to support dynamic dispatch.
type ICmd_declareFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareFunContext differentiates from other interfaces.
	IsCmd_declareFunContext()
}

type Cmd_declareFunContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareFunContext() *Cmd_declareFunContext {
	var p = new(Cmd_declareFunContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun
	return p
}

func (*Cmd_declareFunContext) IsCmd_declareFunContext() {}

func NewCmd_declareFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareFunContext {
	var p = new(Cmd_declareFunContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun

	return p
}

func (s *Cmd_declareFunContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareFunContext) CMD_DeclareFun() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareFun, 0)
}

func (s *Cmd_declareFunContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareFunContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_declareFunContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_declareFunContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *Cmd_declareFunContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_declareFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareFun(s)
	}
}

func (s *Cmd_declareFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareFun(s)
	}
}

func (s *Cmd_declareFunContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareFun(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareFun() (localctx ICmd_declareFunContext) {
	localctx = NewCmd_declareFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SMTLIBv2ParserRULE_cmd_declareFun)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(SMTLIBv2ParserCMD_DeclareFun)
	}
	{
		p.SetState(687)
		p.Symbol()
	}
	{
		p.SetState(688)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(689)
			p.Sort()
		}

		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(695)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(696)
		p.Sort()
	}

	return localctx
}

// ICmd_declareSortContext is an interface to support dynamic dispatch.
type ICmd_declareSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareSortContext differentiates from other interfaces.
	IsCmd_declareSortContext()
}

type Cmd_declareSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareSortContext() *Cmd_declareSortContext {
	var p = new(Cmd_declareSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort
	return p
}

func (*Cmd_declareSortContext) IsCmd_declareSortContext() {}

func NewCmd_declareSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareSortContext {
	var p = new(Cmd_declareSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort

	return p
}

func (s *Cmd_declareSortContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareSortContext) CMD_DeclareSort() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareSort, 0)
}

func (s *Cmd_declareSortContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareSortContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_declareSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareSort(s)
	}
}

func (s *Cmd_declareSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareSort(s)
	}
}

func (s *Cmd_declareSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareSort() (localctx ICmd_declareSortContext) {
	localctx = NewCmd_declareSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SMTLIBv2ParserRULE_cmd_declareSort)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(SMTLIBv2ParserCMD_DeclareSort)
	}
	{
		p.SetState(699)
		p.Symbol()
	}
	{
		p.SetState(700)
		p.Numeral()
	}

	return localctx
}

// ICmd_defineFunContext is an interface to support dynamic dispatch.
type ICmd_defineFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineFunContext differentiates from other interfaces.
	IsCmd_defineFunContext()
}

type Cmd_defineFunContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunContext() *Cmd_defineFunContext {
	var p = new(Cmd_defineFunContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun
	return p
}

func (*Cmd_defineFunContext) IsCmd_defineFunContext() {}

func NewCmd_defineFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunContext {
	var p = new(Cmd_defineFunContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun

	return p
}

func (s *Cmd_defineFunContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunContext) CMD_DefineFun() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFun, 0)
}

func (s *Cmd_defineFunContext) Function_def() IFunction_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_defContext)
}

func (s *Cmd_defineFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFun(s)
	}
}

func (s *Cmd_defineFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFun(s)
	}
}

func (s *Cmd_defineFunContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFun(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFun() (localctx ICmd_defineFunContext) {
	localctx = NewCmd_defineFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SMTLIBv2ParserRULE_cmd_defineFun)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(SMTLIBv2ParserCMD_DefineFun)
	}
	{
		p.SetState(703)
		p.Function_def()
	}

	return localctx
}

// ICmd_defineFunRecContext is an interface to support dynamic dispatch.
type ICmd_defineFunRecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineFunRecContext differentiates from other interfaces.
	IsCmd_defineFunRecContext()
}

type Cmd_defineFunRecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunRecContext() *Cmd_defineFunRecContext {
	var p = new(Cmd_defineFunRecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec
	return p
}

func (*Cmd_defineFunRecContext) IsCmd_defineFunRecContext() {}

func NewCmd_defineFunRecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunRecContext {
	var p = new(Cmd_defineFunRecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec

	return p
}

func (s *Cmd_defineFunRecContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunRecContext) CMD_DefineFunRec() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFunRec, 0)
}

func (s *Cmd_defineFunRecContext) Function_def() IFunction_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_defContext)
}

func (s *Cmd_defineFunRecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunRecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunRecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFunRec(s)
	}
}

func (s *Cmd_defineFunRecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFunRec(s)
	}
}

func (s *Cmd_defineFunRecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFunRec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFunRec() (localctx ICmd_defineFunRecContext) {
	localctx = NewCmd_defineFunRecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SMTLIBv2ParserRULE_cmd_defineFunRec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Match(SMTLIBv2ParserCMD_DefineFunRec)
	}
	{
		p.SetState(706)
		p.Function_def()
	}

	return localctx
}

// ICmd_defineFunsRecContext is an interface to support dynamic dispatch.
type ICmd_defineFunsRecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineFunsRecContext differentiates from other interfaces.
	IsCmd_defineFunsRecContext()
}

type Cmd_defineFunsRecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunsRecContext() *Cmd_defineFunsRecContext {
	var p = new(Cmd_defineFunsRecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec
	return p
}

func (*Cmd_defineFunsRecContext) IsCmd_defineFunsRecContext() {}

func NewCmd_defineFunsRecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunsRecContext {
	var p = new(Cmd_defineFunsRecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec

	return p
}

func (s *Cmd_defineFunsRecContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunsRecContext) CMD_DefineFunsRec() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFunsRec, 0)
}

func (s *Cmd_defineFunsRecContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Cmd_defineFunsRecContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Cmd_defineFunsRecContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Cmd_defineFunsRecContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Cmd_defineFunsRecContext) AllFunction_dec() []IFunction_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_decContext)(nil)).Elem())
	var tst = make([]IFunction_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_decContext)
		}
	}

	return tst
}

func (s *Cmd_defineFunsRecContext) Function_dec(i int) IFunction_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_decContext)
}

func (s *Cmd_defineFunsRecContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Cmd_defineFunsRecContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_defineFunsRecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunsRecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunsRecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFunsRec(s)
	}
}

func (s *Cmd_defineFunsRecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFunsRec(s)
	}
}

func (s *Cmd_defineFunsRecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFunsRec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFunsRec() (localctx ICmd_defineFunsRecContext) {
	localctx = NewCmd_defineFunsRecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SMTLIBv2ParserRULE_cmd_defineFunsRec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(SMTLIBv2ParserCMD_DefineFunsRec)
	}
	{
		p.SetState(709)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(710)
			p.Function_dec()
		}

		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(715)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(716)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(717)
			p.Term()
		}

		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(722)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_defineSortContext is an interface to support dynamic dispatch.
type ICmd_defineSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineSortContext differentiates from other interfaces.
	IsCmd_defineSortContext()
}

type Cmd_defineSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineSortContext() *Cmd_defineSortContext {
	var p = new(Cmd_defineSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort
	return p
}

func (*Cmd_defineSortContext) IsCmd_defineSortContext() {}

func NewCmd_defineSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineSortContext {
	var p = new(Cmd_defineSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort

	return p
}

func (s *Cmd_defineSortContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineSortContext) CMD_DefineSort() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineSort, 0)
}

func (s *Cmd_defineSortContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Cmd_defineSortContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_defineSortContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_defineSortContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_defineSortContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_defineSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineSort(s)
	}
}

func (s *Cmd_defineSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineSort(s)
	}
}

func (s *Cmd_defineSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineSort() (localctx ICmd_defineSortContext) {
	localctx = NewCmd_defineSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SMTLIBv2ParserRULE_cmd_defineSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.Match(SMTLIBv2ParserCMD_DefineSort)
	}
	{
		p.SetState(725)
		p.Symbol()
	}
	{
		p.SetState(726)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(727)
			p.Symbol()
		}

		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(733)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(734)
		p.Sort()
	}

	return localctx
}

// ICmd_echoContext is an interface to support dynamic dispatch.
type ICmd_echoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_echoContext differentiates from other interfaces.
	IsCmd_echoContext()
}

type Cmd_echoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_echoContext() *Cmd_echoContext {
	var p = new(Cmd_echoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo
	return p
}

func (*Cmd_echoContext) IsCmd_echoContext() {}

func NewCmd_echoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_echoContext {
	var p = new(Cmd_echoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo

	return p
}

func (s *Cmd_echoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_echoContext) CMD_Echo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Echo, 0)
}

func (s *Cmd_echoContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Cmd_echoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_echoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_echoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_echo(s)
	}
}

func (s *Cmd_echoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_echo(s)
	}
}

func (s *Cmd_echoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_echo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_echo() (localctx ICmd_echoContext) {
	localctx = NewCmd_echoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SMTLIBv2ParserRULE_cmd_echo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(SMTLIBv2ParserCMD_Echo)
	}
	{
		p.SetState(737)
		p.String_()
	}

	return localctx
}

// ICmd_exitContext is an interface to support dynamic dispatch.
type ICmd_exitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_exitContext differentiates from other interfaces.
	IsCmd_exitContext()
}

type Cmd_exitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_exitContext() *Cmd_exitContext {
	var p = new(Cmd_exitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit
	return p
}

func (*Cmd_exitContext) IsCmd_exitContext() {}

func NewCmd_exitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_exitContext {
	var p = new(Cmd_exitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit

	return p
}

func (s *Cmd_exitContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_exitContext) CMD_Exit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Exit, 0)
}

func (s *Cmd_exitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_exitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_exitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_exit(s)
	}
}

func (s *Cmd_exitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_exit(s)
	}
}

func (s *Cmd_exitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_exit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_exit() (localctx ICmd_exitContext) {
	localctx = NewCmd_exitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SMTLIBv2ParserRULE_cmd_exit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Match(SMTLIBv2ParserCMD_Exit)
	}

	return localctx
}

// ICmd_getAssertionsContext is an interface to support dynamic dispatch.
type ICmd_getAssertionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getAssertionsContext differentiates from other interfaces.
	IsCmd_getAssertionsContext()
}

type Cmd_getAssertionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getAssertionsContext() *Cmd_getAssertionsContext {
	var p = new(Cmd_getAssertionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions
	return p
}

func (*Cmd_getAssertionsContext) IsCmd_getAssertionsContext() {}

func NewCmd_getAssertionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getAssertionsContext {
	var p = new(Cmd_getAssertionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions

	return p
}

func (s *Cmd_getAssertionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getAssertionsContext) CMD_GetAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetAssertions, 0)
}

func (s *Cmd_getAssertionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getAssertionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getAssertionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getAssertions(s)
	}
}

func (s *Cmd_getAssertionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getAssertions(s)
	}
}

func (s *Cmd_getAssertionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getAssertions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getAssertions() (localctx ICmd_getAssertionsContext) {
	localctx = NewCmd_getAssertionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SMTLIBv2ParserRULE_cmd_getAssertions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Match(SMTLIBv2ParserCMD_GetAssertions)
	}

	return localctx
}

// ICmd_getAssignmentContext is an interface to support dynamic dispatch.
type ICmd_getAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getAssignmentContext differentiates from other interfaces.
	IsCmd_getAssignmentContext()
}

type Cmd_getAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getAssignmentContext() *Cmd_getAssignmentContext {
	var p = new(Cmd_getAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment
	return p
}

func (*Cmd_getAssignmentContext) IsCmd_getAssignmentContext() {}

func NewCmd_getAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getAssignmentContext {
	var p = new(Cmd_getAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment

	return p
}

func (s *Cmd_getAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getAssignmentContext) CMD_GetAssignment() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetAssignment, 0)
}

func (s *Cmd_getAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getAssignment(s)
	}
}

func (s *Cmd_getAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getAssignment(s)
	}
}

func (s *Cmd_getAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getAssignment() (localctx ICmd_getAssignmentContext) {
	localctx = NewCmd_getAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SMTLIBv2ParserRULE_cmd_getAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(SMTLIBv2ParserCMD_GetAssignment)
	}

	return localctx
}

// ICmd_getInfoContext is an interface to support dynamic dispatch.
type ICmd_getInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getInfoContext differentiates from other interfaces.
	IsCmd_getInfoContext()
}

type Cmd_getInfoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getInfoContext() *Cmd_getInfoContext {
	var p = new(Cmd_getInfoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo
	return p
}

func (*Cmd_getInfoContext) IsCmd_getInfoContext() {}

func NewCmd_getInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getInfoContext {
	var p = new(Cmd_getInfoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo

	return p
}

func (s *Cmd_getInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getInfoContext) CMD_GetInfo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetInfo, 0)
}

func (s *Cmd_getInfoContext) Info_flag() IInfo_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfo_flagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfo_flagContext)
}

func (s *Cmd_getInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getInfo(s)
	}
}

func (s *Cmd_getInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getInfo(s)
	}
}

func (s *Cmd_getInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getInfo() (localctx ICmd_getInfoContext) {
	localctx = NewCmd_getInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SMTLIBv2ParserRULE_cmd_getInfo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(SMTLIBv2ParserCMD_GetInfo)
	}
	{
		p.SetState(746)
		p.Info_flag()
	}

	return localctx
}

// ICmd_getModelContext is an interface to support dynamic dispatch.
type ICmd_getModelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getModelContext differentiates from other interfaces.
	IsCmd_getModelContext()
}

type Cmd_getModelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getModelContext() *Cmd_getModelContext {
	var p = new(Cmd_getModelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel
	return p
}

func (*Cmd_getModelContext) IsCmd_getModelContext() {}

func NewCmd_getModelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getModelContext {
	var p = new(Cmd_getModelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel

	return p
}

func (s *Cmd_getModelContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getModelContext) CMD_GetModel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetModel, 0)
}

func (s *Cmd_getModelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getModelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getModelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getModel(s)
	}
}

func (s *Cmd_getModelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getModel(s)
	}
}

func (s *Cmd_getModelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getModel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getModel() (localctx ICmd_getModelContext) {
	localctx = NewCmd_getModelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SMTLIBv2ParserRULE_cmd_getModel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Match(SMTLIBv2ParserCMD_GetModel)
	}

	return localctx
}

// ICmd_getOptionContext is an interface to support dynamic dispatch.
type ICmd_getOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getOptionContext differentiates from other interfaces.
	IsCmd_getOptionContext()
}

type Cmd_getOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getOptionContext() *Cmd_getOptionContext {
	var p = new(Cmd_getOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption
	return p
}

func (*Cmd_getOptionContext) IsCmd_getOptionContext() {}

func NewCmd_getOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getOptionContext {
	var p = new(Cmd_getOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption

	return p
}

func (s *Cmd_getOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getOptionContext) CMD_GetOption() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetOption, 0)
}

func (s *Cmd_getOptionContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *Cmd_getOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getOption(s)
	}
}

func (s *Cmd_getOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getOption(s)
	}
}

func (s *Cmd_getOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getOption() (localctx ICmd_getOptionContext) {
	localctx = NewCmd_getOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SMTLIBv2ParserRULE_cmd_getOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(750)
		p.Match(SMTLIBv2ParserCMD_GetOption)
	}
	{
		p.SetState(751)
		p.Keyword()
	}

	return localctx
}

// ICmd_getProofContext is an interface to support dynamic dispatch.
type ICmd_getProofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getProofContext differentiates from other interfaces.
	IsCmd_getProofContext()
}

type Cmd_getProofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getProofContext() *Cmd_getProofContext {
	var p = new(Cmd_getProofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof
	return p
}

func (*Cmd_getProofContext) IsCmd_getProofContext() {}

func NewCmd_getProofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getProofContext {
	var p = new(Cmd_getProofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof

	return p
}

func (s *Cmd_getProofContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getProofContext) CMD_GetProof() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetProof, 0)
}

func (s *Cmd_getProofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getProofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getProofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getProof(s)
	}
}

func (s *Cmd_getProofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getProof(s)
	}
}

func (s *Cmd_getProofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getProof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getProof() (localctx ICmd_getProofContext) {
	localctx = NewCmd_getProofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SMTLIBv2ParserRULE_cmd_getProof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.Match(SMTLIBv2ParserCMD_GetProof)
	}

	return localctx
}

// ICmd_getUnsatAssumptionsContext is an interface to support dynamic dispatch.
type ICmd_getUnsatAssumptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getUnsatAssumptionsContext differentiates from other interfaces.
	IsCmd_getUnsatAssumptionsContext()
}

type Cmd_getUnsatAssumptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getUnsatAssumptionsContext() *Cmd_getUnsatAssumptionsContext {
	var p = new(Cmd_getUnsatAssumptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions
	return p
}

func (*Cmd_getUnsatAssumptionsContext) IsCmd_getUnsatAssumptionsContext() {}

func NewCmd_getUnsatAssumptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getUnsatAssumptionsContext {
	var p = new(Cmd_getUnsatAssumptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions

	return p
}

func (s *Cmd_getUnsatAssumptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getUnsatAssumptionsContext) CMD_GetUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetUnsatAssumptions, 0)
}

func (s *Cmd_getUnsatAssumptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getUnsatAssumptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getUnsatAssumptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getUnsatAssumptions(s)
	}
}

func (s *Cmd_getUnsatAssumptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getUnsatAssumptions(s)
	}
}

func (s *Cmd_getUnsatAssumptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getUnsatAssumptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getUnsatAssumptions() (localctx ICmd_getUnsatAssumptionsContext) {
	localctx = NewCmd_getUnsatAssumptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SMTLIBv2ParserRULE_cmd_getUnsatAssumptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(SMTLIBv2ParserCMD_GetUnsatAssumptions)
	}

	return localctx
}

// ICmd_getUnsatCoreContext is an interface to support dynamic dispatch.
type ICmd_getUnsatCoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getUnsatCoreContext differentiates from other interfaces.
	IsCmd_getUnsatCoreContext()
}

type Cmd_getUnsatCoreContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getUnsatCoreContext() *Cmd_getUnsatCoreContext {
	var p = new(Cmd_getUnsatCoreContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore
	return p
}

func (*Cmd_getUnsatCoreContext) IsCmd_getUnsatCoreContext() {}

func NewCmd_getUnsatCoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getUnsatCoreContext {
	var p = new(Cmd_getUnsatCoreContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore

	return p
}

func (s *Cmd_getUnsatCoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getUnsatCoreContext) CMD_GetUnsatCore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetUnsatCore, 0)
}

func (s *Cmd_getUnsatCoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getUnsatCoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getUnsatCoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getUnsatCore(s)
	}
}

func (s *Cmd_getUnsatCoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getUnsatCore(s)
	}
}

func (s *Cmd_getUnsatCoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getUnsatCore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getUnsatCore() (localctx ICmd_getUnsatCoreContext) {
	localctx = NewCmd_getUnsatCoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SMTLIBv2ParserRULE_cmd_getUnsatCore)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(SMTLIBv2ParserCMD_GetUnsatCore)
	}

	return localctx
}

// ICmd_getValueContext is an interface to support dynamic dispatch.
type ICmd_getValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getValueContext differentiates from other interfaces.
	IsCmd_getValueContext()
}

type Cmd_getValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getValueContext() *Cmd_getValueContext {
	var p = new(Cmd_getValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue
	return p
}

func (*Cmd_getValueContext) IsCmd_getValueContext() {}

func NewCmd_getValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getValueContext {
	var p = new(Cmd_getValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue

	return p
}

func (s *Cmd_getValueContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getValueContext) CMD_GetValue() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetValue, 0)
}

func (s *Cmd_getValueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_getValueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_getValueContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Cmd_getValueContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_getValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getValue(s)
	}
}

func (s *Cmd_getValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getValue(s)
	}
}

func (s *Cmd_getValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getValue() (localctx ICmd_getValueContext) {
	localctx = NewCmd_getValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SMTLIBv2ParserRULE_cmd_getValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(SMTLIBv2ParserCMD_GetValue)
	}
	{
		p.SetState(760)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(761)
			p.Term()
		}

		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(766)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_popContext is an interface to support dynamic dispatch.
type ICmd_popContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_popContext differentiates from other interfaces.
	IsCmd_popContext()
}

type Cmd_popContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_popContext() *Cmd_popContext {
	var p = new(Cmd_popContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop
	return p
}

func (*Cmd_popContext) IsCmd_popContext() {}

func NewCmd_popContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_popContext {
	var p = new(Cmd_popContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop

	return p
}

func (s *Cmd_popContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_popContext) CMD_Pop() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Pop, 0)
}

func (s *Cmd_popContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_popContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_popContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_popContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_pop(s)
	}
}

func (s *Cmd_popContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_pop(s)
	}
}

func (s *Cmd_popContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_pop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_pop() (localctx ICmd_popContext) {
	localctx = NewCmd_popContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SMTLIBv2ParserRULE_cmd_pop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(SMTLIBv2ParserCMD_Pop)
	}
	{
		p.SetState(769)
		p.Numeral()
	}

	return localctx
}

// ICmd_pushContext is an interface to support dynamic dispatch.
type ICmd_pushContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_pushContext differentiates from other interfaces.
	IsCmd_pushContext()
}

type Cmd_pushContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_pushContext() *Cmd_pushContext {
	var p = new(Cmd_pushContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push
	return p
}

func (*Cmd_pushContext) IsCmd_pushContext() {}

func NewCmd_pushContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_pushContext {
	var p = new(Cmd_pushContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push

	return p
}

func (s *Cmd_pushContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_pushContext) CMD_Push() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Push, 0)
}

func (s *Cmd_pushContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_pushContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_pushContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_pushContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_push(s)
	}
}

func (s *Cmd_pushContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_push(s)
	}
}

func (s *Cmd_pushContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_push(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_push() (localctx ICmd_pushContext) {
	localctx = NewCmd_pushContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SMTLIBv2ParserRULE_cmd_push)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(SMTLIBv2ParserCMD_Push)
	}
	{
		p.SetState(772)
		p.Numeral()
	}

	return localctx
}

// ICmd_resetContext is an interface to support dynamic dispatch.
type ICmd_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_resetContext differentiates from other interfaces.
	IsCmd_resetContext()
}

type Cmd_resetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_resetContext() *Cmd_resetContext {
	var p = new(Cmd_resetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset
	return p
}

func (*Cmd_resetContext) IsCmd_resetContext() {}

func NewCmd_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_resetContext {
	var p = new(Cmd_resetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset

	return p
}

func (s *Cmd_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_resetContext) CMD_Reset() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Reset, 0)
}

func (s *Cmd_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_reset(s)
	}
}

func (s *Cmd_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_reset(s)
	}
}

func (s *Cmd_resetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_reset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_reset() (localctx ICmd_resetContext) {
	localctx = NewCmd_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SMTLIBv2ParserRULE_cmd_reset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(SMTLIBv2ParserCMD_Reset)
	}

	return localctx
}

// ICmd_resetAssertionsContext is an interface to support dynamic dispatch.
type ICmd_resetAssertionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_resetAssertionsContext differentiates from other interfaces.
	IsCmd_resetAssertionsContext()
}

type Cmd_resetAssertionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_resetAssertionsContext() *Cmd_resetAssertionsContext {
	var p = new(Cmd_resetAssertionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions
	return p
}

func (*Cmd_resetAssertionsContext) IsCmd_resetAssertionsContext() {}

func NewCmd_resetAssertionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_resetAssertionsContext {
	var p = new(Cmd_resetAssertionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions

	return p
}

func (s *Cmd_resetAssertionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_resetAssertionsContext) CMD_ResetAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_ResetAssertions, 0)
}

func (s *Cmd_resetAssertionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_resetAssertionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_resetAssertionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_resetAssertions(s)
	}
}

func (s *Cmd_resetAssertionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_resetAssertions(s)
	}
}

func (s *Cmd_resetAssertionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_resetAssertions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_resetAssertions() (localctx ICmd_resetAssertionsContext) {
	localctx = NewCmd_resetAssertionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SMTLIBv2ParserRULE_cmd_resetAssertions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.Match(SMTLIBv2ParserCMD_ResetAssertions)
	}

	return localctx
}

// ICmd_setInfoContext is an interface to support dynamic dispatch.
type ICmd_setInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_setInfoContext differentiates from other interfaces.
	IsCmd_setInfoContext()
}

type Cmd_setInfoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setInfoContext() *Cmd_setInfoContext {
	var p = new(Cmd_setInfoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo
	return p
}

func (*Cmd_setInfoContext) IsCmd_setInfoContext() {}

func NewCmd_setInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setInfoContext {
	var p = new(Cmd_setInfoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo

	return p
}

func (s *Cmd_setInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setInfoContext) CMD_SetInfo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetInfo, 0)
}

func (s *Cmd_setInfoContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Cmd_setInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setInfo(s)
	}
}

func (s *Cmd_setInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setInfo(s)
	}
}

func (s *Cmd_setInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setInfo() (localctx ICmd_setInfoContext) {
	localctx = NewCmd_setInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SMTLIBv2ParserRULE_cmd_setInfo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Match(SMTLIBv2ParserCMD_SetInfo)
	}
	{
		p.SetState(779)
		p.Attribute()
	}

	return localctx
}

// ICmd_setLogicContext is an interface to support dynamic dispatch.
type ICmd_setLogicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_setLogicContext differentiates from other interfaces.
	IsCmd_setLogicContext()
}

type Cmd_setLogicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setLogicContext() *Cmd_setLogicContext {
	var p = new(Cmd_setLogicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic
	return p
}

func (*Cmd_setLogicContext) IsCmd_setLogicContext() {}

func NewCmd_setLogicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setLogicContext {
	var p = new(Cmd_setLogicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic

	return p
}

func (s *Cmd_setLogicContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setLogicContext) CMD_SetLogic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetLogic, 0)
}

func (s *Cmd_setLogicContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_setLogicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setLogicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setLogicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setLogic(s)
	}
}

func (s *Cmd_setLogicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setLogic(s)
	}
}

func (s *Cmd_setLogicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setLogic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setLogic() (localctx ICmd_setLogicContext) {
	localctx = NewCmd_setLogicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SMTLIBv2ParserRULE_cmd_setLogic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(SMTLIBv2ParserCMD_SetLogic)
	}
	{
		p.SetState(782)
		p.Symbol()
	}

	return localctx
}

// ICmd_setOptionContext is an interface to support dynamic dispatch.
type ICmd_setOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_setOptionContext differentiates from other interfaces.
	IsCmd_setOptionContext()
}

type Cmd_setOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setOptionContext() *Cmd_setOptionContext {
	var p = new(Cmd_setOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption
	return p
}

func (*Cmd_setOptionContext) IsCmd_setOptionContext() {}

func NewCmd_setOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setOptionContext {
	var p = new(Cmd_setOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption

	return p
}

func (s *Cmd_setOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setOptionContext) CMD_SetOption() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetOption, 0)
}

func (s *Cmd_setOptionContext) Option() IOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionContext)
}

func (s *Cmd_setOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setOption(s)
	}
}

func (s *Cmd_setOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setOption(s)
	}
}

func (s *Cmd_setOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setOption() (localctx ICmd_setOptionContext) {
	localctx = NewCmd_setOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SMTLIBv2ParserRULE_cmd_setOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Match(SMTLIBv2ParserCMD_SetOption)
	}
	{
		p.SetState(785)
		p.Option()
	}

	return localctx
}

// ICommandContext is an interface to support dynamic dispatch.
type ICommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandContext differentiates from other interfaces.
	IsCommandContext()
}

type CommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandContext() *CommandContext {
	var p = new(CommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_command
	return p
}

func (*CommandContext) IsCommandContext() {}

func NewCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandContext {
	var p = new(CommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_command

	return p
}

func (s *CommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *CommandContext) Cmd_assert() ICmd_assertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_assertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_assertContext)
}

func (s *CommandContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *CommandContext) Cmd_checkSat() ICmd_checkSatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_checkSatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_checkSatContext)
}

func (s *CommandContext) Cmd_checkSatAssuming() ICmd_checkSatAssumingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_checkSatAssumingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_checkSatAssumingContext)
}

func (s *CommandContext) Cmd_declareConst() ICmd_declareConstContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareConstContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareConstContext)
}

func (s *CommandContext) Cmd_declareDatatype() ICmd_declareDatatypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareDatatypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareDatatypeContext)
}

func (s *CommandContext) Cmd_declareDatatypes() ICmd_declareDatatypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareDatatypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareDatatypesContext)
}

func (s *CommandContext) Cmd_declareFun() ICmd_declareFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareFunContext)
}

func (s *CommandContext) Cmd_declareSort() ICmd_declareSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareSortContext)
}

func (s *CommandContext) Cmd_defineFun() ICmd_defineFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunContext)
}

func (s *CommandContext) Cmd_defineFunRec() ICmd_defineFunRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunRecContext)
}

func (s *CommandContext) Cmd_defineFunsRec() ICmd_defineFunsRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunsRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunsRecContext)
}

func (s *CommandContext) Cmd_defineSort() ICmd_defineSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineSortContext)
}

func (s *CommandContext) Cmd_echo() ICmd_echoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_echoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_echoContext)
}

func (s *CommandContext) Cmd_exit() ICmd_exitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_exitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_exitContext)
}

func (s *CommandContext) Cmd_getAssertions() ICmd_getAssertionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getAssertionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getAssertionsContext)
}

func (s *CommandContext) Cmd_getAssignment() ICmd_getAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getAssignmentContext)
}

func (s *CommandContext) Cmd_getInfo() ICmd_getInfoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getInfoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getInfoContext)
}

func (s *CommandContext) Cmd_getModel() ICmd_getModelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getModelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getModelContext)
}

func (s *CommandContext) Cmd_getOption() ICmd_getOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getOptionContext)
}

func (s *CommandContext) Cmd_getProof() ICmd_getProofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getProofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getProofContext)
}

func (s *CommandContext) Cmd_getUnsatAssumptions() ICmd_getUnsatAssumptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getUnsatAssumptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getUnsatAssumptionsContext)
}

func (s *CommandContext) Cmd_getUnsatCore() ICmd_getUnsatCoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getUnsatCoreContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getUnsatCoreContext)
}

func (s *CommandContext) Cmd_getValue() ICmd_getValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getValueContext)
}

func (s *CommandContext) Cmd_pop() ICmd_popContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_popContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_popContext)
}

func (s *CommandContext) Cmd_push() ICmd_pushContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_pushContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_pushContext)
}

func (s *CommandContext) Cmd_reset() ICmd_resetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_resetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_resetContext)
}

func (s *CommandContext) Cmd_resetAssertions() ICmd_resetAssertionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_resetAssertionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_resetAssertionsContext)
}

func (s *CommandContext) Cmd_setInfo() ICmd_setInfoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_setInfoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_setInfoContext)
}

func (s *CommandContext) Cmd_setLogic() ICmd_setLogicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_setLogicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_setLogicContext)
}

func (s *CommandContext) Cmd_setOption() ICmd_setOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_setOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_setOptionContext)
}

func (s *CommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCommand(s)
	}
}

func (s *CommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCommand(s)
	}
}

func (s *CommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Command() (localctx ICommandContext) {
	localctx = NewCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SMTLIBv2ParserRULE_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(787)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(788)
			p.Cmd_assert()
		}
		{
			p.SetState(789)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(791)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(792)
			p.Cmd_checkSat()
		}
		{
			p.SetState(793)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(795)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(796)
			p.Cmd_checkSatAssuming()
		}
		{
			p.SetState(797)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(799)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(800)
			p.Cmd_declareConst()
		}
		{
			p.SetState(801)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(803)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(804)
			p.Cmd_declareDatatype()
		}
		{
			p.SetState(805)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(807)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(808)
			p.Cmd_declareDatatypes()
		}
		{
			p.SetState(809)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(811)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(812)
			p.Cmd_declareFun()
		}
		{
			p.SetState(813)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(815)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(816)
			p.Cmd_declareSort()
		}
		{
			p.SetState(817)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(819)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(820)
			p.Cmd_defineFun()
		}
		{
			p.SetState(821)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(823)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(824)
			p.Cmd_defineFunRec()
		}
		{
			p.SetState(825)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(827)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(828)
			p.Cmd_defineFunsRec()
		}
		{
			p.SetState(829)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(831)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(832)
			p.Cmd_defineSort()
		}
		{
			p.SetState(833)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(835)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(836)
			p.Cmd_echo()
		}
		{
			p.SetState(837)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(839)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(840)
			p.Cmd_exit()
		}
		{
			p.SetState(841)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(843)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(844)
			p.Cmd_getAssertions()
		}
		{
			p.SetState(845)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(847)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(848)
			p.Cmd_getAssignment()
		}
		{
			p.SetState(849)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(851)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(852)
			p.Cmd_getInfo()
		}
		{
			p.SetState(853)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(855)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(856)
			p.Cmd_getModel()
		}
		{
			p.SetState(857)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(859)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(860)
			p.Cmd_getOption()
		}
		{
			p.SetState(861)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(863)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(864)
			p.Cmd_getProof()
		}
		{
			p.SetState(865)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(867)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(868)
			p.Cmd_getUnsatAssumptions()
		}
		{
			p.SetState(869)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(871)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(872)
			p.Cmd_getUnsatCore()
		}
		{
			p.SetState(873)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(875)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(876)
			p.Cmd_getValue()
		}
		{
			p.SetState(877)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(879)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(880)
			p.Cmd_pop()
		}
		{
			p.SetState(881)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(883)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(884)
			p.Cmd_push()
		}
		{
			p.SetState(885)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(887)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(888)
			p.Cmd_reset()
		}
		{
			p.SetState(889)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(891)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(892)
			p.Cmd_resetAssertions()
		}
		{
			p.SetState(893)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(895)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(896)
			p.Cmd_setInfo()
		}
		{
			p.SetState(897)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(899)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(900)
			p.Cmd_setLogic()
		}
		{
			p.SetState(901)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(903)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(904)
			p.Cmd_setOption()
		}
		{
			p.SetState(905)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IB_valueContext is an interface to support dynamic dispatch.
type IB_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsB_valueContext differentiates from other interfaces.
	IsB_valueContext()
}

type B_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyB_valueContext() *B_valueContext {
	var p = new(B_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_b_value
	return p
}

func (*B_valueContext) IsB_valueContext() {}

func NewB_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *B_valueContext {
	var p = new(B_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_b_value

	return p
}

func (s *B_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *B_valueContext) PS_True() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_True, 0)
}

func (s *B_valueContext) PS_False() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_False, 0)
}

func (s *B_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *B_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *B_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterB_value(s)
	}
}

func (s *B_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitB_value(s)
	}
}

func (s *B_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitB_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) B_value() (localctx IB_valueContext) {
	localctx = NewB_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SMTLIBv2ParserRULE_b_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(909)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SMTLIBv2ParserPS_False || _la == SMTLIBv2ParserPS_True) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOptionContext is an interface to support dynamic dispatch.
type IOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionContext differentiates from other interfaces.
	IsOptionContext()
}

type OptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionContext() *OptionContext {
	var p = new(OptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_option
	return p
}

func (*OptionContext) IsOptionContext() {}

func NewOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionContext {
	var p = new(OptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_option

	return p
}

func (s *OptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionContext) PK_DiagnosticOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_DiagnosticOutputChannel, 0)
}

func (s *OptionContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *OptionContext) PK_GlobalDeclarations() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_GlobalDeclarations, 0)
}

func (s *OptionContext) B_value() IB_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IB_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IB_valueContext)
}

func (s *OptionContext) PK_InteractiveMode() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_InteractiveMode, 0)
}

func (s *OptionContext) PK_PrintSuccess() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_PrintSuccess, 0)
}

func (s *OptionContext) PK_ProduceAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssertions, 0)
}

func (s *OptionContext) PK_ProduceAssignments() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssignments, 0)
}

func (s *OptionContext) PK_ProduceModels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceModels, 0)
}

func (s *OptionContext) PK_ProduceProofs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceProofs, 0)
}

func (s *OptionContext) PK_ProduceUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatAssumptions, 0)
}

func (s *OptionContext) PK_ProduceUnsatCores() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatCores, 0)
}

func (s *OptionContext) PK_RandomSeed() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RandomSeed, 0)
}

func (s *OptionContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *OptionContext) PK_RegularOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RegularOutputChannel, 0)
}

func (s *OptionContext) PK_ReproducibleResourceLimit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReproducibleResourceLimit, 0)
}

func (s *OptionContext) PK_Verbosity() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Verbosity, 0)
}

func (s *OptionContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *OptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterOption(s)
	}
}

func (s *OptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitOption(s)
	}
}

func (s *OptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Option() (localctx IOptionContext) {
	localctx = NewOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SMTLIBv2ParserRULE_option)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(911)
			p.Match(SMTLIBv2ParserPK_DiagnosticOutputChannel)
		}
		{
			p.SetState(912)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(913)
			p.Match(SMTLIBv2ParserPK_GlobalDeclarations)
		}
		{
			p.SetState(914)
			p.B_value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(915)
			p.Match(SMTLIBv2ParserPK_InteractiveMode)
		}
		{
			p.SetState(916)
			p.B_value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(917)
			p.Match(SMTLIBv2ParserPK_PrintSuccess)
		}
		{
			p.SetState(918)
			p.B_value()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(919)
			p.Match(SMTLIBv2ParserPK_ProduceAssertions)
		}
		{
			p.SetState(920)
			p.B_value()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(921)
			p.Match(SMTLIBv2ParserPK_ProduceAssignments)
		}
		{
			p.SetState(922)
			p.B_value()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(923)
			p.Match(SMTLIBv2ParserPK_ProduceModels)
		}
		{
			p.SetState(924)
			p.B_value()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(925)
			p.Match(SMTLIBv2ParserPK_ProduceProofs)
		}
		{
			p.SetState(926)
			p.B_value()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(927)
			p.Match(SMTLIBv2ParserPK_ProduceUnsatAssumptions)
		}
		{
			p.SetState(928)
			p.B_value()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(929)
			p.Match(SMTLIBv2ParserPK_ProduceUnsatCores)
		}
		{
			p.SetState(930)
			p.B_value()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(931)
			p.Match(SMTLIBv2ParserPK_RandomSeed)
		}
		{
			p.SetState(932)
			p.Numeral()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(933)
			p.Match(SMTLIBv2ParserPK_RegularOutputChannel)
		}
		{
			p.SetState(934)
			p.String_()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(935)
			p.Match(SMTLIBv2ParserPK_ReproducibleResourceLimit)
		}
		{
			p.SetState(936)
			p.Numeral()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(937)
			p.Match(SMTLIBv2ParserPK_Verbosity)
		}
		{
			p.SetState(938)
			p.Numeral()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(939)
			p.Attribute()
		}

	}

	return localctx
}

// IInfo_flagContext is an interface to support dynamic dispatch.
type IInfo_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfo_flagContext differentiates from other interfaces.
	IsInfo_flagContext()
}

type Info_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_flagContext() *Info_flagContext {
	var p = new(Info_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag
	return p
}

func (*Info_flagContext) IsInfo_flagContext() {}

func NewInfo_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_flagContext {
	var p = new(Info_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag

	return p
}

func (s *Info_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_flagContext) PK_AllStatistics() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AllStatistics, 0)
}

func (s *Info_flagContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *Info_flagContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *Info_flagContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *Info_flagContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *Info_flagContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *Info_flagContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *Info_flagContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *Info_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterInfo_flag(s)
	}
}

func (s *Info_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitInfo_flag(s)
	}
}

func (s *Info_flagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitInfo_flag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Info_flag() (localctx IInfo_flagContext) {
	localctx = NewInfo_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SMTLIBv2ParserRULE_info_flag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(942)
			p.Match(SMTLIBv2ParserPK_AllStatistics)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(943)
			p.Match(SMTLIBv2ParserPK_AssertionStackLevels)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(944)
			p.Match(SMTLIBv2ParserPK_Authors)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(945)
			p.Match(SMTLIBv2ParserPK_ErrorBehaviour)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(946)
			p.Match(SMTLIBv2ParserPK_Name)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(947)
			p.Match(SMTLIBv2ParserPK_ReasonUnknown)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(948)
			p.Match(SMTLIBv2ParserPK_Version)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(949)
			p.Keyword()
		}

	}

	return localctx
}

// IError_behaviourContext is an interface to support dynamic dispatch.
type IError_behaviourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_behaviourContext differentiates from other interfaces.
	IsError_behaviourContext()
}

type Error_behaviourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_behaviourContext() *Error_behaviourContext {
	var p = new(Error_behaviourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour
	return p
}

func (*Error_behaviourContext) IsError_behaviourContext() {}

func NewError_behaviourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_behaviourContext {
	var p = new(Error_behaviourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour

	return p
}

func (s *Error_behaviourContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_behaviourContext) PS_ImmediateExit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ImmediateExit, 0)
}

func (s *Error_behaviourContext) PS_ContinuedExecution() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ContinuedExecution, 0)
}

func (s *Error_behaviourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_behaviourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_behaviourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterError_behaviour(s)
	}
}

func (s *Error_behaviourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitError_behaviour(s)
	}
}

func (s *Error_behaviourContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitError_behaviour(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Error_behaviour() (localctx IError_behaviourContext) {
	localctx = NewError_behaviourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SMTLIBv2ParserRULE_error_behaviour)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SMTLIBv2ParserPS_ContinuedExecution || _la == SMTLIBv2ParserPS_ImmediateExit) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReason_unknownContext is an interface to support dynamic dispatch.
type IReason_unknownContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReason_unknownContext differentiates from other interfaces.
	IsReason_unknownContext()
}

type Reason_unknownContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReason_unknownContext() *Reason_unknownContext {
	var p = new(Reason_unknownContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown
	return p
}

func (*Reason_unknownContext) IsReason_unknownContext() {}

func NewReason_unknownContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reason_unknownContext {
	var p = new(Reason_unknownContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown

	return p
}

func (s *Reason_unknownContext) GetParser() antlr.Parser { return s.parser }

func (s *Reason_unknownContext) PS_Memout() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Memout, 0)
}

func (s *Reason_unknownContext) PS_Incomplete() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Incomplete, 0)
}

func (s *Reason_unknownContext) S_expr() IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Reason_unknownContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reason_unknownContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reason_unknownContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterReason_unknown(s)
	}
}

func (s *Reason_unknownContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitReason_unknown(s)
	}
}

func (s *Reason_unknownContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitReason_unknown(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Reason_unknown() (localctx IReason_unknownContext) {
	localctx = NewReason_unknownContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SMTLIBv2ParserRULE_reason_unknown)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(954)
			p.Match(SMTLIBv2ParserPS_Memout)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(955)
			p.Match(SMTLIBv2ParserPS_Incomplete)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(956)
			p.S_expr()
		}

	}

	return localctx
}

// IModel_responseContext is an interface to support dynamic dispatch.
type IModel_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_responseContext differentiates from other interfaces.
	IsModel_responseContext()
}

type Model_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_responseContext() *Model_responseContext {
	var p = new(Model_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_model_response
	return p
}

func (*Model_responseContext) IsModel_responseContext() {}

func NewModel_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_responseContext {
	var p = new(Model_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_model_response

	return p
}

func (s *Model_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Model_responseContext) Cmd_defineFun() ICmd_defineFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunContext)
}

func (s *Model_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Model_responseContext) Cmd_defineFunRec() ICmd_defineFunRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunRecContext)
}

func (s *Model_responseContext) Cmd_defineFunsRec() ICmd_defineFunsRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunsRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunsRecContext)
}

func (s *Model_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterModel_response(s)
	}
}

func (s *Model_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitModel_response(s)
	}
}

func (s *Model_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitModel_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Model_response() (localctx IModel_responseContext) {
	localctx = NewModel_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SMTLIBv2ParserRULE_model_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(971)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(959)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(960)
			p.Cmd_defineFun()
		}
		{
			p.SetState(961)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(963)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(964)
			p.Cmd_defineFunRec()
		}
		{
			p.SetState(965)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(967)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(968)
			p.Cmd_defineFunsRec()
		}
		{
			p.SetState(969)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IInfo_responseContext is an interface to support dynamic dispatch.
type IInfo_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfo_responseContext differentiates from other interfaces.
	IsInfo_responseContext()
}

type Info_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_responseContext() *Info_responseContext {
	var p = new(Info_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_response
	return p
}

func (*Info_responseContext) IsInfo_responseContext() {}

func NewInfo_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_responseContext {
	var p = new(Info_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_info_response

	return p
}

func (s *Info_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_responseContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *Info_responseContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Info_responseContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *Info_responseContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Info_responseContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *Info_responseContext) Error_behaviour() IError_behaviourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_behaviourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_behaviourContext)
}

func (s *Info_responseContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *Info_responseContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *Info_responseContext) Reason_unknown() IReason_unknownContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReason_unknownContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReason_unknownContext)
}

func (s *Info_responseContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *Info_responseContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Info_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterInfo_response(s)
	}
}

func (s *Info_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitInfo_response(s)
	}
}

func (s *Info_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitInfo_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Info_response() (localctx IInfo_responseContext) {
	localctx = NewInfo_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SMTLIBv2ParserRULE_info_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(973)
			p.Match(SMTLIBv2ParserPK_AssertionStackLevels)
		}
		{
			p.SetState(974)
			p.Numeral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(975)
			p.Match(SMTLIBv2ParserPK_Authors)
		}
		{
			p.SetState(976)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(977)
			p.Match(SMTLIBv2ParserPK_ErrorBehaviour)
		}
		{
			p.SetState(978)
			p.Error_behaviour()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(979)
			p.Match(SMTLIBv2ParserPK_Name)
		}
		{
			p.SetState(980)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(981)
			p.Match(SMTLIBv2ParserPK_ReasonUnknown)
		}
		{
			p.SetState(982)
			p.Reason_unknown()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(983)
			p.Match(SMTLIBv2ParserPK_Version)
		}
		{
			p.SetState(984)
			p.String_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(985)
			p.Attribute()
		}

	}

	return localctx
}

// IValuation_pairContext is an interface to support dynamic dispatch.
type IValuation_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuation_pairContext differentiates from other interfaces.
	IsValuation_pairContext()
}

type Valuation_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuation_pairContext() *Valuation_pairContext {
	var p = new(Valuation_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair
	return p
}

func (*Valuation_pairContext) IsValuation_pairContext() {}

func NewValuation_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Valuation_pairContext {
	var p = new(Valuation_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair

	return p
}

func (s *Valuation_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Valuation_pairContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Valuation_pairContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Valuation_pairContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Valuation_pairContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Valuation_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Valuation_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Valuation_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterValuation_pair(s)
	}
}

func (s *Valuation_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitValuation_pair(s)
	}
}

func (s *Valuation_pairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitValuation_pair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Valuation_pair() (localctx IValuation_pairContext) {
	localctx = NewValuation_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SMTLIBv2ParserRULE_valuation_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(989)
		p.Term()
	}
	{
		p.SetState(990)
		p.Term()
	}
	{
		p.SetState(991)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IT_valuation_pairContext is an interface to support dynamic dispatch.
type IT_valuation_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT_valuation_pairContext differentiates from other interfaces.
	IsT_valuation_pairContext()
}

type T_valuation_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_valuation_pairContext() *T_valuation_pairContext {
	var p = new(T_valuation_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair
	return p
}

func (*T_valuation_pairContext) IsT_valuation_pairContext() {}

func NewT_valuation_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_valuation_pairContext {
	var p = new(T_valuation_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair

	return p
}

func (s *T_valuation_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *T_valuation_pairContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *T_valuation_pairContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *T_valuation_pairContext) B_value() IB_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IB_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IB_valueContext)
}

func (s *T_valuation_pairContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *T_valuation_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_valuation_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_valuation_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterT_valuation_pair(s)
	}
}

func (s *T_valuation_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitT_valuation_pair(s)
	}
}

func (s *T_valuation_pairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitT_valuation_pair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) T_valuation_pair() (localctx IT_valuation_pairContext) {
	localctx = NewT_valuation_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SMTLIBv2ParserRULE_t_valuation_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(994)
		p.Symbol()
	}
	{
		p.SetState(995)
		p.B_value()
	}
	{
		p.SetState(996)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICheck_sat_responseContext is an interface to support dynamic dispatch.
type ICheck_sat_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheck_sat_responseContext differentiates from other interfaces.
	IsCheck_sat_responseContext()
}

type Check_sat_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheck_sat_responseContext() *Check_sat_responseContext {
	var p = new(Check_sat_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response
	return p
}

func (*Check_sat_responseContext) IsCheck_sat_responseContext() {}

func NewCheck_sat_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Check_sat_responseContext {
	var p = new(Check_sat_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response

	return p
}

func (s *Check_sat_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Check_sat_responseContext) PS_Sat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Sat, 0)
}

func (s *Check_sat_responseContext) PS_Unsat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsat, 0)
}

func (s *Check_sat_responseContext) PS_Unknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unknown, 0)
}

func (s *Check_sat_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Check_sat_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Check_sat_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCheck_sat_response(s)
	}
}

func (s *Check_sat_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCheck_sat_response(s)
	}
}

func (s *Check_sat_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCheck_sat_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Check_sat_response() (localctx ICheck_sat_responseContext) {
	localctx = NewCheck_sat_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SMTLIBv2ParserRULE_check_sat_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEcho_responseContext is an interface to support dynamic dispatch.
type IEcho_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEcho_responseContext differentiates from other interfaces.
	IsEcho_responseContext()
}

type Echo_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEcho_responseContext() *Echo_responseContext {
	var p = new(Echo_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response
	return p
}

func (*Echo_responseContext) IsEcho_responseContext() {}

func NewEcho_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Echo_responseContext {
	var p = new(Echo_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response

	return p
}

func (s *Echo_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Echo_responseContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Echo_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Echo_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Echo_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterEcho_response(s)
	}
}

func (s *Echo_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitEcho_response(s)
	}
}

func (s *Echo_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitEcho_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Echo_response() (localctx IEcho_responseContext) {
	localctx = NewEcho_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SMTLIBv2ParserRULE_echo_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1000)
		p.String_()
	}

	return localctx
}

// IGet_assertions_responseContext is an interface to support dynamic dispatch.
type IGet_assertions_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_assertions_responseContext differentiates from other interfaces.
	IsGet_assertions_responseContext()
}

type Get_assertions_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_assertions_responseContext() *Get_assertions_responseContext {
	var p = new(Get_assertions_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response
	return p
}

func (*Get_assertions_responseContext) IsGet_assertions_responseContext() {}

func NewGet_assertions_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_assertions_responseContext {
	var p = new(Get_assertions_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response

	return p
}

func (s *Get_assertions_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_assertions_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_assertions_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_assertions_responseContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Get_assertions_responseContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Get_assertions_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_assertions_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_assertions_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_assertions_response(s)
	}
}

func (s *Get_assertions_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_assertions_response(s)
	}
}

func (s *Get_assertions_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_assertions_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_assertions_response() (localctx IGet_assertions_responseContext) {
	localctx = NewGet_assertions_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SMTLIBv2ParserRULE_get_assertions_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1003)
			p.Term()
		}

		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1009)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_assignment_responseContext is an interface to support dynamic dispatch.
type IGet_assignment_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_assignment_responseContext differentiates from other interfaces.
	IsGet_assignment_responseContext()
}

type Get_assignment_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_assignment_responseContext() *Get_assignment_responseContext {
	var p = new(Get_assignment_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response
	return p
}

func (*Get_assignment_responseContext) IsGet_assignment_responseContext() {}

func NewGet_assignment_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_assignment_responseContext {
	var p = new(Get_assignment_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response

	return p
}

func (s *Get_assignment_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_assignment_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_assignment_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_assignment_responseContext) AllT_valuation_pair() []IT_valuation_pairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IT_valuation_pairContext)(nil)).Elem())
	var tst = make([]IT_valuation_pairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IT_valuation_pairContext)
		}
	}

	return tst
}

func (s *Get_assignment_responseContext) T_valuation_pair(i int) IT_valuation_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT_valuation_pairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IT_valuation_pairContext)
}

func (s *Get_assignment_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_assignment_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_assignment_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_assignment_response(s)
	}
}

func (s *Get_assignment_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_assignment_response(s)
	}
}

func (s *Get_assignment_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_assignment_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_assignment_response() (localctx IGet_assignment_responseContext) {
	localctx = NewGet_assignment_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SMTLIBv2ParserRULE_get_assignment_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(1012)
			p.T_valuation_pair()
		}

		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1018)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_info_responseContext is an interface to support dynamic dispatch.
type IGet_info_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_info_responseContext differentiates from other interfaces.
	IsGet_info_responseContext()
}

type Get_info_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_info_responseContext() *Get_info_responseContext {
	var p = new(Get_info_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response
	return p
}

func (*Get_info_responseContext) IsGet_info_responseContext() {}

func NewGet_info_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_info_responseContext {
	var p = new(Get_info_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response

	return p
}

func (s *Get_info_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_info_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_info_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_info_responseContext) AllInfo_response() []IInfo_responseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInfo_responseContext)(nil)).Elem())
	var tst = make([]IInfo_responseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInfo_responseContext)
		}
	}

	return tst
}

func (s *Get_info_responseContext) Info_response(i int) IInfo_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfo_responseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInfo_responseContext)
}

func (s *Get_info_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_info_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_info_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_info_response(s)
	}
}

func (s *Get_info_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_info_response(s)
	}
}

func (s *Get_info_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_info_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_info_response() (localctx IGet_info_responseContext) {
	localctx = NewGet_info_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SMTLIBv2ParserRULE_get_info_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(1021)
			p.Info_response()
		}

		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1026)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_model_responseContext is an interface to support dynamic dispatch.
type IGet_model_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_model_responseContext differentiates from other interfaces.
	IsGet_model_responseContext()
}

type Get_model_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_model_responseContext() *Get_model_responseContext {
	var p = new(Get_model_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response
	return p
}

func (*Get_model_responseContext) IsGet_model_responseContext() {}

func NewGet_model_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_model_responseContext {
	var p = new(Get_model_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response

	return p
}

func (s *Get_model_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_model_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_model_responseContext) RS_Model() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserRS_Model, 0)
}

func (s *Get_model_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_model_responseContext) AllModel_response() []IModel_responseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModel_responseContext)(nil)).Elem())
	var tst = make([]IModel_responseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModel_responseContext)
		}
	}

	return tst
}

func (s *Get_model_responseContext) Model_response(i int) IModel_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_responseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModel_responseContext)
}

func (s *Get_model_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_model_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_model_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_model_response(s)
	}
}

func (s *Get_model_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_model_response(s)
	}
}

func (s *Get_model_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_model_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_model_response() (localctx IGet_model_responseContext) {
	localctx = NewGet_model_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SMTLIBv2ParserRULE_get_model_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1028)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(1029)
			p.Match(SMTLIBv2ParserRS_Model)
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(1030)
				p.Model_response()
			}

			p.SetState(1035)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1036)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1037)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(1038)
				p.Model_response()
			}

			p.SetState(1043)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1044)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IGet_option_responseContext is an interface to support dynamic dispatch.
type IGet_option_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_option_responseContext differentiates from other interfaces.
	IsGet_option_responseContext()
}

type Get_option_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_option_responseContext() *Get_option_responseContext {
	var p = new(Get_option_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response
	return p
}

func (*Get_option_responseContext) IsGet_option_responseContext() {}

func NewGet_option_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_option_responseContext {
	var p = new(Get_option_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response

	return p
}

func (s *Get_option_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_option_responseContext) Attribute_value() IAttribute_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *Get_option_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_option_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_option_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_option_response(s)
	}
}

func (s *Get_option_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_option_response(s)
	}
}

func (s *Get_option_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_option_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_option_response() (localctx IGet_option_responseContext) {
	localctx = NewGet_option_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SMTLIBv2ParserRULE_get_option_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1047)
		p.Attribute_value()
	}

	return localctx
}

// IGet_proof_responseContext is an interface to support dynamic dispatch.
type IGet_proof_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_proof_responseContext differentiates from other interfaces.
	IsGet_proof_responseContext()
}

type Get_proof_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_proof_responseContext() *Get_proof_responseContext {
	var p = new(Get_proof_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response
	return p
}

func (*Get_proof_responseContext) IsGet_proof_responseContext() {}

func NewGet_proof_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_proof_responseContext {
	var p = new(Get_proof_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response

	return p
}

func (s *Get_proof_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_proof_responseContext) S_expr() IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Get_proof_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_proof_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_proof_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_proof_response(s)
	}
}

func (s *Get_proof_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_proof_response(s)
	}
}

func (s *Get_proof_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_proof_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_proof_response() (localctx IGet_proof_responseContext) {
	localctx = NewGet_proof_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SMTLIBv2ParserRULE_get_proof_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.S_expr()
	}

	return localctx
}

// IGet_unsat_assump_responseContext is an interface to support dynamic dispatch.
type IGet_unsat_assump_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_unsat_assump_responseContext differentiates from other interfaces.
	IsGet_unsat_assump_responseContext()
}

type Get_unsat_assump_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_unsat_assump_responseContext() *Get_unsat_assump_responseContext {
	var p = new(Get_unsat_assump_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response
	return p
}

func (*Get_unsat_assump_responseContext) IsGet_unsat_assump_responseContext() {}

func NewGet_unsat_assump_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_unsat_assump_responseContext {
	var p = new(Get_unsat_assump_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response

	return p
}

func (s *Get_unsat_assump_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_unsat_assump_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_unsat_assump_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_unsat_assump_responseContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Get_unsat_assump_responseContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Get_unsat_assump_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_unsat_assump_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_unsat_assump_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_unsat_assump_response(s)
	}
}

func (s *Get_unsat_assump_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_unsat_assump_response(s)
	}
}

func (s *Get_unsat_assump_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_unsat_assump_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_unsat_assump_response() (localctx IGet_unsat_assump_responseContext) {
	localctx = NewGet_unsat_assump_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SMTLIBv2ParserRULE_get_unsat_assump_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1052)
			p.Symbol()
		}

		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1058)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_unsat_core_responseContext is an interface to support dynamic dispatch.
type IGet_unsat_core_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_unsat_core_responseContext differentiates from other interfaces.
	IsGet_unsat_core_responseContext()
}

type Get_unsat_core_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_unsat_core_responseContext() *Get_unsat_core_responseContext {
	var p = new(Get_unsat_core_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response
	return p
}

func (*Get_unsat_core_responseContext) IsGet_unsat_core_responseContext() {}

func NewGet_unsat_core_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_unsat_core_responseContext {
	var p = new(Get_unsat_core_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response

	return p
}

func (s *Get_unsat_core_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_unsat_core_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_unsat_core_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_unsat_core_responseContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Get_unsat_core_responseContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Get_unsat_core_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_unsat_core_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_unsat_core_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_unsat_core_response(s)
	}
}

func (s *Get_unsat_core_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_unsat_core_response(s)
	}
}

func (s *Get_unsat_core_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_unsat_core_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_unsat_core_response() (localctx IGet_unsat_core_responseContext) {
	localctx = NewGet_unsat_core_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SMTLIBv2ParserRULE_get_unsat_core_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1061)
			p.Symbol()
		}

		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1067)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_value_responseContext is an interface to support dynamic dispatch.
type IGet_value_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_value_responseContext differentiates from other interfaces.
	IsGet_value_responseContext()
}

type Get_value_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_value_responseContext() *Get_value_responseContext {
	var p = new(Get_value_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response
	return p
}

func (*Get_value_responseContext) IsGet_value_responseContext() {}

func NewGet_value_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_value_responseContext {
	var p = new(Get_value_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response

	return p
}

func (s *Get_value_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_value_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_value_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_value_responseContext) AllValuation_pair() []IValuation_pairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValuation_pairContext)(nil)).Elem())
	var tst = make([]IValuation_pairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValuation_pairContext)
		}
	}

	return tst
}

func (s *Get_value_responseContext) Valuation_pair(i int) IValuation_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuation_pairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValuation_pairContext)
}

func (s *Get_value_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_value_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_value_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_value_response(s)
	}
}

func (s *Get_value_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_value_response(s)
	}
}

func (s *Get_value_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_value_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_value_response() (localctx IGet_value_responseContext) {
	localctx = NewGet_value_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SMTLIBv2ParserRULE_get_value_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(1070)
			p.Valuation_pair()
		}

		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1075)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISpecific_success_responseContext is an interface to support dynamic dispatch.
type ISpecific_success_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecific_success_responseContext differentiates from other interfaces.
	IsSpecific_success_responseContext()
}

type Specific_success_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecific_success_responseContext() *Specific_success_responseContext {
	var p = new(Specific_success_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response
	return p
}

func (*Specific_success_responseContext) IsSpecific_success_responseContext() {}

func NewSpecific_success_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specific_success_responseContext {
	var p = new(Specific_success_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response

	return p
}

func (s *Specific_success_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Specific_success_responseContext) Check_sat_response() ICheck_sat_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheck_sat_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheck_sat_responseContext)
}

func (s *Specific_success_responseContext) Echo_response() IEcho_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEcho_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEcho_responseContext)
}

func (s *Specific_success_responseContext) Get_assertions_response() IGet_assertions_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_assertions_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_assertions_responseContext)
}

func (s *Specific_success_responseContext) Get_assignment_response() IGet_assignment_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_assignment_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_assignment_responseContext)
}

func (s *Specific_success_responseContext) Get_info_response() IGet_info_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_info_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_info_responseContext)
}

func (s *Specific_success_responseContext) Get_model_response() IGet_model_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_model_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_model_responseContext)
}

func (s *Specific_success_responseContext) Get_option_response() IGet_option_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_option_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_option_responseContext)
}

func (s *Specific_success_responseContext) Get_proof_response() IGet_proof_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_proof_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_proof_responseContext)
}

func (s *Specific_success_responseContext) Get_unsat_assump_response() IGet_unsat_assump_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_unsat_assump_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_unsat_assump_responseContext)
}

func (s *Specific_success_responseContext) Get_unsat_core_response() IGet_unsat_core_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_unsat_core_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_unsat_core_responseContext)
}

func (s *Specific_success_responseContext) Get_value_response() IGet_value_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_value_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_value_responseContext)
}

func (s *Specific_success_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specific_success_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specific_success_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSpecific_success_response(s)
	}
}

func (s *Specific_success_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSpecific_success_response(s)
	}
}

func (s *Specific_success_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSpecific_success_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Specific_success_response() (localctx ISpecific_success_responseContext) {
	localctx = NewSpecific_success_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SMTLIBv2ParserRULE_specific_success_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1077)
			p.Check_sat_response()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.Echo_response()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1079)
			p.Get_assertions_response()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1080)
			p.Get_assignment_response()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1081)
			p.Get_info_response()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1082)
			p.Get_model_response()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1083)
			p.Get_option_response()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1084)
			p.Get_proof_response()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1085)
			p.Get_unsat_assump_response()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1086)
			p.Get_unsat_core_response()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1087)
			p.Get_value_response()
		}

	}

	return localctx
}

// IGeneral_responseContext is an interface to support dynamic dispatch.
type IGeneral_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_responseContext differentiates from other interfaces.
	IsGeneral_responseContext()
}

type General_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_responseContext() *General_responseContext {
	var p = new(General_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_general_response
	return p
}

func (*General_responseContext) IsGeneral_responseContext() {}

func NewGeneral_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_responseContext {
	var p = new(General_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_general_response

	return p
}

func (s *General_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *General_responseContext) PS_Success() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Success, 0)
}

func (s *General_responseContext) Specific_success_response() ISpecific_success_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecific_success_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecific_success_responseContext)
}

func (s *General_responseContext) PS_Unsupported() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsupported, 0)
}

func (s *General_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *General_responseContext) PS_Error() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Error, 0)
}

func (s *General_responseContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *General_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *General_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGeneral_response(s)
	}
}

func (s *General_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGeneral_response(s)
	}
}

func (s *General_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGeneral_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) General_response() (localctx IGeneral_responseContext) {
	localctx = NewGeneral_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SMTLIBv2ParserRULE_general_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1090)
			p.Match(SMTLIBv2ParserPS_Success)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1091)
			p.Specific_success_response()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1092)
			p.Match(SMTLIBv2ParserPS_Unsupported)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1093)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(1094)
			p.Match(SMTLIBv2ParserPS_Error)
		}
		{
			p.SetState(1095)
			p.String_()
		}
		{
			p.SetState(1096)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}
