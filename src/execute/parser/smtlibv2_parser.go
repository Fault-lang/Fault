// Code generated from SMTLIBv2.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // SMTLIBv2

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 116, 1107,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 5, 2, 207, 10, 2, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 213, 10, 4, 3, 5,
	3, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 5, 8, 223, 10, 8, 3, 9, 3, 9,
	3, 10, 3, 10, 3, 11, 3, 11, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3,
	14, 5, 14, 238, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 245,
	10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 7, 16, 252, 10, 16, 12, 16,
	14, 16, 255, 11, 16, 3, 16, 5, 16, 258, 10, 16, 3, 17, 3, 17, 5, 17, 262,
	10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 6, 18, 269, 10, 18, 13, 18,
	14, 18, 270, 3, 18, 3, 18, 5, 18, 275, 10, 18, 3, 19, 3, 19, 3, 19, 3,
	19, 7, 19, 281, 10, 19, 12, 19, 14, 19, 284, 11, 19, 3, 19, 5, 19, 287,
	10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 293, 10, 20, 3, 21, 3, 21, 3,
	21, 3, 21, 6, 21, 299, 10, 21, 13, 21, 14, 21, 300, 3, 21, 3, 21, 5, 21,
	305, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 314,
	10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24,
	3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 6, 25, 330, 10, 25, 13, 25, 14, 25,
	331, 3, 25, 3, 25, 5, 25, 336, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 6, 28, 350, 10, 28, 13,
	28, 14, 28, 351, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 6, 28, 360,
	10, 28, 13, 28, 14, 28, 361, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 6, 28, 372, 10, 28, 13, 28, 14, 28, 373, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 6, 28, 384, 10, 28, 13, 28, 14,
	28, 385, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	6, 28, 397, 10, 28, 13, 28, 14, 28, 398, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 6, 28, 408, 10, 28, 13, 28, 14, 28, 409, 3, 28, 3, 28,
	5, 28, 414, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 420, 10, 29, 12,
	29, 14, 29, 423, 11, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31,
	3, 31, 7, 31, 433, 10, 31, 12, 31, 14, 31, 436, 11, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 3, 31, 7, 31, 444, 10, 31, 12, 31, 14, 31, 447, 11, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 6, 31, 454, 10, 31, 13, 31, 14, 31,
	455, 3, 31, 7, 31, 459, 10, 31, 12, 31, 14, 31, 462, 11, 31, 3, 31, 3,
	31, 5, 31, 466, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 6, 32, 473,
	10, 32, 13, 32, 14, 32, 474, 3, 32, 3, 32, 3, 32, 3, 32, 6, 32, 481, 10,
	32, 13, 32, 14, 32, 482, 3, 32, 7, 32, 486, 10, 32, 12, 32, 14, 32, 489,
	11, 32, 3, 32, 3, 32, 3, 32, 5, 32, 494, 10, 32, 3, 33, 3, 33, 3, 33, 6,
	33, 499, 10, 33, 13, 33, 14, 33, 500, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	6, 33, 508, 10, 33, 13, 33, 14, 33, 509, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 525,
	10, 33, 3, 34, 3, 34, 3, 34, 3, 34, 6, 34, 531, 10, 34, 13, 34, 14, 34,
	532, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 6, 35, 540, 10, 35, 13, 35, 14,
	35, 541, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 5, 35, 555, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 6, 36, 561,
	10, 36, 13, 36, 14, 36, 562, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 7, 39, 580,
	10, 39, 12, 39, 14, 39, 583, 11, 39, 3, 39, 3, 39, 3, 40, 3, 40, 6, 40,
	589, 10, 40, 13, 40, 14, 40, 590, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 6, 40, 599, 10, 40, 13, 40, 14, 40, 600, 3, 40, 3, 40, 3, 40, 6, 40,
	606, 10, 40, 13, 40, 14, 40, 607, 3, 40, 3, 40, 3, 40, 5, 40, 613, 10,
	40, 3, 41, 3, 41, 3, 41, 3, 41, 7, 41, 619, 10, 41, 12, 41, 14, 41, 622,
	11, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 7, 42, 631, 10,
	42, 12, 42, 14, 42, 634, 11, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 646, 10, 43, 3, 44, 7, 44, 649,
	10, 44, 12, 44, 14, 44, 652, 11, 44, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46,
	3, 47, 3, 47, 3, 47, 7, 47, 662, 10, 47, 12, 47, 14, 47, 665, 11, 47, 3,
	47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 50,
	3, 50, 3, 50, 6, 50, 680, 10, 50, 13, 50, 14, 50, 681, 3, 50, 3, 50, 3,
	50, 6, 50, 687, 10, 50, 13, 50, 14, 50, 688, 3, 50, 3, 50, 3, 51, 3, 51,
	3, 51, 3, 51, 7, 51, 697, 10, 51, 12, 51, 14, 51, 700, 11, 51, 3, 51, 3,
	51, 3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54,
	3, 54, 3, 55, 3, 55, 3, 55, 6, 55, 718, 10, 55, 13, 55, 14, 55, 719, 3,
	55, 3, 55, 3, 55, 6, 55, 725, 10, 55, 13, 55, 14, 55, 726, 3, 55, 3, 55,
	3, 56, 3, 56, 3, 56, 3, 56, 7, 56, 735, 10, 56, 12, 56, 14, 56, 738, 11,
	56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 59, 3, 59,
	3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3,
	64, 3, 64, 3, 65, 3, 65, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 6, 67, 769,
	10, 67, 13, 67, 14, 67, 770, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 69,
	3, 69, 3, 69, 3, 70, 3, 70, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 73, 3,
	73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 914,
	10, 75, 3, 76, 3, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77,
	3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3,
	77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77,
	3, 77, 5, 77, 947, 10, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3,
	78, 3, 78, 5, 78, 957, 10, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 5, 80,
	964, 10, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 81, 5, 81, 978, 10, 81, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 993,
	10, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84,
	3, 84, 3, 85, 3, 85, 3, 86, 3, 86, 3, 87, 3, 87, 7, 87, 1011, 10, 87, 12,
	87, 14, 87, 1014, 11, 87, 3, 87, 3, 87, 3, 88, 3, 88, 7, 88, 1020, 10,
	88, 12, 88, 14, 88, 1023, 11, 88, 3, 88, 3, 88, 3, 89, 3, 89, 6, 89, 1029,
	10, 89, 13, 89, 14, 89, 1030, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 7, 90,
	1038, 10, 90, 12, 90, 14, 90, 1041, 11, 90, 3, 90, 3, 90, 3, 90, 7, 90,
	1046, 10, 90, 12, 90, 14, 90, 1049, 11, 90, 3, 90, 5, 90, 1052, 10, 90,
	3, 91, 3, 91, 3, 92, 3, 92, 3, 93, 3, 93, 7, 93, 1060, 10, 93, 12, 93,
	14, 93, 1063, 11, 93, 3, 93, 3, 93, 3, 94, 3, 94, 7, 94, 1069, 10, 94,
	12, 94, 14, 94, 1072, 11, 94, 3, 94, 3, 94, 3, 95, 3, 95, 6, 95, 1078,
	10, 95, 13, 95, 14, 95, 1079, 3, 95, 3, 95, 3, 96, 3, 96, 3, 96, 3, 96,
	3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 1095, 10, 96, 3,
	97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 5, 97, 1105, 10, 97,
	3, 97, 2, 2, 98, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
	32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
	68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
	104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132,
	134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162,
	164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192,
	2, 9, 4, 2, 55, 67, 114, 114, 3, 2, 9, 24, 3, 2, 73, 113, 5, 2, 59, 59,
	65, 65, 67, 67, 4, 2, 13, 13, 21, 21, 4, 2, 11, 11, 14, 14, 5, 2, 18, 18,
	22, 22, 24, 24, 2, 1176, 2, 206, 3, 2, 2, 2, 4, 208, 3, 2, 2, 2, 6, 212,
	3, 2, 2, 2, 8, 214, 3, 2, 2, 2, 10, 216, 3, 2, 2, 2, 12, 218, 3, 2, 2,
	2, 14, 222, 3, 2, 2, 2, 16, 224, 3, 2, 2, 2, 18, 226, 3, 2, 2, 2, 20, 228,
	3, 2, 2, 2, 22, 230, 3, 2, 2, 2, 24, 232, 3, 2, 2, 2, 26, 237, 3, 2, 2,
	2, 28, 244, 3, 2, 2, 2, 30, 257, 3, 2, 2, 2, 32, 261, 3, 2, 2, 2, 34, 274,
	3, 2, 2, 2, 36, 286, 3, 2, 2, 2, 38, 292, 3, 2, 2, 2, 40, 304, 3, 2, 2,
	2, 42, 313, 3, 2, 2, 2, 44, 315, 3, 2, 2, 2, 46, 320, 3, 2, 2, 2, 48, 335,
	3, 2, 2, 2, 50, 337, 3, 2, 2, 2, 52, 342, 3, 2, 2, 2, 54, 413, 3, 2, 2,
	2, 56, 415, 3, 2, 2, 2, 58, 426, 3, 2, 2, 2, 60, 465, 3, 2, 2, 2, 62, 493,
	3, 2, 2, 2, 64, 524, 3, 2, 2, 2, 66, 526, 3, 2, 2, 2, 68, 554, 3, 2, 2,
	2, 70, 556, 3, 2, 2, 2, 72, 566, 3, 2, 2, 2, 74, 571, 3, 2, 2, 2, 76, 576,
	3, 2, 2, 2, 78, 612, 3, 2, 2, 2, 80, 614, 3, 2, 2, 2, 82, 627, 3, 2, 2,
	2, 84, 645, 3, 2, 2, 2, 86, 650, 3, 2, 2, 2, 88, 653, 3, 2, 2, 2, 90, 656,
	3, 2, 2, 2, 92, 658, 3, 2, 2, 2, 94, 668, 3, 2, 2, 2, 96, 672, 3, 2, 2,
	2, 98, 676, 3, 2, 2, 2, 100, 692, 3, 2, 2, 2, 102, 704, 3, 2, 2, 2, 104,
	708, 3, 2, 2, 2, 106, 711, 3, 2, 2, 2, 108, 714, 3, 2, 2, 2, 110, 730,
	3, 2, 2, 2, 112, 742, 3, 2, 2, 2, 114, 745, 3, 2, 2, 2, 116, 747, 3, 2,
	2, 2, 118, 749, 3, 2, 2, 2, 120, 751, 3, 2, 2, 2, 122, 754, 3, 2, 2, 2,
	124, 756, 3, 2, 2, 2, 126, 759, 3, 2, 2, 2, 128, 761, 3, 2, 2, 2, 130,
	763, 3, 2, 2, 2, 132, 765, 3, 2, 2, 2, 134, 774, 3, 2, 2, 2, 136, 777,
	3, 2, 2, 2, 138, 780, 3, 2, 2, 2, 140, 782, 3, 2, 2, 2, 142, 784, 3, 2,
	2, 2, 144, 787, 3, 2, 2, 2, 146, 790, 3, 2, 2, 2, 148, 913, 3, 2, 2, 2,
	150, 915, 3, 2, 2, 2, 152, 946, 3, 2, 2, 2, 154, 956, 3, 2, 2, 2, 156,
	958, 3, 2, 2, 2, 158, 963, 3, 2, 2, 2, 160, 977, 3, 2, 2, 2, 162, 992,
	3, 2, 2, 2, 164, 994, 3, 2, 2, 2, 166, 999, 3, 2, 2, 2, 168, 1004, 3, 2,
	2, 2, 170, 1006, 3, 2, 2, 2, 172, 1008, 3, 2, 2, 2, 174, 1017, 3, 2, 2,
	2, 176, 1026, 3, 2, 2, 2, 178, 1051, 3, 2, 2, 2, 180, 1053, 3, 2, 2, 2,
	182, 1055, 3, 2, 2, 2, 184, 1057, 3, 2, 2, 2, 186, 1066, 3, 2, 2, 2, 188,
	1075, 3, 2, 2, 2, 190, 1094, 3, 2, 2, 2, 192, 1104, 3, 2, 2, 2, 194, 195,
	5, 70, 36, 2, 195, 196, 7, 2, 2, 3, 196, 207, 3, 2, 2, 2, 197, 198, 5,
	66, 34, 2, 198, 199, 7, 2, 2, 3, 199, 207, 3, 2, 2, 2, 200, 201, 5, 86,
	44, 2, 201, 202, 7, 2, 2, 3, 202, 207, 3, 2, 2, 2, 203, 204, 5, 192, 97,
	2, 204, 205, 7, 2, 2, 3, 205, 207, 3, 2, 2, 2, 206, 194, 3, 2, 2, 2, 206,
	197, 3, 2, 2, 2, 206, 200, 3, 2, 2, 2, 206, 203, 3, 2, 2, 2, 207, 3, 3,
	2, 2, 2, 208, 209, 9, 2, 2, 2, 209, 5, 3, 2, 2, 2, 210, 213, 5, 10, 6,
	2, 211, 213, 7, 115, 2, 2, 212, 210, 3, 2, 2, 2, 212, 211, 3, 2, 2, 2,
	213, 7, 3, 2, 2, 2, 214, 215, 7, 8, 2, 2, 215, 9, 3, 2, 2, 2, 216, 217,
	9, 3, 2, 2, 217, 11, 3, 2, 2, 2, 218, 219, 9, 4, 2, 2, 219, 13, 3, 2, 2,
	2, 220, 223, 5, 6, 4, 2, 221, 223, 5, 8, 5, 2, 222, 220, 3, 2, 2, 2, 222,
	221, 3, 2, 2, 2, 223, 15, 3, 2, 2, 2, 224, 225, 7, 68, 2, 2, 225, 17, 3,
	2, 2, 2, 226, 227, 7, 71, 2, 2, 227, 19, 3, 2, 2, 2, 228, 229, 7, 70, 2,
	2, 229, 21, 3, 2, 2, 2, 230, 231, 7, 69, 2, 2, 231, 23, 3, 2, 2, 2, 232,
	233, 7, 7, 2, 2, 233, 25, 3, 2, 2, 2, 234, 238, 5, 12, 7, 2, 235, 236,
	7, 72, 2, 2, 236, 238, 5, 6, 4, 2, 237, 234, 3, 2, 2, 2, 237, 235, 3, 2,
	2, 2, 238, 27, 3, 2, 2, 2, 239, 245, 5, 16, 9, 2, 240, 245, 5, 18, 10,
	2, 241, 245, 5, 20, 11, 2, 242, 245, 5, 22, 12, 2, 243, 245, 5, 24, 13,
	2, 244, 239, 3, 2, 2, 2, 244, 240, 3, 2, 2, 2, 244, 241, 3, 2, 2, 2, 244,
	242, 3, 2, 2, 2, 244, 243, 3, 2, 2, 2, 245, 29, 3, 2, 2, 2, 246, 258, 5,
	28, 15, 2, 247, 258, 5, 14, 8, 2, 248, 258, 5, 26, 14, 2, 249, 253, 7,
	4, 2, 2, 250, 252, 5, 30, 16, 2, 251, 250, 3, 2, 2, 2, 252, 255, 3, 2,
	2, 2, 253, 251, 3, 2, 2, 2, 253, 254, 3, 2, 2, 2, 254, 256, 3, 2, 2, 2,
	255, 253, 3, 2, 2, 2, 256, 258, 7, 5, 2, 2, 257, 246, 3, 2, 2, 2, 257,
	247, 3, 2, 2, 2, 257, 248, 3, 2, 2, 2, 257, 249, 3, 2, 2, 2, 258, 31, 3,
	2, 2, 2, 259, 262, 5, 16, 9, 2, 260, 262, 5, 14, 8, 2, 261, 259, 3, 2,
	2, 2, 261, 260, 3, 2, 2, 2, 262, 33, 3, 2, 2, 2, 263, 275, 5, 14, 8, 2,
	264, 265, 7, 4, 2, 2, 265, 266, 7, 56, 2, 2, 266, 268, 5, 14, 8, 2, 267,
	269, 5, 32, 17, 2, 268, 267, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 268,
	3, 2, 2, 2, 270, 271, 3, 2, 2, 2, 271, 272, 3, 2, 2, 2, 272, 273, 7, 5,
	2, 2, 273, 275, 3, 2, 2, 2, 274, 263, 3, 2, 2, 2, 274, 264, 3, 2, 2, 2,
	275, 35, 3, 2, 2, 2, 276, 287, 5, 28, 15, 2, 277, 287, 5, 14, 8, 2, 278,
	282, 7, 4, 2, 2, 279, 281, 5, 30, 16, 2, 280, 279, 3, 2, 2, 2, 281, 284,
	3, 2, 2, 2, 282, 280, 3, 2, 2, 2, 282, 283, 3, 2, 2, 2, 283, 285, 3, 2,
	2, 2, 284, 282, 3, 2, 2, 2, 285, 287, 7, 5, 2, 2, 286, 276, 3, 2, 2, 2,
	286, 277, 3, 2, 2, 2, 286, 278, 3, 2, 2, 2, 287, 37, 3, 2, 2, 2, 288, 293,
	5, 26, 14, 2, 289, 290, 5, 26, 14, 2, 290, 291, 5, 36, 19, 2, 291, 293,
	3, 2, 2, 2, 292, 288, 3, 2, 2, 2, 292, 289, 3, 2, 2, 2, 293, 39, 3, 2,
	2, 2, 294, 305, 5, 34, 18, 2, 295, 296, 7, 4, 2, 2, 296, 298, 5, 34, 18,
	2, 297, 299, 5, 40, 21, 2, 298, 297, 3, 2, 2, 2, 299, 300, 3, 2, 2, 2,
	300, 298, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 302, 3, 2, 2, 2, 302,
	303, 7, 5, 2, 2, 303, 305, 3, 2, 2, 2, 304, 294, 3, 2, 2, 2, 304, 295,
	3, 2, 2, 2, 305, 41, 3, 2, 2, 2, 306, 314, 5, 34, 18, 2, 307, 308, 7, 4,
	2, 2, 308, 309, 7, 57, 2, 2, 309, 310, 5, 34, 18, 2, 310, 311, 5, 40, 21,
	2, 311, 312, 7, 5, 2, 2, 312, 314, 3, 2, 2, 2, 313, 306, 3, 2, 2, 2, 313,
	307, 3, 2, 2, 2, 314, 43, 3, 2, 2, 2, 315, 316, 7, 4, 2, 2, 316, 317, 5,
	14, 8, 2, 317, 318, 5, 54, 28, 2, 318, 319, 7, 5, 2, 2, 319, 45, 3, 2,
	2, 2, 320, 321, 7, 4, 2, 2, 321, 322, 5, 14, 8, 2, 322, 323, 5, 40, 21,
	2, 323, 324, 7, 5, 2, 2, 324, 47, 3, 2, 2, 2, 325, 336, 5, 14, 8, 2, 326,
	327, 7, 4, 2, 2, 327, 329, 5, 14, 8, 2, 328, 330, 5, 14, 8, 2, 329, 328,
	3, 2, 2, 2, 330, 331, 3, 2, 2, 2, 331, 329, 3, 2, 2, 2, 331, 332, 3, 2,
	2, 2, 332, 333, 3, 2, 2, 2, 333, 334, 7, 5, 2, 2, 334, 336, 3, 2, 2, 2,
	335, 325, 3, 2, 2, 2, 335, 326, 3, 2, 2, 2, 336, 49, 3, 2, 2, 2, 337, 338,
	7, 4, 2, 2, 338, 339, 5, 48, 25, 2, 339, 340, 5, 54, 28, 2, 340, 341, 7,
	5, 2, 2, 341, 51, 3, 2, 2, 2, 342, 343, 5, 14, 8, 2, 343, 53, 3, 2, 2,
	2, 344, 414, 5, 28, 15, 2, 345, 414, 5, 42, 22, 2, 346, 347, 7, 4, 2, 2,
	347, 349, 5, 42, 22, 2, 348, 350, 5, 54, 28, 2, 349, 348, 3, 2, 2, 2, 350,
	351, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352, 353,
	3, 2, 2, 2, 353, 354, 7, 5, 2, 2, 354, 414, 3, 2, 2, 2, 355, 356, 7, 4,
	2, 2, 356, 357, 7, 63, 2, 2, 357, 359, 7, 4, 2, 2, 358, 360, 5, 44, 23,
	2, 359, 358, 3, 2, 2, 2, 360, 361, 3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 361,
	362, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 364, 7, 5, 2, 2, 364, 365,
	5, 54, 28, 2, 365, 366, 7, 5, 2, 2, 366, 414, 3, 2, 2, 2, 367, 368, 7,
	4, 2, 2, 368, 369, 7, 62, 2, 2, 369, 371, 7, 4, 2, 2, 370, 372, 5, 46,
	24, 2, 371, 370, 3, 2, 2, 2, 372, 373, 3, 2, 2, 2, 373, 371, 3, 2, 2, 2,
	373, 374, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 376, 7, 5, 2, 2, 376,
	377, 5, 54, 28, 2, 377, 378, 7, 5, 2, 2, 378, 414, 3, 2, 2, 2, 379, 380,
	7, 4, 2, 2, 380, 381, 7, 60, 2, 2, 381, 383, 7, 4, 2, 2, 382, 384, 5, 46,
	24, 2, 383, 382, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2, 385, 383, 3, 2, 2, 2,
	385, 386, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 388, 7, 5, 2, 2, 388,
	389, 5, 54, 28, 2, 389, 390, 7, 5, 2, 2, 390, 414, 3, 2, 2, 2, 391, 392,
	7, 4, 2, 2, 392, 393, 7, 64, 2, 2, 393, 394, 5, 54, 28, 2, 394, 396, 7,
	4, 2, 2, 395, 397, 5, 50, 26, 2, 396, 395, 3, 2, 2, 2, 397, 398, 3, 2,
	2, 2, 398, 396, 3, 2, 2, 2, 398, 399, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2,
	400, 401, 7, 5, 2, 2, 401, 402, 7, 5, 2, 2, 402, 414, 3, 2, 2, 2, 403,
	404, 7, 4, 2, 2, 404, 405, 7, 55, 2, 2, 405, 407, 5, 54, 28, 2, 406, 408,
	5, 38, 20, 2, 407, 406, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2, 409, 407, 3,
	2, 2, 2, 409, 410, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411, 412, 7, 5, 2,
	2, 412, 414, 3, 2, 2, 2, 413, 344, 3, 2, 2, 2, 413, 345, 3, 2, 2, 2, 413,
	346, 3, 2, 2, 2, 413, 355, 3, 2, 2, 2, 413, 367, 3, 2, 2, 2, 413, 379,
	3, 2, 2, 2, 413, 391, 3, 2, 2, 2, 413, 403, 3, 2, 2, 2, 414, 55, 3, 2,
	2, 2, 415, 416, 7, 4, 2, 2, 416, 417, 5, 34, 18, 2, 417, 421, 5, 16, 9,
	2, 418, 420, 5, 38, 20, 2, 419, 418, 3, 2, 2, 2, 420, 423, 3, 2, 2, 2,
	421, 419, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 424, 3, 2, 2, 2, 423,
	421, 3, 2, 2, 2, 424, 425, 7, 5, 2, 2, 425, 57, 3, 2, 2, 2, 426, 427, 9,
	5, 2, 2, 427, 59, 3, 2, 2, 2, 428, 429, 7, 4, 2, 2, 429, 430, 5, 28, 15,
	2, 430, 434, 5, 40, 21, 2, 431, 433, 5, 38, 20, 2, 432, 431, 3, 2, 2, 2,
	433, 436, 3, 2, 2, 2, 434, 432, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435,
	437, 3, 2, 2, 2, 436, 434, 3, 2, 2, 2, 437, 438, 7, 5, 2, 2, 438, 466,
	3, 2, 2, 2, 439, 440, 7, 4, 2, 2, 440, 441, 5, 58, 30, 2, 441, 445, 5,
	40, 21, 2, 442, 444, 5, 38, 20, 2, 443, 442, 3, 2, 2, 2, 444, 447, 3, 2,
	2, 2, 445, 443, 3, 2, 2, 2, 445, 446, 3, 2, 2, 2, 446, 448, 3, 2, 2, 2,
	447, 445, 3, 2, 2, 2, 448, 449, 7, 5, 2, 2, 449, 466, 3, 2, 2, 2, 450,
	451, 7, 4, 2, 2, 451, 453, 5, 34, 18, 2, 452, 454, 5, 40, 21, 2, 453, 452,
	3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 453, 3, 2, 2, 2, 455, 456, 3, 2,
	2, 2, 456, 460, 3, 2, 2, 2, 457, 459, 5, 38, 20, 2, 458, 457, 3, 2, 2,
	2, 459, 462, 3, 2, 2, 2, 460, 458, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461,
	463, 3, 2, 2, 2, 462, 460, 3, 2, 2, 2, 463, 464, 7, 5, 2, 2, 464, 466,
	3, 2, 2, 2, 465, 428, 3, 2, 2, 2, 465, 439, 3, 2, 2, 2, 465, 450, 3, 2,
	2, 2, 466, 61, 3, 2, 2, 2, 467, 494, 5, 60, 31, 2, 468, 469, 7, 4, 2, 2,
	469, 470, 7, 66, 2, 2, 470, 472, 7, 4, 2, 2, 471, 473, 5, 14, 8, 2, 472,
	471, 3, 2, 2, 2, 473, 474, 3, 2, 2, 2, 474, 472, 3, 2, 2, 2, 474, 475,
	3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 477, 7, 5, 2, 2, 477, 478, 7, 4,
	2, 2, 478, 480, 5, 34, 18, 2, 479, 481, 5, 40, 21, 2, 480, 479, 3, 2, 2,
	2, 481, 482, 3, 2, 2, 2, 482, 480, 3, 2, 2, 2, 482, 483, 3, 2, 2, 2, 483,
	487, 3, 2, 2, 2, 484, 486, 5, 38, 20, 2, 485, 484, 3, 2, 2, 2, 486, 489,
	3, 2, 2, 2, 487, 485, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 488, 490, 3, 2,
	2, 2, 489, 487, 3, 2, 2, 2, 490, 491, 7, 5, 2, 2, 491, 492, 7, 5, 2, 2,
	492, 494, 3, 2, 2, 2, 493, 467, 3, 2, 2, 2, 493, 468, 3, 2, 2, 2, 494,
	63, 3, 2, 2, 2, 495, 496, 7, 106, 2, 2, 496, 498, 7, 4, 2, 2, 497, 499,
	5, 56, 29, 2, 498, 497, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 498, 3,
	2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502, 503, 7, 5, 2,
	2, 503, 525, 3, 2, 2, 2, 504, 505, 7, 82, 2, 2, 505, 507, 7, 4, 2, 2, 506,
	508, 5, 62, 32, 2, 507, 506, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 507,
	3, 2, 2, 2, 509, 510, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 512, 7, 5,
	2, 2, 512, 525, 3, 2, 2, 2, 513, 514, 7, 107, 2, 2, 514, 525, 5, 24, 13,
	2, 515, 516, 7, 83, 2, 2, 516, 525, 5, 24, 13, 2, 517, 518, 7, 78, 2, 2,
	518, 525, 5, 24, 13, 2, 519, 520, 7, 111, 2, 2, 520, 525, 5, 24, 13, 2,
	521, 522, 7, 91, 2, 2, 522, 525, 5, 24, 13, 2, 523, 525, 5, 38, 20, 2,
	524, 495, 3, 2, 2, 2, 524, 504, 3, 2, 2, 2, 524, 513, 3, 2, 2, 2, 524,
	515, 3, 2, 2, 2, 524, 517, 3, 2, 2, 2, 524, 519, 3, 2, 2, 2, 524, 521,
	3, 2, 2, 2, 524, 523, 3, 2, 2, 2, 525, 65, 3, 2, 2, 2, 526, 527, 7, 4,
	2, 2, 527, 528, 7, 20, 2, 2, 528, 530, 5, 14, 8, 2, 529, 531, 5, 64, 33,
	2, 530, 529, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 530, 3, 2, 2, 2, 532,
	533, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 535, 7, 5, 2, 2, 535, 67, 3,
	2, 2, 2, 536, 537, 7, 110, 2, 2, 537, 539, 7, 4, 2, 2, 538, 540, 5, 14,
	8, 2, 539, 538, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2,
	541, 542, 3, 2, 2, 2, 542, 543, 3, 2, 2, 2, 543, 544, 7, 5, 2, 2, 544,
	555, 3, 2, 2, 2, 545, 546, 7, 86, 2, 2, 546, 555, 5, 24, 13, 2, 547, 548,
	7, 81, 2, 2, 548, 555, 5, 24, 13, 2, 549, 550, 7, 111, 2, 2, 550, 555,
	5, 24, 13, 2, 551, 552, 7, 91, 2, 2, 552, 555, 5, 24, 13, 2, 553, 555,
	5, 38, 20, 2, 554, 536, 3, 2, 2, 2, 554, 545, 3, 2, 2, 2, 554, 547, 3,
	2, 2, 2, 554, 549, 3, 2, 2, 2, 554, 551, 3, 2, 2, 2, 554, 553, 3, 2, 2,
	2, 555, 69, 3, 2, 2, 2, 556, 557, 7, 4, 2, 2, 557, 558, 7, 16, 2, 2, 558,
	560, 5, 14, 8, 2, 559, 561, 5, 68, 35, 2, 560, 559, 3, 2, 2, 2, 561, 562,
	3, 2, 2, 2, 562, 560, 3, 2, 2, 2, 562, 563, 3, 2, 2, 2, 563, 564, 3, 2,
	2, 2, 564, 565, 7, 5, 2, 2, 565, 71, 3, 2, 2, 2, 566, 567, 7, 4, 2, 2,
	567, 568, 5, 14, 8, 2, 568, 569, 5, 16, 9, 2, 569, 570, 7, 5, 2, 2, 570,
	73, 3, 2, 2, 2, 571, 572, 7, 4, 2, 2, 572, 573, 5, 14, 8, 2, 573, 574,
	5, 40, 21, 2, 574, 575, 7, 5, 2, 2, 575, 75, 3, 2, 2, 2, 576, 577, 7, 4,
	2, 2, 577, 581, 5, 14, 8, 2, 578, 580, 5, 74, 38, 2, 579, 578, 3, 2, 2,
	2, 580, 583, 3, 2, 2, 2, 581, 579, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582,
	584, 3, 2, 2, 2, 583, 581, 3, 2, 2, 2, 584, 585, 7, 5, 2, 2, 585, 77, 3,
	2, 2, 2, 586, 588, 7, 4, 2, 2, 587, 589, 5, 76, 39, 2, 588, 587, 3, 2,
	2, 2, 589, 590, 3, 2, 2, 2, 590, 588, 3, 2, 2, 2, 590, 591, 3, 2, 2, 2,
	591, 592, 3, 2, 2, 2, 592, 593, 7, 5, 2, 2, 593, 613, 3, 2, 2, 2, 594,
	595, 7, 4, 2, 2, 595, 596, 7, 66, 2, 2, 596, 598, 7, 4, 2, 2, 597, 599,
	5, 14, 8, 2, 598, 597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 598, 3, 2,
	2, 2, 600, 601, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 603, 7, 5, 2, 2,
	603, 605, 7, 4, 2, 2, 604, 606, 5, 76, 39, 2, 605, 604, 3, 2, 2, 2, 606,
	607, 3, 2, 2, 2, 607, 605, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608, 609,
	3, 2, 2, 2, 609, 610, 7, 5, 2, 2, 610, 611, 7, 5, 2, 2, 611, 613, 3, 2,
	2, 2, 612, 586, 3, 2, 2, 2, 612, 594, 3, 2, 2, 2, 613, 79, 3, 2, 2, 2,
	614, 615, 7, 4, 2, 2, 615, 616, 5, 14, 8, 2, 616, 620, 7, 4, 2, 2, 617,
	619, 5, 46, 24, 2, 618, 617, 3, 2, 2, 2, 619, 622, 3, 2, 2, 2, 620, 618,
	3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 623, 3, 2, 2, 2, 622, 620, 3, 2,
	2, 2, 623, 624, 7, 5, 2, 2, 624, 625, 5, 40, 21, 2, 625, 626, 7, 5, 2,
	2, 626, 81, 3, 2, 2, 2, 627, 628, 5, 52, 27, 2, 628, 632, 7, 4, 2, 2, 629,
	631, 5, 46, 24, 2, 630, 629, 3, 2, 2, 2, 631, 634, 3, 2, 2, 2, 632, 630,
	3, 2, 2, 2, 632, 633, 3, 2, 2, 2, 633, 635, 3, 2, 2, 2, 634, 632, 3, 2,
	2, 2, 635, 636, 7, 5, 2, 2, 636, 637, 5, 40, 21, 2, 637, 638, 5, 54, 28,
	2, 638, 83, 3, 2, 2, 2, 639, 646, 5, 14, 8, 2, 640, 641, 7, 4, 2, 2, 641,
	642, 7, 9, 2, 2, 642, 643, 5, 14, 8, 2, 643, 644, 7, 5, 2, 2, 644, 646,
	3, 2, 2, 2, 645, 639, 3, 2, 2, 2, 645, 640, 3, 2, 2, 2, 646, 85, 3, 2,
	2, 2, 647, 649, 5, 148, 75, 2, 648, 647, 3, 2, 2, 2, 649, 652, 3, 2, 2,
	2, 650, 648, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 87, 3, 2, 2, 2, 652,
	650, 3, 2, 2, 2, 653, 654, 7, 25, 2, 2, 654, 655, 5, 54, 28, 2, 655, 89,
	3, 2, 2, 2, 656, 657, 7, 26, 2, 2, 657, 91, 3, 2, 2, 2, 658, 659, 7, 27,
	2, 2, 659, 663, 7, 4, 2, 2, 660, 662, 5, 84, 43, 2, 661, 660, 3, 2, 2,
	2, 662, 665, 3, 2, 2, 2, 663, 661, 3, 2, 2, 2, 663, 664, 3, 2, 2, 2, 664,
	666, 3, 2, 2, 2, 665, 663, 3, 2, 2, 2, 666, 667, 7, 5, 2, 2, 667, 93, 3,
	2, 2, 2, 668, 669, 7, 28, 2, 2, 669, 670, 5, 14, 8, 2, 670, 671, 5, 40,
	21, 2, 671, 95, 3, 2, 2, 2, 672, 673, 7, 29, 2, 2, 673, 674, 5, 14, 8,
	2, 674, 675, 5, 78, 40, 2, 675, 97, 3, 2, 2, 2, 676, 677, 7, 30, 2, 2,
	677, 679, 7, 4, 2, 2, 678, 680, 5, 72, 37, 2, 679, 678, 3, 2, 2, 2, 680,
	681, 3, 2, 2, 2, 681, 679, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 682, 683,
	3, 2, 2, 2, 683, 684, 7, 5, 2, 2, 684, 686, 7, 4, 2, 2, 685, 687, 5, 78,
	40, 2, 686, 685, 3, 2, 2, 2, 687, 688, 3, 2, 2, 2, 688, 686, 3, 2, 2, 2,
	688, 689, 3, 2, 2, 2, 689, 690, 3, 2, 2, 2, 690, 691, 7, 5, 2, 2, 691,
	99, 3, 2, 2, 2, 692, 693, 7, 31, 2, 2, 693, 694, 5, 14, 8, 2, 694, 698,
	7, 4, 2, 2, 695, 697, 5, 40, 21, 2, 696, 695, 3, 2, 2, 2, 697, 700, 3,
	2, 2, 2, 698, 696, 3, 2, 2, 2, 698, 699, 3, 2, 2, 2, 699, 701, 3, 2, 2,
	2, 700, 698, 3, 2, 2, 2, 701, 702, 7, 5, 2, 2, 702, 703, 5, 40, 21, 2,
	703, 101, 3, 2, 2, 2, 704, 705, 7, 32, 2, 2, 705, 706, 5, 14, 8, 2, 706,
	707, 5, 16, 9, 2, 707, 103, 3, 2, 2, 2, 708, 709, 7, 33, 2, 2, 709, 710,
	5, 82, 42, 2, 710, 105, 3, 2, 2, 2, 711, 712, 7, 34, 2, 2, 712, 713, 5,
	82, 42, 2, 713, 107, 3, 2, 2, 2, 714, 715, 7, 35, 2, 2, 715, 717, 7, 4,
	2, 2, 716, 718, 5, 80, 41, 2, 717, 716, 3, 2, 2, 2, 718, 719, 3, 2, 2,
	2, 719, 717, 3, 2, 2, 2, 719, 720, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721,
	722, 7, 5, 2, 2, 722, 724, 7, 4, 2, 2, 723, 725, 5, 54, 28, 2, 724, 723,
	3, 2, 2, 2, 725, 726, 3, 2, 2, 2, 726, 724, 3, 2, 2, 2, 726, 727, 3, 2,
	2, 2, 727, 728, 3, 2, 2, 2, 728, 729, 7, 5, 2, 2, 729, 109, 3, 2, 2, 2,
	730, 731, 7, 36, 2, 2, 731, 732, 5, 14, 8, 2, 732, 736, 7, 4, 2, 2, 733,
	735, 5, 14, 8, 2, 734, 733, 3, 2, 2, 2, 735, 738, 3, 2, 2, 2, 736, 734,
	3, 2, 2, 2, 736, 737, 3, 2, 2, 2, 737, 739, 3, 2, 2, 2, 738, 736, 3, 2,
	2, 2, 739, 740, 7, 5, 2, 2, 740, 741, 5, 40, 21, 2, 741, 111, 3, 2, 2,
	2, 742, 743, 7, 37, 2, 2, 743, 744, 5, 24, 13, 2, 744, 113, 3, 2, 2, 2,
	745, 746, 7, 38, 2, 2, 746, 115, 3, 2, 2, 2, 747, 748, 7, 39, 2, 2, 748,
	117, 3, 2, 2, 2, 749, 750, 7, 40, 2, 2, 750, 119, 3, 2, 2, 2, 751, 752,
	7, 41, 2, 2, 752, 753, 5, 154, 78, 2, 753, 121, 3, 2, 2, 2, 754, 755, 7,
	42, 2, 2, 755, 123, 3, 2, 2, 2, 756, 757, 7, 43, 2, 2, 757, 758, 5, 26,
	14, 2, 758, 125, 3, 2, 2, 2, 759, 760, 7, 44, 2, 2, 760, 127, 3, 2, 2,
	2, 761, 762, 7, 45, 2, 2, 762, 129, 3, 2, 2, 2, 763, 764, 7, 46, 2, 2,
	764, 131, 3, 2, 2, 2, 765, 766, 7, 47, 2, 2, 766, 768, 7, 4, 2, 2, 767,
	769, 5, 54, 28, 2, 768, 767, 3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 768,
	3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 772, 3, 2, 2, 2, 772, 773, 7, 5,
	2, 2, 773, 133, 3, 2, 2, 2, 774, 775, 7, 48, 2, 2, 775, 776, 5, 16, 9,
	2, 776, 135, 3, 2, 2, 2, 777, 778, 7, 49, 2, 2, 778, 779, 5, 16, 9, 2,
	779, 137, 3, 2, 2, 2, 780, 781, 7, 50, 2, 2, 781, 139, 3, 2, 2, 2, 782,
	783, 7, 51, 2, 2, 783, 141, 3, 2, 2, 2, 784, 785, 7, 52, 2, 2, 785, 786,
	5, 38, 20, 2, 786, 143, 3, 2, 2, 2, 787, 788, 7, 53, 2, 2, 788, 789, 5,
	14, 8, 2, 789, 145, 3, 2, 2, 2, 790, 791, 7, 54, 2, 2, 791, 792, 5, 152,
	77, 2, 792, 147, 3, 2, 2, 2, 793, 794, 7, 4, 2, 2, 794, 795, 5, 88, 45,
	2, 795, 796, 7, 5, 2, 2, 796, 914, 3, 2, 2, 2, 797, 798, 7, 4, 2, 2, 798,
	799, 5, 90, 46, 2, 799, 800, 7, 5, 2, 2, 800, 914, 3, 2, 2, 2, 801, 802,
	7, 4, 2, 2, 802, 803, 5, 92, 47, 2, 803, 804, 7, 5, 2, 2, 804, 914, 3,
	2, 2, 2, 805, 806, 7, 4, 2, 2, 806, 807, 5, 94, 48, 2, 807, 808, 7, 5,
	2, 2, 808, 914, 3, 2, 2, 2, 809, 810, 7, 4, 2, 2, 810, 811, 5, 96, 49,
	2, 811, 812, 7, 5, 2, 2, 812, 914, 3, 2, 2, 2, 813, 814, 7, 4, 2, 2, 814,
	815, 5, 98, 50, 2, 815, 816, 7, 5, 2, 2, 816, 914, 3, 2, 2, 2, 817, 818,
	7, 4, 2, 2, 818, 819, 5, 100, 51, 2, 819, 820, 7, 5, 2, 2, 820, 914, 3,
	2, 2, 2, 821, 822, 7, 4, 2, 2, 822, 823, 5, 102, 52, 2, 823, 824, 7, 5,
	2, 2, 824, 914, 3, 2, 2, 2, 825, 826, 7, 4, 2, 2, 826, 827, 5, 104, 53,
	2, 827, 828, 7, 5, 2, 2, 828, 914, 3, 2, 2, 2, 829, 830, 7, 4, 2, 2, 830,
	831, 5, 106, 54, 2, 831, 832, 7, 5, 2, 2, 832, 914, 3, 2, 2, 2, 833, 834,
	7, 4, 2, 2, 834, 835, 5, 108, 55, 2, 835, 836, 7, 5, 2, 2, 836, 914, 3,
	2, 2, 2, 837, 838, 7, 4, 2, 2, 838, 839, 5, 110, 56, 2, 839, 840, 7, 5,
	2, 2, 840, 914, 3, 2, 2, 2, 841, 842, 7, 4, 2, 2, 842, 843, 5, 112, 57,
	2, 843, 844, 7, 5, 2, 2, 844, 914, 3, 2, 2, 2, 845, 846, 7, 4, 2, 2, 846,
	847, 5, 114, 58, 2, 847, 848, 7, 5, 2, 2, 848, 914, 3, 2, 2, 2, 849, 850,
	7, 4, 2, 2, 850, 851, 5, 116, 59, 2, 851, 852, 7, 5, 2, 2, 852, 914, 3,
	2, 2, 2, 853, 854, 7, 4, 2, 2, 854, 855, 5, 118, 60, 2, 855, 856, 7, 5,
	2, 2, 856, 914, 3, 2, 2, 2, 857, 858, 7, 4, 2, 2, 858, 859, 5, 120, 61,
	2, 859, 860, 7, 5, 2, 2, 860, 914, 3, 2, 2, 2, 861, 862, 7, 4, 2, 2, 862,
	863, 5, 122, 62, 2, 863, 864, 7, 5, 2, 2, 864, 914, 3, 2, 2, 2, 865, 866,
	7, 4, 2, 2, 866, 867, 5, 124, 63, 2, 867, 868, 7, 5, 2, 2, 868, 914, 3,
	2, 2, 2, 869, 870, 7, 4, 2, 2, 870, 871, 5, 126, 64, 2, 871, 872, 7, 5,
	2, 2, 872, 914, 3, 2, 2, 2, 873, 874, 7, 4, 2, 2, 874, 875, 5, 128, 65,
	2, 875, 876, 7, 5, 2, 2, 876, 914, 3, 2, 2, 2, 877, 878, 7, 4, 2, 2, 878,
	879, 5, 130, 66, 2, 879, 880, 7, 5, 2, 2, 880, 914, 3, 2, 2, 2, 881, 882,
	7, 4, 2, 2, 882, 883, 5, 132, 67, 2, 883, 884, 7, 5, 2, 2, 884, 914, 3,
	2, 2, 2, 885, 886, 7, 4, 2, 2, 886, 887, 5, 134, 68, 2, 887, 888, 7, 5,
	2, 2, 888, 914, 3, 2, 2, 2, 889, 890, 7, 4, 2, 2, 890, 891, 5, 136, 69,
	2, 891, 892, 7, 5, 2, 2, 892, 914, 3, 2, 2, 2, 893, 894, 7, 4, 2, 2, 894,
	895, 5, 138, 70, 2, 895, 896, 7, 5, 2, 2, 896, 914, 3, 2, 2, 2, 897, 898,
	7, 4, 2, 2, 898, 899, 5, 140, 71, 2, 899, 900, 7, 5, 2, 2, 900, 914, 3,
	2, 2, 2, 901, 902, 7, 4, 2, 2, 902, 903, 5, 142, 72, 2, 903, 904, 7, 5,
	2, 2, 904, 914, 3, 2, 2, 2, 905, 906, 7, 4, 2, 2, 906, 907, 5, 144, 73,
	2, 907, 908, 7, 5, 2, 2, 908, 914, 3, 2, 2, 2, 909, 910, 7, 4, 2, 2, 910,
	911, 5, 146, 74, 2, 911, 912, 7, 5, 2, 2, 912, 914, 3, 2, 2, 2, 913, 793,
	3, 2, 2, 2, 913, 797, 3, 2, 2, 2, 913, 801, 3, 2, 2, 2, 913, 805, 3, 2,
	2, 2, 913, 809, 3, 2, 2, 2, 913, 813, 3, 2, 2, 2, 913, 817, 3, 2, 2, 2,
	913, 821, 3, 2, 2, 2, 913, 825, 3, 2, 2, 2, 913, 829, 3, 2, 2, 2, 913,
	833, 3, 2, 2, 2, 913, 837, 3, 2, 2, 2, 913, 841, 3, 2, 2, 2, 913, 845,
	3, 2, 2, 2, 913, 849, 3, 2, 2, 2, 913, 853, 3, 2, 2, 2, 913, 857, 3, 2,
	2, 2, 913, 861, 3, 2, 2, 2, 913, 865, 3, 2, 2, 2, 913, 869, 3, 2, 2, 2,
	913, 873, 3, 2, 2, 2, 913, 877, 3, 2, 2, 2, 913, 881, 3, 2, 2, 2, 913,
	885, 3, 2, 2, 2, 913, 889, 3, 2, 2, 2, 913, 893, 3, 2, 2, 2, 913, 897,
	3, 2, 2, 2, 913, 901, 3, 2, 2, 2, 913, 905, 3, 2, 2, 2, 913, 909, 3, 2,
	2, 2, 914, 149, 3, 2, 2, 2, 915, 916, 9, 6, 2, 2, 916, 151, 3, 2, 2, 2,
	917, 918, 7, 79, 2, 2, 918, 947, 5, 24, 13, 2, 919, 920, 7, 84, 2, 2, 920,
	947, 5, 150, 76, 2, 921, 922, 7, 85, 2, 2, 922, 947, 5, 150, 76, 2, 923,
	924, 7, 93, 2, 2, 924, 947, 5, 150, 76, 2, 925, 926, 7, 94, 2, 2, 926,
	947, 5, 150, 76, 2, 927, 928, 7, 95, 2, 2, 928, 947, 5, 150, 76, 2, 929,
	930, 7, 96, 2, 2, 930, 947, 5, 150, 76, 2, 931, 932, 7, 97, 2, 2, 932,
	947, 5, 150, 76, 2, 933, 934, 7, 98, 2, 2, 934, 947, 5, 150, 76, 2, 935,
	936, 7, 99, 2, 2, 936, 947, 5, 150, 76, 2, 937, 938, 7, 100, 2, 2, 938,
	947, 5, 16, 9, 2, 939, 940, 7, 102, 2, 2, 940, 947, 5, 24, 13, 2, 941,
	942, 7, 103, 2, 2, 942, 947, 5, 16, 9, 2, 943, 944, 7, 112, 2, 2, 944,
	947, 5, 16, 9, 2, 945, 947, 5, 38, 20, 2, 946, 917, 3, 2, 2, 2, 946, 919,
	3, 2, 2, 2, 946, 921, 3, 2, 2, 2, 946, 923, 3, 2, 2, 2, 946, 925, 3, 2,
	2, 2, 946, 927, 3, 2, 2, 2, 946, 929, 3, 2, 2, 2, 946, 931, 3, 2, 2, 2,
	946, 933, 3, 2, 2, 2, 946, 935, 3, 2, 2, 2, 946, 937, 3, 2, 2, 2, 946,
	939, 3, 2, 2, 2, 946, 941, 3, 2, 2, 2, 946, 943, 3, 2, 2, 2, 946, 945,
	3, 2, 2, 2, 947, 153, 3, 2, 2, 2, 948, 957, 7, 73, 2, 2, 949, 957, 7, 74,
	2, 2, 950, 957, 7, 75, 2, 2, 951, 957, 7, 80, 2, 2, 952, 957, 7, 90, 2,
	2, 953, 957, 7, 101, 2, 2, 954, 957, 7, 113, 2, 2, 955, 957, 5, 26, 14,
	2, 956, 948, 3, 2, 2, 2, 956, 949, 3, 2, 2, 2, 956, 950, 3, 2, 2, 2, 956,
	951, 3, 2, 2, 2, 956, 952, 3, 2, 2, 2, 956, 953, 3, 2, 2, 2, 956, 954,
	3, 2, 2, 2, 956, 955, 3, 2, 2, 2, 957, 155, 3, 2, 2, 2, 958, 959, 9, 7,
	2, 2, 959, 157, 3, 2, 2, 2, 960, 964, 7, 17, 2, 2, 961, 964, 7, 15, 2,
	2, 962, 964, 5, 30, 16, 2, 963, 960, 3, 2, 2, 2, 963, 961, 3, 2, 2, 2,
	963, 962, 3, 2, 2, 2, 964, 159, 3, 2, 2, 2, 965, 966, 7, 4, 2, 2, 966,
	967, 5, 104, 53, 2, 967, 968, 7, 5, 2, 2, 968, 978, 3, 2, 2, 2, 969, 970,
	7, 4, 2, 2, 970, 971, 5, 106, 54, 2, 971, 972, 7, 5, 2, 2, 972, 978, 3,
	2, 2, 2, 973, 974, 7, 4, 2, 2, 974, 975, 5, 108, 55, 2, 975, 976, 7, 5,
	2, 2, 976, 978, 3, 2, 2, 2, 977, 965, 3, 2, 2, 2, 977, 969, 3, 2, 2, 2,
	977, 973, 3, 2, 2, 2, 978, 161, 3, 2, 2, 2, 979, 980, 7, 74, 2, 2, 980,
	993, 5, 16, 9, 2, 981, 982, 7, 75, 2, 2, 982, 993, 5, 24, 13, 2, 983, 984,
	7, 80, 2, 2, 984, 993, 5, 156, 79, 2, 985, 986, 7, 90, 2, 2, 986, 993,
	5, 24, 13, 2, 987, 988, 7, 101, 2, 2, 988, 993, 5, 158, 80, 2, 989, 990,
	7, 113, 2, 2, 990, 993, 5, 24, 13, 2, 991, 993, 5, 38, 20, 2, 992, 979,
	3, 2, 2, 2, 992, 981, 3, 2, 2, 2, 992, 983, 3, 2, 2, 2, 992, 985, 3, 2,
	2, 2, 992, 987, 3, 2, 2, 2, 992, 989, 3, 2, 2, 2, 992, 991, 3, 2, 2, 2,
	993, 163, 3, 2, 2, 2, 994, 995, 7, 4, 2, 2, 995, 996, 5, 54, 28, 2, 996,
	997, 5, 54, 28, 2, 997, 998, 7, 5, 2, 2, 998, 165, 3, 2, 2, 2, 999, 1000,
	7, 4, 2, 2, 1000, 1001, 5, 14, 8, 2, 1001, 1002, 5, 150, 76, 2, 1002, 1003,
	7, 5, 2, 2, 1003, 167, 3, 2, 2, 2, 1004, 1005, 9, 8, 2, 2, 1005, 169, 3,
	2, 2, 2, 1006, 1007, 5, 24, 13, 2, 1007, 171, 3, 2, 2, 2, 1008, 1012, 7,
	4, 2, 2, 1009, 1011, 5, 54, 28, 2, 1010, 1009, 3, 2, 2, 2, 1011, 1014,
	3, 2, 2, 2, 1012, 1010, 3, 2, 2, 2, 1012, 1013, 3, 2, 2, 2, 1013, 1015,
	3, 2, 2, 2, 1014, 1012, 3, 2, 2, 2, 1015, 1016, 7, 5, 2, 2, 1016, 173,
	3, 2, 2, 2, 1017, 1021, 7, 4, 2, 2, 1018, 1020, 5, 166, 84, 2, 1019, 1018,
	3, 2, 2, 2, 1020, 1023, 3, 2, 2, 2, 1021, 1019, 3, 2, 2, 2, 1021, 1022,
	3, 2, 2, 2, 1022, 1024, 3, 2, 2, 2, 1023, 1021, 3, 2, 2, 2, 1024, 1025,
	7, 5, 2, 2, 1025, 175, 3, 2, 2, 2, 1026, 1028, 7, 4, 2, 2, 1027, 1029,
	5, 162, 82, 2, 1028, 1027, 3, 2, 2, 2, 1029, 1030, 3, 2, 2, 2, 1030, 1028,
	3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 1033,
	7, 5, 2, 2, 1033, 177, 3, 2, 2, 2, 1034, 1035, 7, 4, 2, 2, 1035, 1039,
	7, 114, 2, 2, 1036, 1038, 5, 160, 81, 2, 1037, 1036, 3, 2, 2, 2, 1038,
	1041, 3, 2, 2, 2, 1039, 1037, 3, 2, 2, 2, 1039, 1040, 3, 2, 2, 2, 1040,
	1042, 3, 2, 2, 2, 1041, 1039, 3, 2, 2, 2, 1042, 1052, 7, 5, 2, 2, 1043,
	1047, 7, 4, 2, 2, 1044, 1046, 5, 160, 81, 2, 1045, 1044, 3, 2, 2, 2, 1046,
	1049, 3, 2, 2, 2, 1047, 1045, 3, 2, 2, 2, 1047, 1048, 3, 2, 2, 2, 1048,
	1050, 3, 2, 2, 2, 1049, 1047, 3, 2, 2, 2, 1050, 1052, 7, 5, 2, 2, 1051,
	1034, 3, 2, 2, 2, 1051, 1043, 3, 2, 2, 2, 1052, 179, 3, 2, 2, 2, 1053,
	1054, 5, 36, 19, 2, 1054, 181, 3, 2, 2, 2, 1055, 1056, 5, 30, 16, 2, 1056,
	183, 3, 2, 2, 2, 1057, 1061, 7, 4, 2, 2, 1058, 1060, 5, 14, 8, 2, 1059,
	1058, 3, 2, 2, 2, 1060, 1063, 3, 2, 2, 2, 1061, 1059, 3, 2, 2, 2, 1061,
	1062, 3, 2, 2, 2, 1062, 1064, 3, 2, 2, 2, 1063, 1061, 3, 2, 2, 2, 1064,
	1065, 7, 5, 2, 2, 1065, 185, 3, 2, 2, 2, 1066, 1070, 7, 4, 2, 2, 1067,
	1069, 5, 14, 8, 2, 1068, 1067, 3, 2, 2, 2, 1069, 1072, 3, 2, 2, 2, 1070,
	1068, 3, 2, 2, 2, 1070, 1071, 3, 2, 2, 2, 1071, 1073, 3, 2, 2, 2, 1072,
	1070, 3, 2, 2, 2, 1073, 1074, 7, 5, 2, 2, 1074, 187, 3, 2, 2, 2, 1075,
	1077, 7, 4, 2, 2, 1076, 1078, 5, 164, 83, 2, 1077, 1076, 3, 2, 2, 2, 1078,
	1079, 3, 2, 2, 2, 1079, 1077, 3, 2, 2, 2, 1079, 1080, 3, 2, 2, 2, 1080,
	1081, 3, 2, 2, 2, 1081, 1082, 7, 5, 2, 2, 1082, 189, 3, 2, 2, 2, 1083,
	1095, 5, 168, 85, 2, 1084, 1095, 5, 170, 86, 2, 1085, 1095, 5, 172, 87,
	2, 1086, 1095, 5, 174, 88, 2, 1087, 1095, 5, 176, 89, 2, 1088, 1095, 5,
	178, 90, 2, 1089, 1095, 5, 180, 91, 2, 1090, 1095, 5, 182, 92, 2, 1091,
	1095, 5, 184, 93, 2, 1092, 1095, 5, 186, 94, 2, 1093, 1095, 5, 188, 95,
	2, 1094, 1083, 3, 2, 2, 2, 1094, 1084, 3, 2, 2, 2, 1094, 1085, 3, 2, 2,
	2, 1094, 1086, 3, 2, 2, 2, 1094, 1087, 3, 2, 2, 2, 1094, 1088, 3, 2, 2,
	2, 1094, 1089, 3, 2, 2, 2, 1094, 1090, 3, 2, 2, 2, 1094, 1091, 3, 2, 2,
	2, 1094, 1092, 3, 2, 2, 2, 1094, 1093, 3, 2, 2, 2, 1095, 191, 3, 2, 2,
	2, 1096, 1105, 7, 19, 2, 2, 1097, 1105, 5, 190, 96, 2, 1098, 1105, 7, 23,
	2, 2, 1099, 1100, 7, 4, 2, 2, 1100, 1101, 7, 12, 2, 2, 1101, 1102, 5, 24,
	13, 2, 1102, 1103, 7, 5, 2, 2, 1103, 1105, 3, 2, 2, 2, 1104, 1096, 3, 2,
	2, 2, 1104, 1097, 3, 2, 2, 2, 1104, 1098, 3, 2, 2, 2, 1104, 1099, 3, 2,
	2, 2, 1105, 193, 3, 2, 2, 2, 78, 206, 212, 222, 237, 244, 253, 257, 261,
	270, 274, 282, 286, 292, 300, 304, 313, 331, 335, 351, 361, 373, 385, 398,
	409, 413, 421, 434, 445, 455, 460, 465, 474, 482, 487, 493, 500, 509, 524,
	532, 541, 554, 562, 581, 590, 600, 607, 612, 620, 632, 645, 650, 663, 681,
	688, 698, 719, 726, 736, 770, 913, 946, 956, 963, 977, 992, 1012, 1021,
	1030, 1039, 1047, 1051, 1061, 1070, 1079, 1094, 1104,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "'('", "')'", "';'", "", "", "'not'", "'Bool'", "'continued-execution'",
	"'error'", "'false'", "'immediate-exit'", "'incomplete'", "'logic'", "'memout'",
	"'sat'", "'success'", "'theory'", "'true'", "'unknown'", "'unsupported'",
	"'unsat'", "'assert'", "'check-sat'", "'check-sat-assuming'", "'declare-const'",
	"'declare-datatype'", "'declare-datatypes'", "'declare-fun'", "'declare-sort'",
	"'define-fun'", "'define-fun-rec'", "'define-funs-rec'", "'define-sort'",
	"'echo'", "'exit'", "'get-assertions'", "'get-assignment'", "'get-info'",
	"'get-model'", "'get-option'", "'get-proof'", "'get-unsat-assumptions'",
	"'get-unsat-core'", "'get-value'", "'pop'", "'push'", "'reset'", "'reset-assertions'",
	"'set-info'", "'set-logic'", "'set-option'", "'!'", "'_'", "'as'", "'BINARY'",
	"'DECIMAL'", "'exists'", "'HEXADECIMAL'", "'forall'", "'let'", "'match'",
	"'NUMERAL'", "'par'", "'string'", "", "", "", "", "':'", "':all-statistics'",
	"':assertion-stack-levels'", "':authors'", "':category'", "':chainable'",
	"':definition'", "':diagnostic-output-channel'", "':error-behavior'", "':extensions'",
	"':funs'", "':funs-description'", "':global-declarations'", "':interactive-mode'",
	"':language'", "':left-assoc'", "':license'", "':named'", "':name'", "':notes'",
	"':pattern'", "':print-success'", "':produce-assertions'", "':produce-assignments'",
	"':produce-models'", "':produce-proofs'", "':produce-unsat-assumptions'",
	"':produce-unsat-cores'", "':random-seed'", "':reason-unknown'", "':regular-output-channel'",
	"':reproducible-resource-limit'", "':right-assoc'", "':smt-lib-version'",
	"':sorts'", "':sorts-description'", "':source'", "':status'", "':theories'",
	"':values'", "':verbosity'", "':version'", "'model'",
}
var symbolicNames = []string{
	"", "Comment", "ParOpen", "ParClose", "Semicolon", "String_", "QuotedSymbol",
	"PS_Not", "PS_Bool", "PS_ContinuedExecution", "PS_Error", "PS_False", "PS_ImmediateExit",
	"PS_Incomplete", "PS_Logic", "PS_Memout", "PS_Sat", "PS_Success", "PS_Theory",
	"PS_True", "PS_Unknown", "PS_Unsupported", "PS_Unsat", "CMD_Assert", "CMD_CheckSat",
	"CMD_CheckSatAssuming", "CMD_DeclareConst", "CMD_DeclareDatatype", "CMD_DeclareDatatypes",
	"CMD_DeclareFun", "CMD_DeclareSort", "CMD_DefineFun", "CMD_DefineFunRec",
	"CMD_DefineFunsRec", "CMD_DefineSort", "CMD_Echo", "CMD_Exit", "CMD_GetAssertions",
	"CMD_GetAssignment", "CMD_GetInfo", "CMD_GetModel", "CMD_GetOption", "CMD_GetProof",
	"CMD_GetUnsatAssumptions", "CMD_GetUnsatCore", "CMD_GetValue", "CMD_Pop",
	"CMD_Push", "CMD_Reset", "CMD_ResetAssertions", "CMD_SetInfo", "CMD_SetLogic",
	"CMD_SetOption", "GRW_Exclamation", "GRW_Underscore", "GRW_As", "GRW_Binary",
	"GRW_Decimal", "GRW_Exists", "GRW_Hexadecimal", "GRW_Forall", "GRW_Let",
	"GRW_Match", "GRW_Numeral", "GRW_Par", "GRW_String", "Numeral", "Binary",
	"HexDecimal", "Decimal", "Colon", "PK_AllStatistics", "PK_AssertionStackLevels",
	"PK_Authors", "PK_Category", "PK_Chainable", "PK_Definition", "PK_DiagnosticOutputChannel",
	"PK_ErrorBehaviour", "PK_Extension", "PK_Funs", "PK_FunsDescription", "PK_GlobalDeclarations",
	"PK_InteractiveMode", "PK_Language", "PK_LeftAssoc", "PK_License", "PK_Named",
	"PK_Name", "PK_Notes", "PK_Pattern", "PK_PrintSuccess", "PK_ProduceAssertions",
	"PK_ProduceAssignments", "PK_ProduceModels", "PK_ProduceProofs", "PK_ProduceUnsatAssumptions",
	"PK_ProduceUnsatCores", "PK_RandomSeed", "PK_ReasonUnknown", "PK_RegularOutputChannel",
	"PK_ReproducibleResourceLimit", "PK_RightAssoc", "PK_SmtLibVersion", "PK_Sorts",
	"PK_SortsDescription", "PK_Source", "PK_Status", "PK_Theories", "PK_Values",
	"PK_Verbosity", "PK_Version", "RS_Model", "UndefinedSymbol", "WS",
}

var ruleNames = []string{
	"start", "generalReservedWord", "simpleSymbol", "quotedSymbol", "predefSymbol",
	"predefKeyword", "symbol", "numeral", "decimal", "hexadecimal", "binary",
	"string_", "keyword", "spec_constant", "s_expr", "index", "identifier",
	"attribute_value", "attribute", "sort", "qual_identifer", "var_binding",
	"sorted_var", "pattern", "match_case", "variable", "term", "sort_symbol_decl",
	"meta_spec_constant", "fun_symbol_decl", "par_fun_symbol_decl", "theory_attribute",
	"theory_decl", "logic_attribue", "logic", "sort_dec", "selector_dec", "constructor_dec",
	"datatype_dec", "function_dec", "function_def", "prop_literal", "script",
	"cmd_assert", "cmd_checkSat", "cmd_checkSatAssuming", "cmd_declareConst",
	"cmd_declareDatatype", "cmd_declareDatatypes", "cmd_declareFun", "cmd_declareSort",
	"cmd_defineFun", "cmd_defineFunRec", "cmd_defineFunsRec", "cmd_defineSort",
	"cmd_echo", "cmd_exit", "cmd_getAssertions", "cmd_getAssignment", "cmd_getInfo",
	"cmd_getModel", "cmd_getOption", "cmd_getProof", "cmd_getUnsatAssumptions",
	"cmd_getUnsatCore", "cmd_getValue", "cmd_pop", "cmd_push", "cmd_reset",
	"cmd_resetAssertions", "cmd_setInfo", "cmd_setLogic", "cmd_setOption",
	"command", "b_value", "option", "info_flag", "error_behaviour", "reason_unknown",
	"model_response", "info_response", "valuation_pair", "t_valuation_pair",
	"check_sat_response", "echo_response", "get_assertions_response", "get_assignment_response",
	"get_info_response", "get_model_response", "get_option_response", "get_proof_response",
	"get_unsat_assump_response", "get_unsat_core_response", "get_value_response",
	"specific_success_response", "general_response",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SMTLIBv2Parser struct {
	*antlr.BaseParser
}

func NewSMTLIBv2Parser(input antlr.TokenStream) *SMTLIBv2Parser {
	this := new(SMTLIBv2Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SMTLIBv2.g4"

	return this
}

// SMTLIBv2Parser tokens.
const (
	SMTLIBv2ParserEOF                          = antlr.TokenEOF
	SMTLIBv2ParserComment                      = 1
	SMTLIBv2ParserParOpen                      = 2
	SMTLIBv2ParserParClose                     = 3
	SMTLIBv2ParserSemicolon                    = 4
	SMTLIBv2ParserString_                      = 5
	SMTLIBv2ParserQuotedSymbol                 = 6
	SMTLIBv2ParserPS_Not                       = 7
	SMTLIBv2ParserPS_Bool                      = 8
	SMTLIBv2ParserPS_ContinuedExecution        = 9
	SMTLIBv2ParserPS_Error                     = 10
	SMTLIBv2ParserPS_False                     = 11
	SMTLIBv2ParserPS_ImmediateExit             = 12
	SMTLIBv2ParserPS_Incomplete                = 13
	SMTLIBv2ParserPS_Logic                     = 14
	SMTLIBv2ParserPS_Memout                    = 15
	SMTLIBv2ParserPS_Sat                       = 16
	SMTLIBv2ParserPS_Success                   = 17
	SMTLIBv2ParserPS_Theory                    = 18
	SMTLIBv2ParserPS_True                      = 19
	SMTLIBv2ParserPS_Unknown                   = 20
	SMTLIBv2ParserPS_Unsupported               = 21
	SMTLIBv2ParserPS_Unsat                     = 22
	SMTLIBv2ParserCMD_Assert                   = 23
	SMTLIBv2ParserCMD_CheckSat                 = 24
	SMTLIBv2ParserCMD_CheckSatAssuming         = 25
	SMTLIBv2ParserCMD_DeclareConst             = 26
	SMTLIBv2ParserCMD_DeclareDatatype          = 27
	SMTLIBv2ParserCMD_DeclareDatatypes         = 28
	SMTLIBv2ParserCMD_DeclareFun               = 29
	SMTLIBv2ParserCMD_DeclareSort              = 30
	SMTLIBv2ParserCMD_DefineFun                = 31
	SMTLIBv2ParserCMD_DefineFunRec             = 32
	SMTLIBv2ParserCMD_DefineFunsRec            = 33
	SMTLIBv2ParserCMD_DefineSort               = 34
	SMTLIBv2ParserCMD_Echo                     = 35
	SMTLIBv2ParserCMD_Exit                     = 36
	SMTLIBv2ParserCMD_GetAssertions            = 37
	SMTLIBv2ParserCMD_GetAssignment            = 38
	SMTLIBv2ParserCMD_GetInfo                  = 39
	SMTLIBv2ParserCMD_GetModel                 = 40
	SMTLIBv2ParserCMD_GetOption                = 41
	SMTLIBv2ParserCMD_GetProof                 = 42
	SMTLIBv2ParserCMD_GetUnsatAssumptions      = 43
	SMTLIBv2ParserCMD_GetUnsatCore             = 44
	SMTLIBv2ParserCMD_GetValue                 = 45
	SMTLIBv2ParserCMD_Pop                      = 46
	SMTLIBv2ParserCMD_Push                     = 47
	SMTLIBv2ParserCMD_Reset                    = 48
	SMTLIBv2ParserCMD_ResetAssertions          = 49
	SMTLIBv2ParserCMD_SetInfo                  = 50
	SMTLIBv2ParserCMD_SetLogic                 = 51
	SMTLIBv2ParserCMD_SetOption                = 52
	SMTLIBv2ParserGRW_Exclamation              = 53
	SMTLIBv2ParserGRW_Underscore               = 54
	SMTLIBv2ParserGRW_As                       = 55
	SMTLIBv2ParserGRW_Binary                   = 56
	SMTLIBv2ParserGRW_Decimal                  = 57
	SMTLIBv2ParserGRW_Exists                   = 58
	SMTLIBv2ParserGRW_Hexadecimal              = 59
	SMTLIBv2ParserGRW_Forall                   = 60
	SMTLIBv2ParserGRW_Let                      = 61
	SMTLIBv2ParserGRW_Match                    = 62
	SMTLIBv2ParserGRW_Numeral                  = 63
	SMTLIBv2ParserGRW_Par                      = 64
	SMTLIBv2ParserGRW_String                   = 65
	SMTLIBv2ParserNumeral                      = 66
	SMTLIBv2ParserBinary                       = 67
	SMTLIBv2ParserHexDecimal                   = 68
	SMTLIBv2ParserDecimal                      = 69
	SMTLIBv2ParserColon                        = 70
	SMTLIBv2ParserPK_AllStatistics             = 71
	SMTLIBv2ParserPK_AssertionStackLevels      = 72
	SMTLIBv2ParserPK_Authors                   = 73
	SMTLIBv2ParserPK_Category                  = 74
	SMTLIBv2ParserPK_Chainable                 = 75
	SMTLIBv2ParserPK_Definition                = 76
	SMTLIBv2ParserPK_DiagnosticOutputChannel   = 77
	SMTLIBv2ParserPK_ErrorBehaviour            = 78
	SMTLIBv2ParserPK_Extension                 = 79
	SMTLIBv2ParserPK_Funs                      = 80
	SMTLIBv2ParserPK_FunsDescription           = 81
	SMTLIBv2ParserPK_GlobalDeclarations        = 82
	SMTLIBv2ParserPK_InteractiveMode           = 83
	SMTLIBv2ParserPK_Language                  = 84
	SMTLIBv2ParserPK_LeftAssoc                 = 85
	SMTLIBv2ParserPK_License                   = 86
	SMTLIBv2ParserPK_Named                     = 87
	SMTLIBv2ParserPK_Name                      = 88
	SMTLIBv2ParserPK_Notes                     = 89
	SMTLIBv2ParserPK_Pattern                   = 90
	SMTLIBv2ParserPK_PrintSuccess              = 91
	SMTLIBv2ParserPK_ProduceAssertions         = 92
	SMTLIBv2ParserPK_ProduceAssignments        = 93
	SMTLIBv2ParserPK_ProduceModels             = 94
	SMTLIBv2ParserPK_ProduceProofs             = 95
	SMTLIBv2ParserPK_ProduceUnsatAssumptions   = 96
	SMTLIBv2ParserPK_ProduceUnsatCores         = 97
	SMTLIBv2ParserPK_RandomSeed                = 98
	SMTLIBv2ParserPK_ReasonUnknown             = 99
	SMTLIBv2ParserPK_RegularOutputChannel      = 100
	SMTLIBv2ParserPK_ReproducibleResourceLimit = 101
	SMTLIBv2ParserPK_RightAssoc                = 102
	SMTLIBv2ParserPK_SmtLibVersion             = 103
	SMTLIBv2ParserPK_Sorts                     = 104
	SMTLIBv2ParserPK_SortsDescription          = 105
	SMTLIBv2ParserPK_Source                    = 106
	SMTLIBv2ParserPK_Status                    = 107
	SMTLIBv2ParserPK_Theories                  = 108
	SMTLIBv2ParserPK_Values                    = 109
	SMTLIBv2ParserPK_Verbosity                 = 110
	SMTLIBv2ParserPK_Version                   = 111
	SMTLIBv2ParserRS_Model                     = 112
	SMTLIBv2ParserUndefinedSymbol              = 113
	SMTLIBv2ParserWS                           = 114
)

// SMTLIBv2Parser rules.
const (
	SMTLIBv2ParserRULE_start                     = 0
	SMTLIBv2ParserRULE_generalReservedWord       = 1
	SMTLIBv2ParserRULE_simpleSymbol              = 2
	SMTLIBv2ParserRULE_quotedSymbol              = 3
	SMTLIBv2ParserRULE_predefSymbol              = 4
	SMTLIBv2ParserRULE_predefKeyword             = 5
	SMTLIBv2ParserRULE_symbol                    = 6
	SMTLIBv2ParserRULE_numeral                   = 7
	SMTLIBv2ParserRULE_decimal                   = 8
	SMTLIBv2ParserRULE_hexadecimal               = 9
	SMTLIBv2ParserRULE_binary                    = 10
	SMTLIBv2ParserRULE_string_                   = 11
	SMTLIBv2ParserRULE_keyword                   = 12
	SMTLIBv2ParserRULE_spec_constant             = 13
	SMTLIBv2ParserRULE_s_expr                    = 14
	SMTLIBv2ParserRULE_index                     = 15
	SMTLIBv2ParserRULE_identifier                = 16
	SMTLIBv2ParserRULE_attribute_value           = 17
	SMTLIBv2ParserRULE_attribute                 = 18
	SMTLIBv2ParserRULE_sort                      = 19
	SMTLIBv2ParserRULE_qual_identifer            = 20
	SMTLIBv2ParserRULE_var_binding               = 21
	SMTLIBv2ParserRULE_sorted_var                = 22
	SMTLIBv2ParserRULE_pattern                   = 23
	SMTLIBv2ParserRULE_match_case                = 24
	SMTLIBv2ParserRULE_variable                  = 25
	SMTLIBv2ParserRULE_term                      = 26
	SMTLIBv2ParserRULE_sort_symbol_decl          = 27
	SMTLIBv2ParserRULE_meta_spec_constant        = 28
	SMTLIBv2ParserRULE_fun_symbol_decl           = 29
	SMTLIBv2ParserRULE_par_fun_symbol_decl       = 30
	SMTLIBv2ParserRULE_theory_attribute          = 31
	SMTLIBv2ParserRULE_theory_decl               = 32
	SMTLIBv2ParserRULE_logic_attribue            = 33
	SMTLIBv2ParserRULE_logic                     = 34
	SMTLIBv2ParserRULE_sort_dec                  = 35
	SMTLIBv2ParserRULE_selector_dec              = 36
	SMTLIBv2ParserRULE_constructor_dec           = 37
	SMTLIBv2ParserRULE_datatype_dec              = 38
	SMTLIBv2ParserRULE_function_dec              = 39
	SMTLIBv2ParserRULE_function_def              = 40
	SMTLIBv2ParserRULE_prop_literal              = 41
	SMTLIBv2ParserRULE_script                    = 42
	SMTLIBv2ParserRULE_cmd_assert                = 43
	SMTLIBv2ParserRULE_cmd_checkSat              = 44
	SMTLIBv2ParserRULE_cmd_checkSatAssuming      = 45
	SMTLIBv2ParserRULE_cmd_declareConst          = 46
	SMTLIBv2ParserRULE_cmd_declareDatatype       = 47
	SMTLIBv2ParserRULE_cmd_declareDatatypes      = 48
	SMTLIBv2ParserRULE_cmd_declareFun            = 49
	SMTLIBv2ParserRULE_cmd_declareSort           = 50
	SMTLIBv2ParserRULE_cmd_defineFun             = 51
	SMTLIBv2ParserRULE_cmd_defineFunRec          = 52
	SMTLIBv2ParserRULE_cmd_defineFunsRec         = 53
	SMTLIBv2ParserRULE_cmd_defineSort            = 54
	SMTLIBv2ParserRULE_cmd_echo                  = 55
	SMTLIBv2ParserRULE_cmd_exit                  = 56
	SMTLIBv2ParserRULE_cmd_getAssertions         = 57
	SMTLIBv2ParserRULE_cmd_getAssignment         = 58
	SMTLIBv2ParserRULE_cmd_getInfo               = 59
	SMTLIBv2ParserRULE_cmd_getModel              = 60
	SMTLIBv2ParserRULE_cmd_getOption             = 61
	SMTLIBv2ParserRULE_cmd_getProof              = 62
	SMTLIBv2ParserRULE_cmd_getUnsatAssumptions   = 63
	SMTLIBv2ParserRULE_cmd_getUnsatCore          = 64
	SMTLIBv2ParserRULE_cmd_getValue              = 65
	SMTLIBv2ParserRULE_cmd_pop                   = 66
	SMTLIBv2ParserRULE_cmd_push                  = 67
	SMTLIBv2ParserRULE_cmd_reset                 = 68
	SMTLIBv2ParserRULE_cmd_resetAssertions       = 69
	SMTLIBv2ParserRULE_cmd_setInfo               = 70
	SMTLIBv2ParserRULE_cmd_setLogic              = 71
	SMTLIBv2ParserRULE_cmd_setOption             = 72
	SMTLIBv2ParserRULE_command                   = 73
	SMTLIBv2ParserRULE_b_value                   = 74
	SMTLIBv2ParserRULE_option                    = 75
	SMTLIBv2ParserRULE_info_flag                 = 76
	SMTLIBv2ParserRULE_error_behaviour           = 77
	SMTLIBv2ParserRULE_reason_unknown            = 78
	SMTLIBv2ParserRULE_model_response            = 79
	SMTLIBv2ParserRULE_info_response             = 80
	SMTLIBv2ParserRULE_valuation_pair            = 81
	SMTLIBv2ParserRULE_t_valuation_pair          = 82
	SMTLIBv2ParserRULE_check_sat_response        = 83
	SMTLIBv2ParserRULE_echo_response             = 84
	SMTLIBv2ParserRULE_get_assertions_response   = 85
	SMTLIBv2ParserRULE_get_assignment_response   = 86
	SMTLIBv2ParserRULE_get_info_response         = 87
	SMTLIBv2ParserRULE_get_model_response        = 88
	SMTLIBv2ParserRULE_get_option_response       = 89
	SMTLIBv2ParserRULE_get_proof_response        = 90
	SMTLIBv2ParserRULE_get_unsat_assump_response = 91
	SMTLIBv2ParserRULE_get_unsat_core_response   = 92
	SMTLIBv2ParserRULE_get_value_response        = 93
	SMTLIBv2ParserRULE_specific_success_response = 94
	SMTLIBv2ParserRULE_general_response          = 95
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Logic() ILogicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogicContext)
}

func (s *StartContext) EOF() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserEOF, 0)
}

func (s *StartContext) Theory_decl() ITheory_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITheory_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITheory_declContext)
}

func (s *StartContext) Script() IScriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptContext)
}

func (s *StartContext) General_response() IGeneral_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneral_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneral_responseContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitStart(s)
	}
}

func (s *StartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Start() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SMTLIBv2ParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(192)
			p.Logic()
		}
		{
			p.SetState(193)
			p.Match(SMTLIBv2ParserEOF)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(195)
			p.Theory_decl()
		}
		{
			p.SetState(196)
			p.Match(SMTLIBv2ParserEOF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(198)
			p.Script()
		}
		{
			p.SetState(199)
			p.Match(SMTLIBv2ParserEOF)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(201)
			p.General_response()
		}
		{
			p.SetState(202)
			p.Match(SMTLIBv2ParserEOF)
		}

	}

	return localctx
}

// IGeneralReservedWordContext is an interface to support dynamic dispatch.
type IGeneralReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralReservedWordContext differentiates from other interfaces.
	IsGeneralReservedWordContext()
}

type GeneralReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralReservedWordContext() *GeneralReservedWordContext {
	var p = new(GeneralReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord
	return p
}

func (*GeneralReservedWordContext) IsGeneralReservedWordContext() {}

func NewGeneralReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralReservedWordContext {
	var p = new(GeneralReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_generalReservedWord

	return p
}

func (s *GeneralReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralReservedWordContext) GRW_Exclamation() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exclamation, 0)
}

func (s *GeneralReservedWordContext) GRW_Underscore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Underscore, 0)
}

func (s *GeneralReservedWordContext) GRW_As() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_As, 0)
}

func (s *GeneralReservedWordContext) GRW_Binary() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Binary, 0)
}

func (s *GeneralReservedWordContext) GRW_Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Decimal, 0)
}

func (s *GeneralReservedWordContext) GRW_Exists() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exists, 0)
}

func (s *GeneralReservedWordContext) GRW_Hexadecimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Hexadecimal, 0)
}

func (s *GeneralReservedWordContext) GRW_Forall() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Forall, 0)
}

func (s *GeneralReservedWordContext) GRW_Let() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Let, 0)
}

func (s *GeneralReservedWordContext) GRW_Match() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Match, 0)
}

func (s *GeneralReservedWordContext) GRW_Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Numeral, 0)
}

func (s *GeneralReservedWordContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *GeneralReservedWordContext) GRW_String() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_String, 0)
}

func (s *GeneralReservedWordContext) RS_Model() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserRS_Model, 0)
}

func (s *GeneralReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGeneralReservedWord(s)
	}
}

func (s *GeneralReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGeneralReservedWord(s)
	}
}

func (s *GeneralReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGeneralReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) GeneralReservedWord() (localctx IGeneralReservedWordContext) {
	localctx = NewGeneralReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SMTLIBv2ParserRULE_generalReservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SMTLIBv2ParserGRW_Exclamation-53))|(1<<(SMTLIBv2ParserGRW_Underscore-53))|(1<<(SMTLIBv2ParserGRW_As-53))|(1<<(SMTLIBv2ParserGRW_Binary-53))|(1<<(SMTLIBv2ParserGRW_Decimal-53))|(1<<(SMTLIBv2ParserGRW_Exists-53))|(1<<(SMTLIBv2ParserGRW_Hexadecimal-53))|(1<<(SMTLIBv2ParserGRW_Forall-53))|(1<<(SMTLIBv2ParserGRW_Let-53))|(1<<(SMTLIBv2ParserGRW_Match-53))|(1<<(SMTLIBv2ParserGRW_Numeral-53))|(1<<(SMTLIBv2ParserGRW_Par-53))|(1<<(SMTLIBv2ParserGRW_String-53)))) != 0) || _la == SMTLIBv2ParserRS_Model) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISimpleSymbolContext is an interface to support dynamic dispatch.
type ISimpleSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleSymbolContext differentiates from other interfaces.
	IsSimpleSymbolContext()
}

type SimpleSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleSymbolContext() *SimpleSymbolContext {
	var p = new(SimpleSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol
	return p
}

func (*SimpleSymbolContext) IsSimpleSymbolContext() {}

func NewSimpleSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleSymbolContext {
	var p = new(SimpleSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_simpleSymbol

	return p
}

func (s *SimpleSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleSymbolContext) PredefSymbol() IPredefSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredefSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredefSymbolContext)
}

func (s *SimpleSymbolContext) UndefinedSymbol() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserUndefinedSymbol, 0)
}

func (s *SimpleSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSimpleSymbol(s)
	}
}

func (s *SimpleSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSimpleSymbol(s)
	}
}

func (s *SimpleSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSimpleSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) SimpleSymbol() (localctx ISimpleSymbolContext) {
	localctx = NewSimpleSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SMTLIBv2ParserRULE_simpleSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(210)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(208)
			p.PredefSymbol()
		}

	case SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(209)
			p.Match(SMTLIBv2ParserUndefinedSymbol)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuotedSymbolContext is an interface to support dynamic dispatch.
type IQuotedSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedSymbolContext differentiates from other interfaces.
	IsQuotedSymbolContext()
}

type QuotedSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedSymbolContext() *QuotedSymbolContext {
	var p = new(QuotedSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol
	return p
}

func (*QuotedSymbolContext) IsQuotedSymbolContext() {}

func NewQuotedSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedSymbolContext {
	var p = new(QuotedSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_quotedSymbol

	return p
}

func (s *QuotedSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedSymbolContext) QuotedSymbol() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserQuotedSymbol, 0)
}

func (s *QuotedSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterQuotedSymbol(s)
	}
}

func (s *QuotedSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitQuotedSymbol(s)
	}
}

func (s *QuotedSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitQuotedSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) QuotedSymbol() (localctx IQuotedSymbolContext) {
	localctx = NewQuotedSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SMTLIBv2ParserRULE_quotedSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(212)
		p.Match(SMTLIBv2ParserQuotedSymbol)
	}

	return localctx
}

// IPredefSymbolContext is an interface to support dynamic dispatch.
type IPredefSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredefSymbolContext differentiates from other interfaces.
	IsPredefSymbolContext()
}

type PredefSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefSymbolContext() *PredefSymbolContext {
	var p = new(PredefSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol
	return p
}

func (*PredefSymbolContext) IsPredefSymbolContext() {}

func NewPredefSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefSymbolContext {
	var p = new(PredefSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_predefSymbol

	return p
}

func (s *PredefSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefSymbolContext) PS_Not() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Not, 0)
}

func (s *PredefSymbolContext) PS_Bool() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Bool, 0)
}

func (s *PredefSymbolContext) PS_ContinuedExecution() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ContinuedExecution, 0)
}

func (s *PredefSymbolContext) PS_Error() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Error, 0)
}

func (s *PredefSymbolContext) PS_False() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_False, 0)
}

func (s *PredefSymbolContext) PS_ImmediateExit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ImmediateExit, 0)
}

func (s *PredefSymbolContext) PS_Incomplete() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Incomplete, 0)
}

func (s *PredefSymbolContext) PS_Logic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Logic, 0)
}

func (s *PredefSymbolContext) PS_Memout() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Memout, 0)
}

func (s *PredefSymbolContext) PS_Sat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Sat, 0)
}

func (s *PredefSymbolContext) PS_Success() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Success, 0)
}

func (s *PredefSymbolContext) PS_Theory() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Theory, 0)
}

func (s *PredefSymbolContext) PS_True() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_True, 0)
}

func (s *PredefSymbolContext) PS_Unknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unknown, 0)
}

func (s *PredefSymbolContext) PS_Unsupported() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsupported, 0)
}

func (s *PredefSymbolContext) PS_Unsat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsat, 0)
}

func (s *PredefSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPredefSymbol(s)
	}
}

func (s *PredefSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPredefSymbol(s)
	}
}

func (s *PredefSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPredefSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) PredefSymbol() (localctx IPredefSymbolContext) {
	localctx = NewPredefSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SMTLIBv2ParserRULE_predefSymbol)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPredefKeywordContext is an interface to support dynamic dispatch.
type IPredefKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredefKeywordContext differentiates from other interfaces.
	IsPredefKeywordContext()
}

type PredefKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefKeywordContext() *PredefKeywordContext {
	var p = new(PredefKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword
	return p
}

func (*PredefKeywordContext) IsPredefKeywordContext() {}

func NewPredefKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefKeywordContext {
	var p = new(PredefKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_predefKeyword

	return p
}

func (s *PredefKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefKeywordContext) PK_AllStatistics() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AllStatistics, 0)
}

func (s *PredefKeywordContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *PredefKeywordContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *PredefKeywordContext) PK_Category() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Category, 0)
}

func (s *PredefKeywordContext) PK_Chainable() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Chainable, 0)
}

func (s *PredefKeywordContext) PK_Definition() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Definition, 0)
}

func (s *PredefKeywordContext) PK_DiagnosticOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_DiagnosticOutputChannel, 0)
}

func (s *PredefKeywordContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *PredefKeywordContext) PK_Extension() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Extension, 0)
}

func (s *PredefKeywordContext) PK_Funs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Funs, 0)
}

func (s *PredefKeywordContext) PK_FunsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_FunsDescription, 0)
}

func (s *PredefKeywordContext) PK_GlobalDeclarations() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_GlobalDeclarations, 0)
}

func (s *PredefKeywordContext) PK_InteractiveMode() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_InteractiveMode, 0)
}

func (s *PredefKeywordContext) PK_Language() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Language, 0)
}

func (s *PredefKeywordContext) PK_LeftAssoc() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_LeftAssoc, 0)
}

func (s *PredefKeywordContext) PK_License() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_License, 0)
}

func (s *PredefKeywordContext) PK_Named() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Named, 0)
}

func (s *PredefKeywordContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *PredefKeywordContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *PredefKeywordContext) PK_Pattern() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Pattern, 0)
}

func (s *PredefKeywordContext) PK_PrintSuccess() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_PrintSuccess, 0)
}

func (s *PredefKeywordContext) PK_ProduceAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssertions, 0)
}

func (s *PredefKeywordContext) PK_ProduceAssignments() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssignments, 0)
}

func (s *PredefKeywordContext) PK_ProduceModels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceModels, 0)
}

func (s *PredefKeywordContext) PK_ProduceProofs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceProofs, 0)
}

func (s *PredefKeywordContext) PK_ProduceUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatAssumptions, 0)
}

func (s *PredefKeywordContext) PK_ProduceUnsatCores() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatCores, 0)
}

func (s *PredefKeywordContext) PK_RandomSeed() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RandomSeed, 0)
}

func (s *PredefKeywordContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *PredefKeywordContext) PK_RegularOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RegularOutputChannel, 0)
}

func (s *PredefKeywordContext) PK_ReproducibleResourceLimit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReproducibleResourceLimit, 0)
}

func (s *PredefKeywordContext) PK_RightAssoc() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RightAssoc, 0)
}

func (s *PredefKeywordContext) PK_SmtLibVersion() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SmtLibVersion, 0)
}

func (s *PredefKeywordContext) PK_Sorts() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Sorts, 0)
}

func (s *PredefKeywordContext) PK_SortsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SortsDescription, 0)
}

func (s *PredefKeywordContext) PK_Source() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Source, 0)
}

func (s *PredefKeywordContext) PK_Status() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Status, 0)
}

func (s *PredefKeywordContext) PK_Theories() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Theories, 0)
}

func (s *PredefKeywordContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *PredefKeywordContext) PK_Verbosity() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Verbosity, 0)
}

func (s *PredefKeywordContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *PredefKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPredefKeyword(s)
	}
}

func (s *PredefKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPredefKeyword(s)
	}
}

func (s *PredefKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPredefKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) PredefKeyword() (localctx IPredefKeywordContext) {
	localctx = NewPredefKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SMTLIBv2ParserRULE_predefKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(216)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(SMTLIBv2ParserPK_AllStatistics-71))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-71))|(1<<(SMTLIBv2ParserPK_Authors-71))|(1<<(SMTLIBv2ParserPK_Category-71))|(1<<(SMTLIBv2ParserPK_Chainable-71))|(1<<(SMTLIBv2ParserPK_Definition-71))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-71))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-71))|(1<<(SMTLIBv2ParserPK_Extension-71))|(1<<(SMTLIBv2ParserPK_Funs-71))|(1<<(SMTLIBv2ParserPK_FunsDescription-71))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-71))|(1<<(SMTLIBv2ParserPK_InteractiveMode-71))|(1<<(SMTLIBv2ParserPK_Language-71))|(1<<(SMTLIBv2ParserPK_LeftAssoc-71))|(1<<(SMTLIBv2ParserPK_License-71))|(1<<(SMTLIBv2ParserPK_Named-71))|(1<<(SMTLIBv2ParserPK_Name-71))|(1<<(SMTLIBv2ParserPK_Notes-71))|(1<<(SMTLIBv2ParserPK_Pattern-71))|(1<<(SMTLIBv2ParserPK_PrintSuccess-71))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-71))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-71))|(1<<(SMTLIBv2ParserPK_ProduceModels-71))|(1<<(SMTLIBv2ParserPK_ProduceProofs-71))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-71))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-71))|(1<<(SMTLIBv2ParserPK_RandomSeed-71))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-71))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-71))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-71))|(1<<(SMTLIBv2ParserPK_RightAssoc-71)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(SMTLIBv2ParserPK_SmtLibVersion-103))|(1<<(SMTLIBv2ParserPK_Sorts-103))|(1<<(SMTLIBv2ParserPK_SortsDescription-103))|(1<<(SMTLIBv2ParserPK_Source-103))|(1<<(SMTLIBv2ParserPK_Status-103))|(1<<(SMTLIBv2ParserPK_Theories-103))|(1<<(SMTLIBv2ParserPK_Values-103))|(1<<(SMTLIBv2ParserPK_Verbosity-103))|(1<<(SMTLIBv2ParserPK_Version-103)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_symbol
	return p
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) SimpleSymbol() ISimpleSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleSymbolContext)
}

func (s *SymbolContext) QuotedSymbol() IQuotedSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedSymbolContext)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (s *SymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SMTLIBv2ParserRULE_symbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(220)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(218)
			p.SimpleSymbol()
		}

	case SMTLIBv2ParserQuotedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(219)
			p.QuotedSymbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumeralContext is an interface to support dynamic dispatch.
type INumeralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeralContext differentiates from other interfaces.
	IsNumeralContext()
}

type NumeralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeralContext() *NumeralContext {
	var p = new(NumeralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_numeral
	return p
}

func (*NumeralContext) IsNumeralContext() {}

func NewNumeralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumeralContext {
	var p = new(NumeralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_numeral

	return p
}

func (s *NumeralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumeralContext) Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserNumeral, 0)
}

func (s *NumeralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumeralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumeralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterNumeral(s)
	}
}

func (s *NumeralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitNumeral(s)
	}
}

func (s *NumeralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitNumeral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Numeral() (localctx INumeralContext) {
	localctx = NewNumeralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SMTLIBv2ParserRULE_numeral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(SMTLIBv2ParserNumeral)
	}

	return localctx
}

// IDecimalContext is an interface to support dynamic dispatch.
type IDecimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalContext differentiates from other interfaces.
	IsDecimalContext()
}

type DecimalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalContext() *DecimalContext {
	var p = new(DecimalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_decimal
	return p
}

func (*DecimalContext) IsDecimalContext() {}

func NewDecimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalContext {
	var p = new(DecimalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_decimal

	return p
}

func (s *DecimalContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalContext) Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserDecimal, 0)
}

func (s *DecimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterDecimal(s)
	}
}

func (s *DecimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitDecimal(s)
	}
}

func (s *DecimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitDecimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Decimal() (localctx IDecimalContext) {
	localctx = NewDecimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SMTLIBv2ParserRULE_decimal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(SMTLIBv2ParserDecimal)
	}

	return localctx
}

// IHexadecimalContext is an interface to support dynamic dispatch.
type IHexadecimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalContext differentiates from other interfaces.
	IsHexadecimalContext()
}

type HexadecimalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalContext() *HexadecimalContext {
	var p = new(HexadecimalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal
	return p
}

func (*HexadecimalContext) IsHexadecimalContext() {}

func NewHexadecimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalContext {
	var p = new(HexadecimalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_hexadecimal

	return p
}

func (s *HexadecimalContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalContext) HexDecimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserHexDecimal, 0)
}

func (s *HexadecimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterHexadecimal(s)
	}
}

func (s *HexadecimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitHexadecimal(s)
	}
}

func (s *HexadecimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitHexadecimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Hexadecimal() (localctx IHexadecimalContext) {
	localctx = NewHexadecimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SMTLIBv2ParserRULE_hexadecimal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(SMTLIBv2ParserHexDecimal)
	}

	return localctx
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_binary
	return p
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) Binary() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserBinary, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitBinary(s)
	}
}

func (s *BinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SMTLIBv2ParserRULE_binary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(228)
		p.Match(SMTLIBv2ParserBinary)
	}

	return localctx
}

// IString_Context is an interface to support dynamic dispatch.
type IString_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_Context differentiates from other interfaces.
	IsString_Context()
}

type String_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_Context() *String_Context {
	var p = new(String_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_string_
	return p
}

func (*String_Context) IsString_Context() {}

func NewString_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_Context {
	var p = new(String_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_string_

	return p
}

func (s *String_Context) GetParser() antlr.Parser { return s.parser }

func (s *String_Context) String_() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserString_, 0)
}

func (s *String_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterString_(s)
	}
}

func (s *String_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitString_(s)
	}
}

func (s *String_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitString_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) String_() (localctx IString_Context) {
	localctx = NewString_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SMTLIBv2ParserRULE_string_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(SMTLIBv2ParserString_)
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) PredefKeyword() IPredefKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredefKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredefKeywordContext)
}

func (s *KeywordContext) Colon() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserColon, 0)
}

func (s *KeywordContext) SimpleSymbol() ISimpleSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleSymbolContext)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SMTLIBv2ParserRULE_keyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(235)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserPK_AllStatistics, SMTLIBv2ParserPK_AssertionStackLevels, SMTLIBv2ParserPK_Authors, SMTLIBv2ParserPK_Category, SMTLIBv2ParserPK_Chainable, SMTLIBv2ParserPK_Definition, SMTLIBv2ParserPK_DiagnosticOutputChannel, SMTLIBv2ParserPK_ErrorBehaviour, SMTLIBv2ParserPK_Extension, SMTLIBv2ParserPK_Funs, SMTLIBv2ParserPK_FunsDescription, SMTLIBv2ParserPK_GlobalDeclarations, SMTLIBv2ParserPK_InteractiveMode, SMTLIBv2ParserPK_Language, SMTLIBv2ParserPK_LeftAssoc, SMTLIBv2ParserPK_License, SMTLIBv2ParserPK_Named, SMTLIBv2ParserPK_Name, SMTLIBv2ParserPK_Notes, SMTLIBv2ParserPK_Pattern, SMTLIBv2ParserPK_PrintSuccess, SMTLIBv2ParserPK_ProduceAssertions, SMTLIBv2ParserPK_ProduceAssignments, SMTLIBv2ParserPK_ProduceModels, SMTLIBv2ParserPK_ProduceProofs, SMTLIBv2ParserPK_ProduceUnsatAssumptions, SMTLIBv2ParserPK_ProduceUnsatCores, SMTLIBv2ParserPK_RandomSeed, SMTLIBv2ParserPK_ReasonUnknown, SMTLIBv2ParserPK_RegularOutputChannel, SMTLIBv2ParserPK_ReproducibleResourceLimit, SMTLIBv2ParserPK_RightAssoc, SMTLIBv2ParserPK_SmtLibVersion, SMTLIBv2ParserPK_Sorts, SMTLIBv2ParserPK_SortsDescription, SMTLIBv2ParserPK_Source, SMTLIBv2ParserPK_Status, SMTLIBv2ParserPK_Theories, SMTLIBv2ParserPK_Values, SMTLIBv2ParserPK_Verbosity, SMTLIBv2ParserPK_Version:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(232)
			p.PredefKeyword()
		}

	case SMTLIBv2ParserColon:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(233)
			p.Match(SMTLIBv2ParserColon)
		}
		{
			p.SetState(234)
			p.SimpleSymbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpec_constantContext is an interface to support dynamic dispatch.
type ISpec_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpec_constantContext differentiates from other interfaces.
	IsSpec_constantContext()
}

type Spec_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpec_constantContext() *Spec_constantContext {
	var p = new(Spec_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant
	return p
}

func (*Spec_constantContext) IsSpec_constantContext() {}

func NewSpec_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Spec_constantContext {
	var p = new(Spec_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_spec_constant

	return p
}

func (s *Spec_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Spec_constantContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Spec_constantContext) Decimal() IDecimalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalContext)
}

func (s *Spec_constantContext) Hexadecimal() IHexadecimalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexadecimalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexadecimalContext)
}

func (s *Spec_constantContext) Binary() IBinaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *Spec_constantContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Spec_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Spec_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Spec_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSpec_constant(s)
	}
}

func (s *Spec_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSpec_constant(s)
	}
}

func (s *Spec_constantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSpec_constant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Spec_constant() (localctx ISpec_constantContext) {
	localctx = NewSpec_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SMTLIBv2ParserRULE_spec_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(242)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserNumeral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(237)
			p.Numeral()
		}

	case SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(238)
			p.Decimal()
		}

	case SMTLIBv2ParserHexDecimal:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(239)
			p.Hexadecimal()
		}

	case SMTLIBv2ParserBinary:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(240)
			p.Binary()
		}

	case SMTLIBv2ParserString_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(241)
			p.String_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IS_exprContext is an interface to support dynamic dispatch.
type IS_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsS_exprContext differentiates from other interfaces.
	IsS_exprContext()
}

type S_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyS_exprContext() *S_exprContext {
	var p = new(S_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr
	return p
}

func (*S_exprContext) IsS_exprContext() {}

func NewS_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *S_exprContext {
	var p = new(S_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_s_expr

	return p
}

func (s *S_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *S_exprContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *S_exprContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *S_exprContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *S_exprContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *S_exprContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *S_exprContext) AllS_expr() []IS_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IS_exprContext)(nil)).Elem())
	var tst = make([]IS_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IS_exprContext)
		}
	}

	return tst
}

func (s *S_exprContext) S_expr(i int) IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *S_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *S_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *S_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterS_expr(s)
	}
}

func (s *S_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitS_expr(s)
	}
}

func (s *S_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitS_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) S_expr() (localctx IS_exprContext) {
	localctx = NewS_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SMTLIBv2ParserRULE_s_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(255)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserString_, SMTLIBv2ParserNumeral, SMTLIBv2ParserBinary, SMTLIBv2ParserHexDecimal, SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(244)
			p.Spec_constant()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(245)
			p.Symbol()
		}

	case SMTLIBv2ParserColon, SMTLIBv2ParserPK_AllStatistics, SMTLIBv2ParserPK_AssertionStackLevels, SMTLIBv2ParserPK_Authors, SMTLIBv2ParserPK_Category, SMTLIBv2ParserPK_Chainable, SMTLIBv2ParserPK_Definition, SMTLIBv2ParserPK_DiagnosticOutputChannel, SMTLIBv2ParserPK_ErrorBehaviour, SMTLIBv2ParserPK_Extension, SMTLIBv2ParserPK_Funs, SMTLIBv2ParserPK_FunsDescription, SMTLIBv2ParserPK_GlobalDeclarations, SMTLIBv2ParserPK_InteractiveMode, SMTLIBv2ParserPK_Language, SMTLIBv2ParserPK_LeftAssoc, SMTLIBv2ParserPK_License, SMTLIBv2ParserPK_Named, SMTLIBv2ParserPK_Name, SMTLIBv2ParserPK_Notes, SMTLIBv2ParserPK_Pattern, SMTLIBv2ParserPK_PrintSuccess, SMTLIBv2ParserPK_ProduceAssertions, SMTLIBv2ParserPK_ProduceAssignments, SMTLIBv2ParserPK_ProduceModels, SMTLIBv2ParserPK_ProduceProofs, SMTLIBv2ParserPK_ProduceUnsatAssumptions, SMTLIBv2ParserPK_ProduceUnsatCores, SMTLIBv2ParserPK_RandomSeed, SMTLIBv2ParserPK_ReasonUnknown, SMTLIBv2ParserPK_RegularOutputChannel, SMTLIBv2ParserPK_ReproducibleResourceLimit, SMTLIBv2ParserPK_RightAssoc, SMTLIBv2ParserPK_SmtLibVersion, SMTLIBv2ParserPK_Sorts, SMTLIBv2ParserPK_SortsDescription, SMTLIBv2ParserPK_Source, SMTLIBv2ParserPK_Status, SMTLIBv2ParserPK_Theories, SMTLIBv2ParserPK_Values, SMTLIBv2ParserPK_Verbosity, SMTLIBv2ParserPK_Version:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(246)
			p.Keyword()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(247)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66))|(1<<(SMTLIBv2ParserColon-66))|(1<<(SMTLIBv2ParserPK_AllStatistics-66))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-66))|(1<<(SMTLIBv2ParserPK_Authors-66))|(1<<(SMTLIBv2ParserPK_Category-66))|(1<<(SMTLIBv2ParserPK_Chainable-66))|(1<<(SMTLIBv2ParserPK_Definition-66))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-66))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-66))|(1<<(SMTLIBv2ParserPK_Extension-66))|(1<<(SMTLIBv2ParserPK_Funs-66))|(1<<(SMTLIBv2ParserPK_FunsDescription-66))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-66))|(1<<(SMTLIBv2ParserPK_InteractiveMode-66))|(1<<(SMTLIBv2ParserPK_Language-66))|(1<<(SMTLIBv2ParserPK_LeftAssoc-66))|(1<<(SMTLIBv2ParserPK_License-66))|(1<<(SMTLIBv2ParserPK_Named-66))|(1<<(SMTLIBv2ParserPK_Name-66))|(1<<(SMTLIBv2ParserPK_Notes-66))|(1<<(SMTLIBv2ParserPK_Pattern-66))|(1<<(SMTLIBv2ParserPK_PrintSuccess-66))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-66))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-66))|(1<<(SMTLIBv2ParserPK_ProduceModels-66))|(1<<(SMTLIBv2ParserPK_ProduceProofs-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(SMTLIBv2ParserPK_RandomSeed-98))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-98))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-98))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-98))|(1<<(SMTLIBv2ParserPK_RightAssoc-98))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-98))|(1<<(SMTLIBv2ParserPK_Sorts-98))|(1<<(SMTLIBv2ParserPK_SortsDescription-98))|(1<<(SMTLIBv2ParserPK_Source-98))|(1<<(SMTLIBv2ParserPK_Status-98))|(1<<(SMTLIBv2ParserPK_Theories-98))|(1<<(SMTLIBv2ParserPK_Values-98))|(1<<(SMTLIBv2ParserPK_Verbosity-98))|(1<<(SMTLIBv2ParserPK_Version-98))|(1<<(SMTLIBv2ParserUndefinedSymbol-98)))) != 0) {
			{
				p.SetState(248)
				p.S_expr()
			}

			p.SetState(253)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(254)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexContext is an interface to support dynamic dispatch.
type IIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexContext differentiates from other interfaces.
	IsIndexContext()
}

type IndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexContext() *IndexContext {
	var p = new(IndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_index
	return p
}

func (*IndexContext) IsIndexContext() {}

func NewIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexContext {
	var p = new(IndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_index

	return p
}

func (s *IndexContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *IndexContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *IndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterIndex(s)
	}
}

func (s *IndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitIndex(s)
	}
}

func (s *IndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Index() (localctx IIndexContext) {
	localctx = NewIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SMTLIBv2ParserRULE_index)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(259)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserNumeral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(257)
			p.Numeral()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(258)
			p.Symbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *IdentifierContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *IdentifierContext) GRW_Underscore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Underscore, 0)
}

func (s *IdentifierContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *IdentifierContext) AllIndex() []IIndexContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexContext)(nil)).Elem())
	var tst = make([]IIndexContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexContext)
		}
	}

	return tst
}

func (s *IdentifierContext) Index(i int) IIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SMTLIBv2ParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(272)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(261)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(262)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(263)
			p.Match(SMTLIBv2ParserGRW_Underscore)
		}
		{
			p.SetState(264)
			p.Symbol()
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserNumeral || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(265)
				p.Index()
			}

			p.SetState(268)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(270)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribute_valueContext is an interface to support dynamic dispatch.
type IAttribute_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_valueContext differentiates from other interfaces.
	IsAttribute_valueContext()
}

type Attribute_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_valueContext() *Attribute_valueContext {
	var p = new(Attribute_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value
	return p
}

func (*Attribute_valueContext) IsAttribute_valueContext() {}

func NewAttribute_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_valueContext {
	var p = new(Attribute_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_attribute_value

	return p
}

func (s *Attribute_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_valueContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *Attribute_valueContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Attribute_valueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Attribute_valueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Attribute_valueContext) AllS_expr() []IS_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IS_exprContext)(nil)).Elem())
	var tst = make([]IS_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IS_exprContext)
		}
	}

	return tst
}

func (s *Attribute_valueContext) S_expr(i int) IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Attribute_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterAttribute_value(s)
	}
}

func (s *Attribute_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitAttribute_value(s)
	}
}

func (s *Attribute_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitAttribute_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Attribute_value() (localctx IAttribute_valueContext) {
	localctx = NewAttribute_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SMTLIBv2ParserRULE_attribute_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(284)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserString_, SMTLIBv2ParserNumeral, SMTLIBv2ParserBinary, SMTLIBv2ParserHexDecimal, SMTLIBv2ParserDecimal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(274)
			p.Spec_constant()
		}

	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(275)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(276)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66))|(1<<(SMTLIBv2ParserColon-66))|(1<<(SMTLIBv2ParserPK_AllStatistics-66))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-66))|(1<<(SMTLIBv2ParserPK_Authors-66))|(1<<(SMTLIBv2ParserPK_Category-66))|(1<<(SMTLIBv2ParserPK_Chainable-66))|(1<<(SMTLIBv2ParserPK_Definition-66))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-66))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-66))|(1<<(SMTLIBv2ParserPK_Extension-66))|(1<<(SMTLIBv2ParserPK_Funs-66))|(1<<(SMTLIBv2ParserPK_FunsDescription-66))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-66))|(1<<(SMTLIBv2ParserPK_InteractiveMode-66))|(1<<(SMTLIBv2ParserPK_Language-66))|(1<<(SMTLIBv2ParserPK_LeftAssoc-66))|(1<<(SMTLIBv2ParserPK_License-66))|(1<<(SMTLIBv2ParserPK_Named-66))|(1<<(SMTLIBv2ParserPK_Name-66))|(1<<(SMTLIBv2ParserPK_Notes-66))|(1<<(SMTLIBv2ParserPK_Pattern-66))|(1<<(SMTLIBv2ParserPK_PrintSuccess-66))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-66))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-66))|(1<<(SMTLIBv2ParserPK_ProduceModels-66))|(1<<(SMTLIBv2ParserPK_ProduceProofs-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-66))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(SMTLIBv2ParserPK_RandomSeed-98))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-98))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-98))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-98))|(1<<(SMTLIBv2ParserPK_RightAssoc-98))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-98))|(1<<(SMTLIBv2ParserPK_Sorts-98))|(1<<(SMTLIBv2ParserPK_SortsDescription-98))|(1<<(SMTLIBv2ParserPK_Source-98))|(1<<(SMTLIBv2ParserPK_Status-98))|(1<<(SMTLIBv2ParserPK_Theories-98))|(1<<(SMTLIBv2ParserPK_Values-98))|(1<<(SMTLIBv2ParserPK_Verbosity-98))|(1<<(SMTLIBv2ParserPK_Version-98))|(1<<(SMTLIBv2ParserUndefinedSymbol-98)))) != 0) {
			{
				p.SetState(277)
				p.S_expr()
			}

			p.SetState(282)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(283)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *AttributeContext) Attribute_value() IAttribute_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SMTLIBv2ParserRULE_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(286)
			p.Keyword()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(287)
			p.Keyword()
		}
		{
			p.SetState(288)
			p.Attribute_value()
		}

	}

	return localctx
}

// ISortContext is an interface to support dynamic dispatch.
type ISortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortContext differentiates from other interfaces.
	IsSortContext()
}

type SortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortContext() *SortContext {
	var p = new(SortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort
	return p
}

func (*SortContext) IsSortContext() {}

func NewSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortContext {
	var p = new(SortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort

	return p
}

func (s *SortContext) GetParser() antlr.Parser { return s.parser }

func (s *SortContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SortContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *SortContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *SortContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *SortContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *SortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort(s)
	}
}

func (s *SortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort(s)
	}
}

func (s *SortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort() (localctx ISortContext) {
	localctx = NewSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SMTLIBv2ParserRULE_sort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(292)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(293)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(294)
			p.Identifier()
		}
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(295)
				p.Sort()
			}

			p.SetState(298)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(300)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IQual_identiferContext is an interface to support dynamic dispatch.
type IQual_identiferContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQual_identiferContext differentiates from other interfaces.
	IsQual_identiferContext()
}

type Qual_identiferContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQual_identiferContext() *Qual_identiferContext {
	var p = new(Qual_identiferContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer
	return p
}

func (*Qual_identiferContext) IsQual_identiferContext() {}

func NewQual_identiferContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qual_identiferContext {
	var p = new(Qual_identiferContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_qual_identifer

	return p
}

func (s *Qual_identiferContext) GetParser() antlr.Parser { return s.parser }

func (s *Qual_identiferContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Qual_identiferContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Qual_identiferContext) GRW_As() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_As, 0)
}

func (s *Qual_identiferContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Qual_identiferContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Qual_identiferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qual_identiferContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qual_identiferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterQual_identifer(s)
	}
}

func (s *Qual_identiferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitQual_identifer(s)
	}
}

func (s *Qual_identiferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitQual_identifer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Qual_identifer() (localctx IQual_identiferContext) {
	localctx = NewQual_identiferContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SMTLIBv2ParserRULE_qual_identifer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(311)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(304)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(305)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(306)
			p.Match(SMTLIBv2ParserGRW_As)
		}
		{
			p.SetState(307)
			p.Identifier()
		}
		{
			p.SetState(308)
			p.Sort()
		}
		{
			p.SetState(309)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IVar_bindingContext is an interface to support dynamic dispatch.
type IVar_bindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_bindingContext differentiates from other interfaces.
	IsVar_bindingContext()
}

type Var_bindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_bindingContext() *Var_bindingContext {
	var p = new(Var_bindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding
	return p
}

func (*Var_bindingContext) IsVar_bindingContext() {}

func NewVar_bindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_bindingContext {
	var p = new(Var_bindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_var_binding

	return p
}

func (s *Var_bindingContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_bindingContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Var_bindingContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Var_bindingContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Var_bindingContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Var_bindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_bindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_bindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterVar_binding(s)
	}
}

func (s *Var_bindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitVar_binding(s)
	}
}

func (s *Var_bindingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitVar_binding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Var_binding() (localctx IVar_bindingContext) {
	localctx = NewVar_bindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SMTLIBv2ParserRULE_var_binding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(314)
		p.Symbol()
	}
	{
		p.SetState(315)
		p.Term()
	}
	{
		p.SetState(316)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISorted_varContext is an interface to support dynamic dispatch.
type ISorted_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSorted_varContext differentiates from other interfaces.
	IsSorted_varContext()
}

type Sorted_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySorted_varContext() *Sorted_varContext {
	var p = new(Sorted_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var
	return p
}

func (*Sorted_varContext) IsSorted_varContext() {}

func NewSorted_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sorted_varContext {
	var p = new(Sorted_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sorted_var

	return p
}

func (s *Sorted_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Sorted_varContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sorted_varContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Sorted_varContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Sorted_varContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sorted_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sorted_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sorted_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSorted_var(s)
	}
}

func (s *Sorted_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSorted_var(s)
	}
}

func (s *Sorted_varContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSorted_var(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sorted_var() (localctx ISorted_varContext) {
	localctx = NewSorted_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SMTLIBv2ParserRULE_sorted_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(319)
		p.Symbol()
	}
	{
		p.SetState(320)
		p.Sort()
	}
	{
		p.SetState(321)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *PatternContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *PatternContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *PatternContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPattern(s)
	}
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SMTLIBv2ParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(333)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(323)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(324)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(325)
			p.Symbol()
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(326)
				p.Symbol()
			}

			p.SetState(329)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(331)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatch_caseContext is an interface to support dynamic dispatch.
type IMatch_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatch_caseContext differentiates from other interfaces.
	IsMatch_caseContext()
}

type Match_caseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_caseContext() *Match_caseContext {
	var p = new(Match_caseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_match_case
	return p
}

func (*Match_caseContext) IsMatch_caseContext() {}

func NewMatch_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_caseContext {
	var p = new(Match_caseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_match_case

	return p
}

func (s *Match_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_caseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Match_caseContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Match_caseContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Match_caseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Match_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterMatch_case(s)
	}
}

func (s *Match_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitMatch_case(s)
	}
}

func (s *Match_caseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitMatch_case(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Match_case() (localctx IMatch_caseContext) {
	localctx = NewMatch_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SMTLIBv2ParserRULE_match_case)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(336)
		p.Pattern()
	}
	{
		p.SetState(337)
		p.Term()
	}
	{
		p.SetState(338)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SMTLIBv2ParserRULE_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Symbol()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *TermContext) Qual_identifer() IQual_identiferContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQual_identiferContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQual_identiferContext)
}

func (s *TermContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *TermContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *TermContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *TermContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *TermContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *TermContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GRW_Let() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Let, 0)
}

func (s *TermContext) AllVar_binding() []IVar_bindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVar_bindingContext)(nil)).Elem())
	var tst = make([]IVar_bindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVar_bindingContext)
		}
	}

	return tst
}

func (s *TermContext) Var_binding(i int) IVar_bindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_bindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVar_bindingContext)
}

func (s *TermContext) GRW_Forall() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Forall, 0)
}

func (s *TermContext) AllSorted_var() []ISorted_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISorted_varContext)(nil)).Elem())
	var tst = make([]ISorted_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISorted_varContext)
		}
	}

	return tst
}

func (s *TermContext) Sorted_var(i int) ISorted_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISorted_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *TermContext) GRW_Exists() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exists, 0)
}

func (s *TermContext) GRW_Match() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Match, 0)
}

func (s *TermContext) AllMatch_case() []IMatch_caseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMatch_caseContext)(nil)).Elem())
	var tst = make([]IMatch_caseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMatch_caseContext)
		}
	}

	return tst
}

func (s *TermContext) Match_case(i int) IMatch_caseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatch_caseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMatch_caseContext)
}

func (s *TermContext) GRW_Exclamation() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Exclamation, 0)
}

func (s *TermContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *TermContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SMTLIBv2ParserRULE_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(342)
			p.Spec_constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(343)
			p.Qual_identifer()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(344)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(345)
			p.Qual_identifer()
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(346)
				p.Term()
			}

			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(351)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(353)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(354)
			p.Match(SMTLIBv2ParserGRW_Let)
		}
		{
			p.SetState(355)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(356)
				p.Var_binding()
			}

			p.SetState(359)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(361)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(362)
			p.Term()
		}
		{
			p.SetState(363)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(365)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(366)
			p.Match(SMTLIBv2ParserGRW_Forall)
		}
		{
			p.SetState(367)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(368)
				p.Sorted_var()
			}

			p.SetState(371)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(373)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(374)
			p.Term()
		}
		{
			p.SetState(375)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(377)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(378)
			p.Match(SMTLIBv2ParserGRW_Exists)
		}
		{
			p.SetState(379)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(380)
				p.Sorted_var()
			}

			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(385)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(386)
			p.Term()
		}
		{
			p.SetState(387)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(389)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(390)
			p.Match(SMTLIBv2ParserGRW_Match)
		}
		{
			p.SetState(391)
			p.Term()
		}
		{
			p.SetState(392)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(393)
				p.Match_case()
			}

			p.SetState(396)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(398)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(399)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(401)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(402)
			p.Match(SMTLIBv2ParserGRW_Exclamation)
		}
		{
			p.SetState(403)
			p.Term()
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(404)
				p.Attribute()
			}

			p.SetState(407)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(409)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// ISort_symbol_declContext is an interface to support dynamic dispatch.
type ISort_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSort_symbol_declContext differentiates from other interfaces.
	IsSort_symbol_declContext()
}

type Sort_symbol_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_symbol_declContext() *Sort_symbol_declContext {
	var p = new(Sort_symbol_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl
	return p
}

func (*Sort_symbol_declContext) IsSort_symbol_declContext() {}

func NewSort_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_symbol_declContext {
	var p = new(Sort_symbol_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort_symbol_decl

	return p
}

func (s *Sort_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_symbol_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sort_symbol_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Sort_symbol_declContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Sort_symbol_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sort_symbol_declContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *Sort_symbol_declContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Sort_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort_symbol_decl(s)
	}
}

func (s *Sort_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort_symbol_decl(s)
	}
}

func (s *Sort_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort_symbol_decl() (localctx ISort_symbol_declContext) {
	localctx = NewSort_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SMTLIBv2ParserRULE_sort_symbol_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(414)
		p.Identifier()
	}
	{
		p.SetState(415)
		p.Numeral()
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(416)
			p.Attribute()
		}

		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(422)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IMeta_spec_constantContext is an interface to support dynamic dispatch.
type IMeta_spec_constantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMeta_spec_constantContext differentiates from other interfaces.
	IsMeta_spec_constantContext()
}

type Meta_spec_constantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeta_spec_constantContext() *Meta_spec_constantContext {
	var p = new(Meta_spec_constantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant
	return p
}

func (*Meta_spec_constantContext) IsMeta_spec_constantContext() {}

func NewMeta_spec_constantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Meta_spec_constantContext {
	var p = new(Meta_spec_constantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_meta_spec_constant

	return p
}

func (s *Meta_spec_constantContext) GetParser() antlr.Parser { return s.parser }

func (s *Meta_spec_constantContext) GRW_Numeral() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Numeral, 0)
}

func (s *Meta_spec_constantContext) GRW_Decimal() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Decimal, 0)
}

func (s *Meta_spec_constantContext) GRW_String() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_String, 0)
}

func (s *Meta_spec_constantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Meta_spec_constantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Meta_spec_constantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterMeta_spec_constant(s)
	}
}

func (s *Meta_spec_constantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitMeta_spec_constant(s)
	}
}

func (s *Meta_spec_constantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitMeta_spec_constant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Meta_spec_constant() (localctx IMeta_spec_constantContext) {
	localctx = NewMeta_spec_constantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SMTLIBv2ParserRULE_meta_spec_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(SMTLIBv2ParserGRW_Decimal-57))|(1<<(SMTLIBv2ParserGRW_Numeral-57))|(1<<(SMTLIBv2ParserGRW_String-57)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFun_symbol_declContext is an interface to support dynamic dispatch.
type IFun_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFun_symbol_declContext differentiates from other interfaces.
	IsFun_symbol_declContext()
}

type Fun_symbol_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFun_symbol_declContext() *Fun_symbol_declContext {
	var p = new(Fun_symbol_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl
	return p
}

func (*Fun_symbol_declContext) IsFun_symbol_declContext() {}

func NewFun_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fun_symbol_declContext {
	var p = new(Fun_symbol_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_fun_symbol_decl

	return p
}

func (s *Fun_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Fun_symbol_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Fun_symbol_declContext) Spec_constant() ISpec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpec_constantContext)
}

func (s *Fun_symbol_declContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *Fun_symbol_declContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Fun_symbol_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Fun_symbol_declContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *Fun_symbol_declContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Fun_symbol_declContext) Meta_spec_constant() IMeta_spec_constantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMeta_spec_constantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMeta_spec_constantContext)
}

func (s *Fun_symbol_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Fun_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fun_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fun_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFun_symbol_decl(s)
	}
}

func (s *Fun_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFun_symbol_decl(s)
	}
}

func (s *Fun_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFun_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Fun_symbol_decl() (localctx IFun_symbol_declContext) {
	localctx = NewFun_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SMTLIBv2ParserRULE_fun_symbol_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(426)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(427)
			p.Spec_constant()
		}
		{
			p.SetState(428)
			p.Sort()
		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(429)
				p.Attribute()
			}

			p.SetState(434)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(435)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(437)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(438)
			p.Meta_spec_constant()
		}
		{
			p.SetState(439)
			p.Sort()
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(440)
				p.Attribute()
			}

			p.SetState(445)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(446)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(448)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(449)
			p.Identifier()
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(450)
				p.Sort()
			}

			p.SetState(453)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(458)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(455)
				p.Attribute()
			}

			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(461)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IPar_fun_symbol_declContext is an interface to support dynamic dispatch.
type IPar_fun_symbol_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_fun_symbol_declContext differentiates from other interfaces.
	IsPar_fun_symbol_declContext()
}

type Par_fun_symbol_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_fun_symbol_declContext() *Par_fun_symbol_declContext {
	var p = new(Par_fun_symbol_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl
	return p
}

func (*Par_fun_symbol_declContext) IsPar_fun_symbol_declContext() {}

func NewPar_fun_symbol_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_fun_symbol_declContext {
	var p = new(Par_fun_symbol_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_par_fun_symbol_decl

	return p
}

func (s *Par_fun_symbol_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_fun_symbol_declContext) Fun_symbol_decl() IFun_symbol_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFun_symbol_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFun_symbol_declContext)
}

func (s *Par_fun_symbol_declContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Par_fun_symbol_declContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Par_fun_symbol_declContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *Par_fun_symbol_declContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Par_fun_symbol_declContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Par_fun_symbol_declContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Par_fun_symbol_declContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Par_fun_symbol_declContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Par_fun_symbol_declContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *Par_fun_symbol_declContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Par_fun_symbol_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_fun_symbol_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_fun_symbol_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterPar_fun_symbol_decl(s)
	}
}

func (s *Par_fun_symbol_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitPar_fun_symbol_decl(s)
	}
}

func (s *Par_fun_symbol_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitPar_fun_symbol_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Par_fun_symbol_decl() (localctx IPar_fun_symbol_declContext) {
	localctx = NewPar_fun_symbol_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SMTLIBv2ParserRULE_par_fun_symbol_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(465)
			p.Fun_symbol_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(466)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(467)
			p.Match(SMTLIBv2ParserGRW_Par)
		}
		{
			p.SetState(468)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(469)
				p.Symbol()
			}

			p.SetState(472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(474)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(475)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(476)
			p.Identifier()
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(477)
				p.Sort()
			}

			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
			{
				p.SetState(482)
				p.Attribute()
			}

			p.SetState(487)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(488)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(489)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// ITheory_attributeContext is an interface to support dynamic dispatch.
type ITheory_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTheory_attributeContext differentiates from other interfaces.
	IsTheory_attributeContext()
}

type Theory_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_attributeContext() *Theory_attributeContext {
	var p = new(Theory_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute
	return p
}

func (*Theory_attributeContext) IsTheory_attributeContext() {}

func NewTheory_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_attributeContext {
	var p = new(Theory_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_theory_attribute

	return p
}

func (s *Theory_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_attributeContext) PK_Sorts() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Sorts, 0)
}

func (s *Theory_attributeContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Theory_attributeContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Theory_attributeContext) AllSort_symbol_decl() []ISort_symbol_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISort_symbol_declContext)(nil)).Elem())
	var tst = make([]ISort_symbol_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISort_symbol_declContext)
		}
	}

	return tst
}

func (s *Theory_attributeContext) Sort_symbol_decl(i int) ISort_symbol_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISort_symbol_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISort_symbol_declContext)
}

func (s *Theory_attributeContext) PK_Funs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Funs, 0)
}

func (s *Theory_attributeContext) AllPar_fun_symbol_decl() []IPar_fun_symbol_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPar_fun_symbol_declContext)(nil)).Elem())
	var tst = make([]IPar_fun_symbol_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPar_fun_symbol_declContext)
		}
	}

	return tst
}

func (s *Theory_attributeContext) Par_fun_symbol_decl(i int) IPar_fun_symbol_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_fun_symbol_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPar_fun_symbol_declContext)
}

func (s *Theory_attributeContext) PK_SortsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_SortsDescription, 0)
}

func (s *Theory_attributeContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Theory_attributeContext) PK_FunsDescription() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_FunsDescription, 0)
}

func (s *Theory_attributeContext) PK_Definition() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Definition, 0)
}

func (s *Theory_attributeContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *Theory_attributeContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *Theory_attributeContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Theory_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTheory_attribute(s)
	}
}

func (s *Theory_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTheory_attribute(s)
	}
}

func (s *Theory_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTheory_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Theory_attribute() (localctx ITheory_attributeContext) {
	localctx = NewTheory_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SMTLIBv2ParserRULE_theory_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(493)
			p.Match(SMTLIBv2ParserPK_Sorts)
		}
		{
			p.SetState(494)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(495)
				p.Sort_symbol_decl()
			}

			p.SetState(498)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(500)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(502)
			p.Match(SMTLIBv2ParserPK_Funs)
		}
		{
			p.SetState(503)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(504)
				p.Par_fun_symbol_decl()
			}

			p.SetState(507)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(509)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(511)
			p.Match(SMTLIBv2ParserPK_SortsDescription)
		}
		{
			p.SetState(512)
			p.String_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(513)
			p.Match(SMTLIBv2ParserPK_FunsDescription)
		}
		{
			p.SetState(514)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(515)
			p.Match(SMTLIBv2ParserPK_Definition)
		}
		{
			p.SetState(516)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(517)
			p.Match(SMTLIBv2ParserPK_Values)
		}
		{
			p.SetState(518)
			p.String_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(519)
			p.Match(SMTLIBv2ParserPK_Notes)
		}
		{
			p.SetState(520)
			p.String_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(521)
			p.Attribute()
		}

	}

	return localctx
}

// ITheory_declContext is an interface to support dynamic dispatch.
type ITheory_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTheory_declContext differentiates from other interfaces.
	IsTheory_declContext()
}

type Theory_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheory_declContext() *Theory_declContext {
	var p = new(Theory_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl
	return p
}

func (*Theory_declContext) IsTheory_declContext() {}

func NewTheory_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Theory_declContext {
	var p = new(Theory_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_theory_decl

	return p
}

func (s *Theory_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Theory_declContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Theory_declContext) PS_Theory() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Theory, 0)
}

func (s *Theory_declContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Theory_declContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Theory_declContext) AllTheory_attribute() []ITheory_attributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITheory_attributeContext)(nil)).Elem())
	var tst = make([]ITheory_attributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITheory_attributeContext)
		}
	}

	return tst
}

func (s *Theory_declContext) Theory_attribute(i int) ITheory_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITheory_attributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITheory_attributeContext)
}

func (s *Theory_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Theory_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Theory_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterTheory_decl(s)
	}
}

func (s *Theory_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitTheory_decl(s)
	}
}

func (s *Theory_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitTheory_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Theory_decl() (localctx ITheory_declContext) {
	localctx = NewTheory_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SMTLIBv2ParserRULE_theory_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(525)
		p.Match(SMTLIBv2ParserPS_Theory)
	}
	{
		p.SetState(526)
		p.Symbol()
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(527)
			p.Theory_attribute()
		}

		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(532)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ILogic_attribueContext is an interface to support dynamic dispatch.
type ILogic_attribueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogic_attribueContext differentiates from other interfaces.
	IsLogic_attribueContext()
}

type Logic_attribueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogic_attribueContext() *Logic_attribueContext {
	var p = new(Logic_attribueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue
	return p
}

func (*Logic_attribueContext) IsLogic_attribueContext() {}

func NewLogic_attribueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logic_attribueContext {
	var p = new(Logic_attribueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_logic_attribue

	return p
}

func (s *Logic_attribueContext) GetParser() antlr.Parser { return s.parser }

func (s *Logic_attribueContext) PK_Theories() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Theories, 0)
}

func (s *Logic_attribueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Logic_attribueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Logic_attribueContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Logic_attribueContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Logic_attribueContext) PK_Language() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Language, 0)
}

func (s *Logic_attribueContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Logic_attribueContext) PK_Extension() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Extension, 0)
}

func (s *Logic_attribueContext) PK_Values() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Values, 0)
}

func (s *Logic_attribueContext) PK_Notes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Notes, 0)
}

func (s *Logic_attribueContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Logic_attribueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logic_attribueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logic_attribueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterLogic_attribue(s)
	}
}

func (s *Logic_attribueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitLogic_attribue(s)
	}
}

func (s *Logic_attribueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitLogic_attribue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Logic_attribue() (localctx ILogic_attribueContext) {
	localctx = NewLogic_attribueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SMTLIBv2ParserRULE_logic_attribue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.Match(SMTLIBv2ParserPK_Theories)
		}
		{
			p.SetState(535)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(536)
				p.Symbol()
			}

			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(541)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(543)
			p.Match(SMTLIBv2ParserPK_Language)
		}
		{
			p.SetState(544)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(545)
			p.Match(SMTLIBv2ParserPK_Extension)
		}
		{
			p.SetState(546)
			p.String_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(547)
			p.Match(SMTLIBv2ParserPK_Values)
		}
		{
			p.SetState(548)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(549)
			p.Match(SMTLIBv2ParserPK_Notes)
		}
		{
			p.SetState(550)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(551)
			p.Attribute()
		}

	}

	return localctx
}

// ILogicContext is an interface to support dynamic dispatch.
type ILogicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicContext differentiates from other interfaces.
	IsLogicContext()
}

type LogicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicContext() *LogicContext {
	var p = new(LogicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_logic
	return p
}

func (*LogicContext) IsLogicContext() {}

func NewLogicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicContext {
	var p = new(LogicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_logic

	return p
}

func (s *LogicContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *LogicContext) PS_Logic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Logic, 0)
}

func (s *LogicContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *LogicContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *LogicContext) AllLogic_attribue() []ILogic_attribueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogic_attribueContext)(nil)).Elem())
	var tst = make([]ILogic_attribueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogic_attribueContext)
		}
	}

	return tst
}

func (s *LogicContext) Logic_attribue(i int) ILogic_attribueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogic_attribueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogic_attribueContext)
}

func (s *LogicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterLogic(s)
	}
}

func (s *LogicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitLogic(s)
	}
}

func (s *LogicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitLogic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Logic() (localctx ILogicContext) {
	localctx = NewLogicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SMTLIBv2ParserRULE_logic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(555)
		p.Match(SMTLIBv2ParserPS_Logic)
	}
	{
		p.SetState(556)
		p.Symbol()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(557)
			p.Logic_attribue()
		}

		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(562)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISort_decContext is an interface to support dynamic dispatch.
type ISort_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSort_decContext differentiates from other interfaces.
	IsSort_decContext()
}

type Sort_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_decContext() *Sort_decContext {
	var p = new(Sort_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec
	return p
}

func (*Sort_decContext) IsSort_decContext() {}

func NewSort_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_decContext {
	var p = new(Sort_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_sort_dec

	return p
}

func (s *Sort_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Sort_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Sort_decContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Sort_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Sort_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSort_dec(s)
	}
}

func (s *Sort_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSort_dec(s)
	}
}

func (s *Sort_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSort_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Sort_dec() (localctx ISort_decContext) {
	localctx = NewSort_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SMTLIBv2ParserRULE_sort_dec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(565)
		p.Symbol()
	}
	{
		p.SetState(566)
		p.Numeral()
	}
	{
		p.SetState(567)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISelector_decContext is an interface to support dynamic dispatch.
type ISelector_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelector_decContext differentiates from other interfaces.
	IsSelector_decContext()
}

type Selector_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelector_decContext() *Selector_decContext {
	var p = new(Selector_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec
	return p
}

func (*Selector_decContext) IsSelector_decContext() {}

func NewSelector_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selector_decContext {
	var p = new(Selector_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_selector_dec

	return p
}

func (s *Selector_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Selector_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Selector_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Selector_decContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Selector_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Selector_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selector_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selector_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSelector_dec(s)
	}
}

func (s *Selector_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSelector_dec(s)
	}
}

func (s *Selector_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSelector_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Selector_dec() (localctx ISelector_decContext) {
	localctx = NewSelector_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SMTLIBv2ParserRULE_selector_dec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(570)
		p.Symbol()
	}
	{
		p.SetState(571)
		p.Sort()
	}
	{
		p.SetState(572)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IConstructor_decContext is an interface to support dynamic dispatch.
type IConstructor_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_decContext differentiates from other interfaces.
	IsConstructor_decContext()
}

type Constructor_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_decContext() *Constructor_decContext {
	var p = new(Constructor_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec
	return p
}

func (*Constructor_decContext) IsConstructor_decContext() {}

func NewConstructor_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_decContext {
	var p = new(Constructor_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_constructor_dec

	return p
}

func (s *Constructor_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_decContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Constructor_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Constructor_decContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Constructor_decContext) AllSelector_dec() []ISelector_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelector_decContext)(nil)).Elem())
	var tst = make([]ISelector_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelector_decContext)
		}
	}

	return tst
}

func (s *Constructor_decContext) Selector_dec(i int) ISelector_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelector_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelector_decContext)
}

func (s *Constructor_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterConstructor_dec(s)
	}
}

func (s *Constructor_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitConstructor_dec(s)
	}
}

func (s *Constructor_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitConstructor_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Constructor_dec() (localctx IConstructor_decContext) {
	localctx = NewConstructor_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SMTLIBv2ParserRULE_constructor_dec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(575)
		p.Symbol()
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(576)
			p.Selector_dec()
		}

		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(582)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IDatatype_decContext is an interface to support dynamic dispatch.
type IDatatype_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatatype_decContext differentiates from other interfaces.
	IsDatatype_decContext()
}

type Datatype_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatype_decContext() *Datatype_decContext {
	var p = new(Datatype_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec
	return p
}

func (*Datatype_decContext) IsDatatype_decContext() {}

func NewDatatype_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datatype_decContext {
	var p = new(Datatype_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_datatype_dec

	return p
}

func (s *Datatype_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Datatype_decContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Datatype_decContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Datatype_decContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Datatype_decContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Datatype_decContext) AllConstructor_dec() []IConstructor_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstructor_decContext)(nil)).Elem())
	var tst = make([]IConstructor_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstructor_decContext)
		}
	}

	return tst
}

func (s *Datatype_decContext) Constructor_dec(i int) IConstructor_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstructor_decContext)
}

func (s *Datatype_decContext) GRW_Par() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserGRW_Par, 0)
}

func (s *Datatype_decContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Datatype_decContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Datatype_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datatype_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datatype_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterDatatype_dec(s)
	}
}

func (s *Datatype_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitDatatype_dec(s)
	}
}

func (s *Datatype_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitDatatype_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Datatype_dec() (localctx IDatatype_decContext) {
	localctx = NewDatatype_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SMTLIBv2ParserRULE_datatype_dec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(584)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(585)
				p.Constructor_dec()
			}

			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(590)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(592)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(593)
			p.Match(SMTLIBv2ParserGRW_Par)
		}
		{
			p.SetState(594)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
			{
				p.SetState(595)
				p.Symbol()
			}

			p.SetState(598)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(600)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(601)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(602)
				p.Constructor_dec()
			}

			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(607)
			p.Match(SMTLIBv2ParserParClose)
		}
		{
			p.SetState(608)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IFunction_decContext is an interface to support dynamic dispatch.
type IFunction_decContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_decContext differentiates from other interfaces.
	IsFunction_decContext()
}

type Function_decContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_decContext() *Function_decContext {
	var p = new(Function_decContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec
	return p
}

func (*Function_decContext) IsFunction_decContext() {}

func NewFunction_decContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_decContext {
	var p = new(Function_decContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_function_dec

	return p
}

func (s *Function_decContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_decContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Function_decContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Function_decContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Function_decContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Function_decContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Function_decContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Function_decContext) AllSorted_var() []ISorted_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISorted_varContext)(nil)).Elem())
	var tst = make([]ISorted_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISorted_varContext)
		}
	}

	return tst
}

func (s *Function_decContext) Sorted_var(i int) ISorted_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISorted_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *Function_decContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_decContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_decContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFunction_dec(s)
	}
}

func (s *Function_decContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFunction_dec(s)
	}
}

func (s *Function_decContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFunction_dec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Function_dec() (localctx IFunction_decContext) {
	localctx = NewFunction_decContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SMTLIBv2ParserRULE_function_dec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(613)
		p.Symbol()
	}
	{
		p.SetState(614)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(615)
			p.Sorted_var()
		}

		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(621)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(622)
		p.Sort()
	}
	{
		p.SetState(623)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IFunction_defContext is an interface to support dynamic dispatch.
type IFunction_defContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_defContext differentiates from other interfaces.
	IsFunction_defContext()
}

type Function_defContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_defContext() *Function_defContext {
	var p = new(Function_defContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_function_def
	return p
}

func (*Function_defContext) IsFunction_defContext() {}

func NewFunction_defContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_defContext {
	var p = new(Function_defContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_function_def

	return p
}

func (s *Function_defContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_defContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Function_defContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Function_defContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Function_defContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Function_defContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Function_defContext) AllSorted_var() []ISorted_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISorted_varContext)(nil)).Elem())
	var tst = make([]ISorted_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISorted_varContext)
		}
	}

	return tst
}

func (s *Function_defContext) Sorted_var(i int) ISorted_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISorted_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISorted_varContext)
}

func (s *Function_defContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_defContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_defContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterFunction_def(s)
	}
}

func (s *Function_defContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitFunction_def(s)
	}
}

func (s *Function_defContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitFunction_def(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Function_def() (localctx IFunction_defContext) {
	localctx = NewFunction_defContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SMTLIBv2ParserRULE_function_def)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Variable()
	}
	{
		p.SetState(626)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(627)
			p.Sorted_var()
		}

		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(633)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(634)
		p.Sort()
	}
	{
		p.SetState(635)
		p.Term()
	}

	return localctx
}

// IProp_literalContext is an interface to support dynamic dispatch.
type IProp_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProp_literalContext differentiates from other interfaces.
	IsProp_literalContext()
}

type Prop_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProp_literalContext() *Prop_literalContext {
	var p = new(Prop_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal
	return p
}

func (*Prop_literalContext) IsProp_literalContext() {}

func NewProp_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Prop_literalContext {
	var p = new(Prop_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_prop_literal

	return p
}

func (s *Prop_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Prop_literalContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Prop_literalContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Prop_literalContext) PS_Not() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Not, 0)
}

func (s *Prop_literalContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Prop_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Prop_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Prop_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterProp_literal(s)
	}
}

func (s *Prop_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitProp_literal(s)
	}
}

func (s *Prop_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitProp_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Prop_literal() (localctx IProp_literalContext) {
	localctx = NewProp_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SMTLIBv2ParserRULE_prop_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(643)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SMTLIBv2ParserQuotedSymbol, SMTLIBv2ParserPS_Not, SMTLIBv2ParserPS_Bool, SMTLIBv2ParserPS_ContinuedExecution, SMTLIBv2ParserPS_Error, SMTLIBv2ParserPS_False, SMTLIBv2ParserPS_ImmediateExit, SMTLIBv2ParserPS_Incomplete, SMTLIBv2ParserPS_Logic, SMTLIBv2ParserPS_Memout, SMTLIBv2ParserPS_Sat, SMTLIBv2ParserPS_Success, SMTLIBv2ParserPS_Theory, SMTLIBv2ParserPS_True, SMTLIBv2ParserPS_Unknown, SMTLIBv2ParserPS_Unsupported, SMTLIBv2ParserPS_Unsat, SMTLIBv2ParserUndefinedSymbol:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.Symbol()
		}

	case SMTLIBv2ParserParOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(639)
			p.Match(SMTLIBv2ParserPS_Not)
		}
		{
			p.SetState(640)
			p.Symbol()
		}
		{
			p.SetState(641)
			p.Match(SMTLIBv2ParserParClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_script
	return p
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) AllCommand() []ICommandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommandContext)(nil)).Elem())
	var tst = make([]ICommandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommandContext)
		}
	}

	return tst
}

func (s *ScriptContext) Command(i int) ICommandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommandContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitScript(s)
	}
}

func (s *ScriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitScript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SMTLIBv2ParserRULE_script)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(645)
			p.Command()
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICmd_assertContext is an interface to support dynamic dispatch.
type ICmd_assertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_assertContext differentiates from other interfaces.
	IsCmd_assertContext()
}

type Cmd_assertContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_assertContext() *Cmd_assertContext {
	var p = new(Cmd_assertContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert
	return p
}

func (*Cmd_assertContext) IsCmd_assertContext() {}

func NewCmd_assertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_assertContext {
	var p = new(Cmd_assertContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_assert

	return p
}

func (s *Cmd_assertContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_assertContext) CMD_Assert() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Assert, 0)
}

func (s *Cmd_assertContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_assertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_assertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_assertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_assert(s)
	}
}

func (s *Cmd_assertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_assert(s)
	}
}

func (s *Cmd_assertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_assert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_assert() (localctx ICmd_assertContext) {
	localctx = NewCmd_assertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SMTLIBv2ParserRULE_cmd_assert)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(SMTLIBv2ParserCMD_Assert)
	}
	{
		p.SetState(652)
		p.Term()
	}

	return localctx
}

// ICmd_checkSatContext is an interface to support dynamic dispatch.
type ICmd_checkSatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_checkSatContext differentiates from other interfaces.
	IsCmd_checkSatContext()
}

type Cmd_checkSatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_checkSatContext() *Cmd_checkSatContext {
	var p = new(Cmd_checkSatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat
	return p
}

func (*Cmd_checkSatContext) IsCmd_checkSatContext() {}

func NewCmd_checkSatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_checkSatContext {
	var p = new(Cmd_checkSatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSat

	return p
}

func (s *Cmd_checkSatContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_checkSatContext) CMD_CheckSat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_CheckSat, 0)
}

func (s *Cmd_checkSatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_checkSatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_checkSatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_checkSat(s)
	}
}

func (s *Cmd_checkSatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_checkSat(s)
	}
}

func (s *Cmd_checkSatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_checkSat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_checkSat() (localctx ICmd_checkSatContext) {
	localctx = NewCmd_checkSatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SMTLIBv2ParserRULE_cmd_checkSat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Match(SMTLIBv2ParserCMD_CheckSat)
	}

	return localctx
}

// ICmd_checkSatAssumingContext is an interface to support dynamic dispatch.
type ICmd_checkSatAssumingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_checkSatAssumingContext differentiates from other interfaces.
	IsCmd_checkSatAssumingContext()
}

type Cmd_checkSatAssumingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_checkSatAssumingContext() *Cmd_checkSatAssumingContext {
	var p = new(Cmd_checkSatAssumingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming
	return p
}

func (*Cmd_checkSatAssumingContext) IsCmd_checkSatAssumingContext() {}

func NewCmd_checkSatAssumingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_checkSatAssumingContext {
	var p = new(Cmd_checkSatAssumingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_checkSatAssuming

	return p
}

func (s *Cmd_checkSatAssumingContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_checkSatAssumingContext) CMD_CheckSatAssuming() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_CheckSatAssuming, 0)
}

func (s *Cmd_checkSatAssumingContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_checkSatAssumingContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_checkSatAssumingContext) AllProp_literal() []IProp_literalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProp_literalContext)(nil)).Elem())
	var tst = make([]IProp_literalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProp_literalContext)
		}
	}

	return tst
}

func (s *Cmd_checkSatAssumingContext) Prop_literal(i int) IProp_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProp_literalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProp_literalContext)
}

func (s *Cmd_checkSatAssumingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_checkSatAssumingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_checkSatAssumingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_checkSatAssuming(s)
	}
}

func (s *Cmd_checkSatAssumingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_checkSatAssuming(s)
	}
}

func (s *Cmd_checkSatAssumingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_checkSatAssuming(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_checkSatAssuming() (localctx ICmd_checkSatAssumingContext) {
	localctx = NewCmd_checkSatAssumingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SMTLIBv2ParserRULE_cmd_checkSatAssuming)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(SMTLIBv2ParserCMD_CheckSatAssuming)
	}
	{
		p.SetState(657)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(658)
			p.Prop_literal()
		}

		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(664)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_declareConstContext is an interface to support dynamic dispatch.
type ICmd_declareConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareConstContext differentiates from other interfaces.
	IsCmd_declareConstContext()
}

type Cmd_declareConstContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareConstContext() *Cmd_declareConstContext {
	var p = new(Cmd_declareConstContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst
	return p
}

func (*Cmd_declareConstContext) IsCmd_declareConstContext() {}

func NewCmd_declareConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareConstContext {
	var p = new(Cmd_declareConstContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareConst

	return p
}

func (s *Cmd_declareConstContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareConstContext) CMD_DeclareConst() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareConst, 0)
}

func (s *Cmd_declareConstContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareConstContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_declareConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareConst(s)
	}
}

func (s *Cmd_declareConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareConst(s)
	}
}

func (s *Cmd_declareConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareConst() (localctx ICmd_declareConstContext) {
	localctx = NewCmd_declareConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SMTLIBv2ParserRULE_cmd_declareConst)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(SMTLIBv2ParserCMD_DeclareConst)
	}
	{
		p.SetState(667)
		p.Symbol()
	}
	{
		p.SetState(668)
		p.Sort()
	}

	return localctx
}

// ICmd_declareDatatypeContext is an interface to support dynamic dispatch.
type ICmd_declareDatatypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareDatatypeContext differentiates from other interfaces.
	IsCmd_declareDatatypeContext()
}

type Cmd_declareDatatypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareDatatypeContext() *Cmd_declareDatatypeContext {
	var p = new(Cmd_declareDatatypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype
	return p
}

func (*Cmd_declareDatatypeContext) IsCmd_declareDatatypeContext() {}

func NewCmd_declareDatatypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareDatatypeContext {
	var p = new(Cmd_declareDatatypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatype

	return p
}

func (s *Cmd_declareDatatypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareDatatypeContext) CMD_DeclareDatatype() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareDatatype, 0)
}

func (s *Cmd_declareDatatypeContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareDatatypeContext) Datatype_dec() IDatatype_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatype_decContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatatype_decContext)
}

func (s *Cmd_declareDatatypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareDatatypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareDatatypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareDatatype(s)
	}
}

func (s *Cmd_declareDatatypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareDatatype(s)
	}
}

func (s *Cmd_declareDatatypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareDatatype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareDatatype() (localctx ICmd_declareDatatypeContext) {
	localctx = NewCmd_declareDatatypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SMTLIBv2ParserRULE_cmd_declareDatatype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(SMTLIBv2ParserCMD_DeclareDatatype)
	}
	{
		p.SetState(671)
		p.Symbol()
	}
	{
		p.SetState(672)
		p.Datatype_dec()
	}

	return localctx
}

// ICmd_declareDatatypesContext is an interface to support dynamic dispatch.
type ICmd_declareDatatypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareDatatypesContext differentiates from other interfaces.
	IsCmd_declareDatatypesContext()
}

type Cmd_declareDatatypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareDatatypesContext() *Cmd_declareDatatypesContext {
	var p = new(Cmd_declareDatatypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes
	return p
}

func (*Cmd_declareDatatypesContext) IsCmd_declareDatatypesContext() {}

func NewCmd_declareDatatypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareDatatypesContext {
	var p = new(Cmd_declareDatatypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareDatatypes

	return p
}

func (s *Cmd_declareDatatypesContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareDatatypesContext) CMD_DeclareDatatypes() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareDatatypes, 0)
}

func (s *Cmd_declareDatatypesContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Cmd_declareDatatypesContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Cmd_declareDatatypesContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Cmd_declareDatatypesContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Cmd_declareDatatypesContext) AllSort_dec() []ISort_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISort_decContext)(nil)).Elem())
	var tst = make([]ISort_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISort_decContext)
		}
	}

	return tst
}

func (s *Cmd_declareDatatypesContext) Sort_dec(i int) ISort_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISort_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISort_decContext)
}

func (s *Cmd_declareDatatypesContext) AllDatatype_dec() []IDatatype_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatatype_decContext)(nil)).Elem())
	var tst = make([]IDatatype_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatatype_decContext)
		}
	}

	return tst
}

func (s *Cmd_declareDatatypesContext) Datatype_dec(i int) IDatatype_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatype_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatatype_decContext)
}

func (s *Cmd_declareDatatypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareDatatypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareDatatypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareDatatypes(s)
	}
}

func (s *Cmd_declareDatatypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareDatatypes(s)
	}
}

func (s *Cmd_declareDatatypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareDatatypes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareDatatypes() (localctx ICmd_declareDatatypesContext) {
	localctx = NewCmd_declareDatatypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SMTLIBv2ParserRULE_cmd_declareDatatypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(SMTLIBv2ParserCMD_DeclareDatatypes)
	}
	{
		p.SetState(675)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(676)
			p.Sort_dec()
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(681)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(682)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(683)
			p.Datatype_dec()
		}

		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(688)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_declareFunContext is an interface to support dynamic dispatch.
type ICmd_declareFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareFunContext differentiates from other interfaces.
	IsCmd_declareFunContext()
}

type Cmd_declareFunContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareFunContext() *Cmd_declareFunContext {
	var p = new(Cmd_declareFunContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun
	return p
}

func (*Cmd_declareFunContext) IsCmd_declareFunContext() {}

func NewCmd_declareFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareFunContext {
	var p = new(Cmd_declareFunContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareFun

	return p
}

func (s *Cmd_declareFunContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareFunContext) CMD_DeclareFun() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareFun, 0)
}

func (s *Cmd_declareFunContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareFunContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_declareFunContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_declareFunContext) AllSort() []ISortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortContext)(nil)).Elem())
	var tst = make([]ISortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortContext)
		}
	}

	return tst
}

func (s *Cmd_declareFunContext) Sort(i int) ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_declareFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareFun(s)
	}
}

func (s *Cmd_declareFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareFun(s)
	}
}

func (s *Cmd_declareFunContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareFun(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareFun() (localctx ICmd_declareFunContext) {
	localctx = NewCmd_declareFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SMTLIBv2ParserRULE_cmd_declareFun)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(SMTLIBv2ParserCMD_DeclareFun)
	}
	{
		p.SetState(691)
		p.Symbol()
	}
	{
		p.SetState(692)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(693)
			p.Sort()
		}

		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(699)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(700)
		p.Sort()
	}

	return localctx
}

// ICmd_declareSortContext is an interface to support dynamic dispatch.
type ICmd_declareSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_declareSortContext differentiates from other interfaces.
	IsCmd_declareSortContext()
}

type Cmd_declareSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_declareSortContext() *Cmd_declareSortContext {
	var p = new(Cmd_declareSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort
	return p
}

func (*Cmd_declareSortContext) IsCmd_declareSortContext() {}

func NewCmd_declareSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_declareSortContext {
	var p = new(Cmd_declareSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_declareSort

	return p
}

func (s *Cmd_declareSortContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_declareSortContext) CMD_DeclareSort() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DeclareSort, 0)
}

func (s *Cmd_declareSortContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_declareSortContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_declareSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_declareSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_declareSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_declareSort(s)
	}
}

func (s *Cmd_declareSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_declareSort(s)
	}
}

func (s *Cmd_declareSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_declareSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_declareSort() (localctx ICmd_declareSortContext) {
	localctx = NewCmd_declareSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SMTLIBv2ParserRULE_cmd_declareSort)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(SMTLIBv2ParserCMD_DeclareSort)
	}
	{
		p.SetState(703)
		p.Symbol()
	}
	{
		p.SetState(704)
		p.Numeral()
	}

	return localctx
}

// ICmd_defineFunContext is an interface to support dynamic dispatch.
type ICmd_defineFunContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineFunContext differentiates from other interfaces.
	IsCmd_defineFunContext()
}

type Cmd_defineFunContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunContext() *Cmd_defineFunContext {
	var p = new(Cmd_defineFunContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun
	return p
}

func (*Cmd_defineFunContext) IsCmd_defineFunContext() {}

func NewCmd_defineFunContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunContext {
	var p = new(Cmd_defineFunContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFun

	return p
}

func (s *Cmd_defineFunContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunContext) CMD_DefineFun() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFun, 0)
}

func (s *Cmd_defineFunContext) Function_def() IFunction_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_defContext)
}

func (s *Cmd_defineFunContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFun(s)
	}
}

func (s *Cmd_defineFunContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFun(s)
	}
}

func (s *Cmd_defineFunContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFun(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFun() (localctx ICmd_defineFunContext) {
	localctx = NewCmd_defineFunContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SMTLIBv2ParserRULE_cmd_defineFun)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(SMTLIBv2ParserCMD_DefineFun)
	}
	{
		p.SetState(707)
		p.Function_def()
	}

	return localctx
}

// ICmd_defineFunRecContext is an interface to support dynamic dispatch.
type ICmd_defineFunRecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineFunRecContext differentiates from other interfaces.
	IsCmd_defineFunRecContext()
}

type Cmd_defineFunRecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunRecContext() *Cmd_defineFunRecContext {
	var p = new(Cmd_defineFunRecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec
	return p
}

func (*Cmd_defineFunRecContext) IsCmd_defineFunRecContext() {}

func NewCmd_defineFunRecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunRecContext {
	var p = new(Cmd_defineFunRecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunRec

	return p
}

func (s *Cmd_defineFunRecContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunRecContext) CMD_DefineFunRec() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFunRec, 0)
}

func (s *Cmd_defineFunRecContext) Function_def() IFunction_defContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_defContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_defContext)
}

func (s *Cmd_defineFunRecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunRecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunRecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFunRec(s)
	}
}

func (s *Cmd_defineFunRecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFunRec(s)
	}
}

func (s *Cmd_defineFunRecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFunRec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFunRec() (localctx ICmd_defineFunRecContext) {
	localctx = NewCmd_defineFunRecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SMTLIBv2ParserRULE_cmd_defineFunRec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(SMTLIBv2ParserCMD_DefineFunRec)
	}
	{
		p.SetState(710)
		p.Function_def()
	}

	return localctx
}

// ICmd_defineFunsRecContext is an interface to support dynamic dispatch.
type ICmd_defineFunsRecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineFunsRecContext differentiates from other interfaces.
	IsCmd_defineFunsRecContext()
}

type Cmd_defineFunsRecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineFunsRecContext() *Cmd_defineFunsRecContext {
	var p = new(Cmd_defineFunsRecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec
	return p
}

func (*Cmd_defineFunsRecContext) IsCmd_defineFunsRecContext() {}

func NewCmd_defineFunsRecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineFunsRecContext {
	var p = new(Cmd_defineFunsRecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineFunsRec

	return p
}

func (s *Cmd_defineFunsRecContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineFunsRecContext) CMD_DefineFunsRec() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineFunsRec, 0)
}

func (s *Cmd_defineFunsRecContext) AllParOpen() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParOpen)
}

func (s *Cmd_defineFunsRecContext) ParOpen(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, i)
}

func (s *Cmd_defineFunsRecContext) AllParClose() []antlr.TerminalNode {
	return s.GetTokens(SMTLIBv2ParserParClose)
}

func (s *Cmd_defineFunsRecContext) ParClose(i int) antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, i)
}

func (s *Cmd_defineFunsRecContext) AllFunction_dec() []IFunction_decContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_decContext)(nil)).Elem())
	var tst = make([]IFunction_decContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_decContext)
		}
	}

	return tst
}

func (s *Cmd_defineFunsRecContext) Function_dec(i int) IFunction_decContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_decContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_decContext)
}

func (s *Cmd_defineFunsRecContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Cmd_defineFunsRecContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_defineFunsRecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineFunsRecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineFunsRecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineFunsRec(s)
	}
}

func (s *Cmd_defineFunsRecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineFunsRec(s)
	}
}

func (s *Cmd_defineFunsRecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineFunsRec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineFunsRec() (localctx ICmd_defineFunsRecContext) {
	localctx = NewCmd_defineFunsRecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SMTLIBv2ParserRULE_cmd_defineFunsRec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Match(SMTLIBv2ParserCMD_DefineFunsRec)
	}
	{
		p.SetState(713)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(714)
			p.Function_dec()
		}

		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(719)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(720)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(721)
			p.Term()
		}

		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(726)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_defineSortContext is an interface to support dynamic dispatch.
type ICmd_defineSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_defineSortContext differentiates from other interfaces.
	IsCmd_defineSortContext()
}

type Cmd_defineSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_defineSortContext() *Cmd_defineSortContext {
	var p = new(Cmd_defineSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort
	return p
}

func (*Cmd_defineSortContext) IsCmd_defineSortContext() {}

func NewCmd_defineSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_defineSortContext {
	var p = new(Cmd_defineSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_defineSort

	return p
}

func (s *Cmd_defineSortContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_defineSortContext) CMD_DefineSort() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_DefineSort, 0)
}

func (s *Cmd_defineSortContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Cmd_defineSortContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_defineSortContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_defineSortContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_defineSortContext) Sort() ISortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortContext)
}

func (s *Cmd_defineSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_defineSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_defineSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_defineSort(s)
	}
}

func (s *Cmd_defineSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_defineSort(s)
	}
}

func (s *Cmd_defineSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_defineSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_defineSort() (localctx ICmd_defineSortContext) {
	localctx = NewCmd_defineSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SMTLIBv2ParserRULE_cmd_defineSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(SMTLIBv2ParserCMD_DefineSort)
	}
	{
		p.SetState(729)
		p.Symbol()
	}
	{
		p.SetState(730)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(731)
			p.Symbol()
		}

		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(737)
		p.Match(SMTLIBv2ParserParClose)
	}
	{
		p.SetState(738)
		p.Sort()
	}

	return localctx
}

// ICmd_echoContext is an interface to support dynamic dispatch.
type ICmd_echoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_echoContext differentiates from other interfaces.
	IsCmd_echoContext()
}

type Cmd_echoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_echoContext() *Cmd_echoContext {
	var p = new(Cmd_echoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo
	return p
}

func (*Cmd_echoContext) IsCmd_echoContext() {}

func NewCmd_echoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_echoContext {
	var p = new(Cmd_echoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_echo

	return p
}

func (s *Cmd_echoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_echoContext) CMD_Echo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Echo, 0)
}

func (s *Cmd_echoContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Cmd_echoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_echoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_echoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_echo(s)
	}
}

func (s *Cmd_echoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_echo(s)
	}
}

func (s *Cmd_echoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_echo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_echo() (localctx ICmd_echoContext) {
	localctx = NewCmd_echoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SMTLIBv2ParserRULE_cmd_echo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(SMTLIBv2ParserCMD_Echo)
	}
	{
		p.SetState(741)
		p.String_()
	}

	return localctx
}

// ICmd_exitContext is an interface to support dynamic dispatch.
type ICmd_exitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_exitContext differentiates from other interfaces.
	IsCmd_exitContext()
}

type Cmd_exitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_exitContext() *Cmd_exitContext {
	var p = new(Cmd_exitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit
	return p
}

func (*Cmd_exitContext) IsCmd_exitContext() {}

func NewCmd_exitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_exitContext {
	var p = new(Cmd_exitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_exit

	return p
}

func (s *Cmd_exitContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_exitContext) CMD_Exit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Exit, 0)
}

func (s *Cmd_exitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_exitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_exitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_exit(s)
	}
}

func (s *Cmd_exitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_exit(s)
	}
}

func (s *Cmd_exitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_exit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_exit() (localctx ICmd_exitContext) {
	localctx = NewCmd_exitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SMTLIBv2ParserRULE_cmd_exit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(SMTLIBv2ParserCMD_Exit)
	}

	return localctx
}

// ICmd_getAssertionsContext is an interface to support dynamic dispatch.
type ICmd_getAssertionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getAssertionsContext differentiates from other interfaces.
	IsCmd_getAssertionsContext()
}

type Cmd_getAssertionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getAssertionsContext() *Cmd_getAssertionsContext {
	var p = new(Cmd_getAssertionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions
	return p
}

func (*Cmd_getAssertionsContext) IsCmd_getAssertionsContext() {}

func NewCmd_getAssertionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getAssertionsContext {
	var p = new(Cmd_getAssertionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssertions

	return p
}

func (s *Cmd_getAssertionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getAssertionsContext) CMD_GetAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetAssertions, 0)
}

func (s *Cmd_getAssertionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getAssertionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getAssertionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getAssertions(s)
	}
}

func (s *Cmd_getAssertionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getAssertions(s)
	}
}

func (s *Cmd_getAssertionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getAssertions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getAssertions() (localctx ICmd_getAssertionsContext) {
	localctx = NewCmd_getAssertionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SMTLIBv2ParserRULE_cmd_getAssertions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(SMTLIBv2ParserCMD_GetAssertions)
	}

	return localctx
}

// ICmd_getAssignmentContext is an interface to support dynamic dispatch.
type ICmd_getAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getAssignmentContext differentiates from other interfaces.
	IsCmd_getAssignmentContext()
}

type Cmd_getAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getAssignmentContext() *Cmd_getAssignmentContext {
	var p = new(Cmd_getAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment
	return p
}

func (*Cmd_getAssignmentContext) IsCmd_getAssignmentContext() {}

func NewCmd_getAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getAssignmentContext {
	var p = new(Cmd_getAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getAssignment

	return p
}

func (s *Cmd_getAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getAssignmentContext) CMD_GetAssignment() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetAssignment, 0)
}

func (s *Cmd_getAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getAssignment(s)
	}
}

func (s *Cmd_getAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getAssignment(s)
	}
}

func (s *Cmd_getAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getAssignment() (localctx ICmd_getAssignmentContext) {
	localctx = NewCmd_getAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SMTLIBv2ParserRULE_cmd_getAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(SMTLIBv2ParserCMD_GetAssignment)
	}

	return localctx
}

// ICmd_getInfoContext is an interface to support dynamic dispatch.
type ICmd_getInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getInfoContext differentiates from other interfaces.
	IsCmd_getInfoContext()
}

type Cmd_getInfoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getInfoContext() *Cmd_getInfoContext {
	var p = new(Cmd_getInfoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo
	return p
}

func (*Cmd_getInfoContext) IsCmd_getInfoContext() {}

func NewCmd_getInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getInfoContext {
	var p = new(Cmd_getInfoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getInfo

	return p
}

func (s *Cmd_getInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getInfoContext) CMD_GetInfo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetInfo, 0)
}

func (s *Cmd_getInfoContext) Info_flag() IInfo_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfo_flagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfo_flagContext)
}

func (s *Cmd_getInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getInfo(s)
	}
}

func (s *Cmd_getInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getInfo(s)
	}
}

func (s *Cmd_getInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getInfo() (localctx ICmd_getInfoContext) {
	localctx = NewCmd_getInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SMTLIBv2ParserRULE_cmd_getInfo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(SMTLIBv2ParserCMD_GetInfo)
	}
	{
		p.SetState(750)
		p.Info_flag()
	}

	return localctx
}

// ICmd_getModelContext is an interface to support dynamic dispatch.
type ICmd_getModelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getModelContext differentiates from other interfaces.
	IsCmd_getModelContext()
}

type Cmd_getModelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getModelContext() *Cmd_getModelContext {
	var p = new(Cmd_getModelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel
	return p
}

func (*Cmd_getModelContext) IsCmd_getModelContext() {}

func NewCmd_getModelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getModelContext {
	var p = new(Cmd_getModelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getModel

	return p
}

func (s *Cmd_getModelContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getModelContext) CMD_GetModel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetModel, 0)
}

func (s *Cmd_getModelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getModelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getModelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getModel(s)
	}
}

func (s *Cmd_getModelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getModel(s)
	}
}

func (s *Cmd_getModelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getModel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getModel() (localctx ICmd_getModelContext) {
	localctx = NewCmd_getModelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SMTLIBv2ParserRULE_cmd_getModel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Match(SMTLIBv2ParserCMD_GetModel)
	}

	return localctx
}

// ICmd_getOptionContext is an interface to support dynamic dispatch.
type ICmd_getOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getOptionContext differentiates from other interfaces.
	IsCmd_getOptionContext()
}

type Cmd_getOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getOptionContext() *Cmd_getOptionContext {
	var p = new(Cmd_getOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption
	return p
}

func (*Cmd_getOptionContext) IsCmd_getOptionContext() {}

func NewCmd_getOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getOptionContext {
	var p = new(Cmd_getOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getOption

	return p
}

func (s *Cmd_getOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getOptionContext) CMD_GetOption() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetOption, 0)
}

func (s *Cmd_getOptionContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *Cmd_getOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getOption(s)
	}
}

func (s *Cmd_getOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getOption(s)
	}
}

func (s *Cmd_getOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getOption() (localctx ICmd_getOptionContext) {
	localctx = NewCmd_getOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SMTLIBv2ParserRULE_cmd_getOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(SMTLIBv2ParserCMD_GetOption)
	}
	{
		p.SetState(755)
		p.Keyword()
	}

	return localctx
}

// ICmd_getProofContext is an interface to support dynamic dispatch.
type ICmd_getProofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getProofContext differentiates from other interfaces.
	IsCmd_getProofContext()
}

type Cmd_getProofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getProofContext() *Cmd_getProofContext {
	var p = new(Cmd_getProofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof
	return p
}

func (*Cmd_getProofContext) IsCmd_getProofContext() {}

func NewCmd_getProofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getProofContext {
	var p = new(Cmd_getProofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getProof

	return p
}

func (s *Cmd_getProofContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getProofContext) CMD_GetProof() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetProof, 0)
}

func (s *Cmd_getProofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getProofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getProofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getProof(s)
	}
}

func (s *Cmd_getProofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getProof(s)
	}
}

func (s *Cmd_getProofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getProof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getProof() (localctx ICmd_getProofContext) {
	localctx = NewCmd_getProofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SMTLIBv2ParserRULE_cmd_getProof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(SMTLIBv2ParserCMD_GetProof)
	}

	return localctx
}

// ICmd_getUnsatAssumptionsContext is an interface to support dynamic dispatch.
type ICmd_getUnsatAssumptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getUnsatAssumptionsContext differentiates from other interfaces.
	IsCmd_getUnsatAssumptionsContext()
}

type Cmd_getUnsatAssumptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getUnsatAssumptionsContext() *Cmd_getUnsatAssumptionsContext {
	var p = new(Cmd_getUnsatAssumptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions
	return p
}

func (*Cmd_getUnsatAssumptionsContext) IsCmd_getUnsatAssumptionsContext() {}

func NewCmd_getUnsatAssumptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getUnsatAssumptionsContext {
	var p = new(Cmd_getUnsatAssumptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatAssumptions

	return p
}

func (s *Cmd_getUnsatAssumptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getUnsatAssumptionsContext) CMD_GetUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetUnsatAssumptions, 0)
}

func (s *Cmd_getUnsatAssumptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getUnsatAssumptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getUnsatAssumptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getUnsatAssumptions(s)
	}
}

func (s *Cmd_getUnsatAssumptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getUnsatAssumptions(s)
	}
}

func (s *Cmd_getUnsatAssumptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getUnsatAssumptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getUnsatAssumptions() (localctx ICmd_getUnsatAssumptionsContext) {
	localctx = NewCmd_getUnsatAssumptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SMTLIBv2ParserRULE_cmd_getUnsatAssumptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(SMTLIBv2ParserCMD_GetUnsatAssumptions)
	}

	return localctx
}

// ICmd_getUnsatCoreContext is an interface to support dynamic dispatch.
type ICmd_getUnsatCoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getUnsatCoreContext differentiates from other interfaces.
	IsCmd_getUnsatCoreContext()
}

type Cmd_getUnsatCoreContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getUnsatCoreContext() *Cmd_getUnsatCoreContext {
	var p = new(Cmd_getUnsatCoreContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore
	return p
}

func (*Cmd_getUnsatCoreContext) IsCmd_getUnsatCoreContext() {}

func NewCmd_getUnsatCoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getUnsatCoreContext {
	var p = new(Cmd_getUnsatCoreContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getUnsatCore

	return p
}

func (s *Cmd_getUnsatCoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getUnsatCoreContext) CMD_GetUnsatCore() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetUnsatCore, 0)
}

func (s *Cmd_getUnsatCoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getUnsatCoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getUnsatCoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getUnsatCore(s)
	}
}

func (s *Cmd_getUnsatCoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getUnsatCore(s)
	}
}

func (s *Cmd_getUnsatCoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getUnsatCore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getUnsatCore() (localctx ICmd_getUnsatCoreContext) {
	localctx = NewCmd_getUnsatCoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SMTLIBv2ParserRULE_cmd_getUnsatCore)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(SMTLIBv2ParserCMD_GetUnsatCore)
	}

	return localctx
}

// ICmd_getValueContext is an interface to support dynamic dispatch.
type ICmd_getValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_getValueContext differentiates from other interfaces.
	IsCmd_getValueContext()
}

type Cmd_getValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_getValueContext() *Cmd_getValueContext {
	var p = new(Cmd_getValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue
	return p
}

func (*Cmd_getValueContext) IsCmd_getValueContext() {}

func NewCmd_getValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_getValueContext {
	var p = new(Cmd_getValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_getValue

	return p
}

func (s *Cmd_getValueContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_getValueContext) CMD_GetValue() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_GetValue, 0)
}

func (s *Cmd_getValueContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Cmd_getValueContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Cmd_getValueContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Cmd_getValueContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Cmd_getValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_getValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_getValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_getValue(s)
	}
}

func (s *Cmd_getValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_getValue(s)
	}
}

func (s *Cmd_getValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_getValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_getValue() (localctx ICmd_getValueContext) {
	localctx = NewCmd_getValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SMTLIBv2ParserRULE_cmd_getValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Match(SMTLIBv2ParserCMD_GetValue)
	}
	{
		p.SetState(764)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(765)
			p.Term()
		}

		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(770)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICmd_popContext is an interface to support dynamic dispatch.
type ICmd_popContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_popContext differentiates from other interfaces.
	IsCmd_popContext()
}

type Cmd_popContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_popContext() *Cmd_popContext {
	var p = new(Cmd_popContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop
	return p
}

func (*Cmd_popContext) IsCmd_popContext() {}

func NewCmd_popContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_popContext {
	var p = new(Cmd_popContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_pop

	return p
}

func (s *Cmd_popContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_popContext) CMD_Pop() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Pop, 0)
}

func (s *Cmd_popContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_popContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_popContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_popContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_pop(s)
	}
}

func (s *Cmd_popContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_pop(s)
	}
}

func (s *Cmd_popContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_pop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_pop() (localctx ICmd_popContext) {
	localctx = NewCmd_popContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SMTLIBv2ParserRULE_cmd_pop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(SMTLIBv2ParserCMD_Pop)
	}
	{
		p.SetState(773)
		p.Numeral()
	}

	return localctx
}

// ICmd_pushContext is an interface to support dynamic dispatch.
type ICmd_pushContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_pushContext differentiates from other interfaces.
	IsCmd_pushContext()
}

type Cmd_pushContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_pushContext() *Cmd_pushContext {
	var p = new(Cmd_pushContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push
	return p
}

func (*Cmd_pushContext) IsCmd_pushContext() {}

func NewCmd_pushContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_pushContext {
	var p = new(Cmd_pushContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_push

	return p
}

func (s *Cmd_pushContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_pushContext) CMD_Push() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Push, 0)
}

func (s *Cmd_pushContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Cmd_pushContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_pushContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_pushContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_push(s)
	}
}

func (s *Cmd_pushContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_push(s)
	}
}

func (s *Cmd_pushContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_push(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_push() (localctx ICmd_pushContext) {
	localctx = NewCmd_pushContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SMTLIBv2ParserRULE_cmd_push)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(SMTLIBv2ParserCMD_Push)
	}
	{
		p.SetState(776)
		p.Numeral()
	}

	return localctx
}

// ICmd_resetContext is an interface to support dynamic dispatch.
type ICmd_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_resetContext differentiates from other interfaces.
	IsCmd_resetContext()
}

type Cmd_resetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_resetContext() *Cmd_resetContext {
	var p = new(Cmd_resetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset
	return p
}

func (*Cmd_resetContext) IsCmd_resetContext() {}

func NewCmd_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_resetContext {
	var p = new(Cmd_resetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_reset

	return p
}

func (s *Cmd_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_resetContext) CMD_Reset() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_Reset, 0)
}

func (s *Cmd_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_reset(s)
	}
}

func (s *Cmd_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_reset(s)
	}
}

func (s *Cmd_resetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_reset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_reset() (localctx ICmd_resetContext) {
	localctx = NewCmd_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SMTLIBv2ParserRULE_cmd_reset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Match(SMTLIBv2ParserCMD_Reset)
	}

	return localctx
}

// ICmd_resetAssertionsContext is an interface to support dynamic dispatch.
type ICmd_resetAssertionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_resetAssertionsContext differentiates from other interfaces.
	IsCmd_resetAssertionsContext()
}

type Cmd_resetAssertionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_resetAssertionsContext() *Cmd_resetAssertionsContext {
	var p = new(Cmd_resetAssertionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions
	return p
}

func (*Cmd_resetAssertionsContext) IsCmd_resetAssertionsContext() {}

func NewCmd_resetAssertionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_resetAssertionsContext {
	var p = new(Cmd_resetAssertionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_resetAssertions

	return p
}

func (s *Cmd_resetAssertionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_resetAssertionsContext) CMD_ResetAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_ResetAssertions, 0)
}

func (s *Cmd_resetAssertionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_resetAssertionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_resetAssertionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_resetAssertions(s)
	}
}

func (s *Cmd_resetAssertionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_resetAssertions(s)
	}
}

func (s *Cmd_resetAssertionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_resetAssertions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_resetAssertions() (localctx ICmd_resetAssertionsContext) {
	localctx = NewCmd_resetAssertionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SMTLIBv2ParserRULE_cmd_resetAssertions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(SMTLIBv2ParserCMD_ResetAssertions)
	}

	return localctx
}

// ICmd_setInfoContext is an interface to support dynamic dispatch.
type ICmd_setInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_setInfoContext differentiates from other interfaces.
	IsCmd_setInfoContext()
}

type Cmd_setInfoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setInfoContext() *Cmd_setInfoContext {
	var p = new(Cmd_setInfoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo
	return p
}

func (*Cmd_setInfoContext) IsCmd_setInfoContext() {}

func NewCmd_setInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setInfoContext {
	var p = new(Cmd_setInfoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setInfo

	return p
}

func (s *Cmd_setInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setInfoContext) CMD_SetInfo() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetInfo, 0)
}

func (s *Cmd_setInfoContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Cmd_setInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setInfo(s)
	}
}

func (s *Cmd_setInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setInfo(s)
	}
}

func (s *Cmd_setInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setInfo() (localctx ICmd_setInfoContext) {
	localctx = NewCmd_setInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SMTLIBv2ParserRULE_cmd_setInfo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(SMTLIBv2ParserCMD_SetInfo)
	}
	{
		p.SetState(783)
		p.Attribute()
	}

	return localctx
}

// ICmd_setLogicContext is an interface to support dynamic dispatch.
type ICmd_setLogicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_setLogicContext differentiates from other interfaces.
	IsCmd_setLogicContext()
}

type Cmd_setLogicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setLogicContext() *Cmd_setLogicContext {
	var p = new(Cmd_setLogicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic
	return p
}

func (*Cmd_setLogicContext) IsCmd_setLogicContext() {}

func NewCmd_setLogicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setLogicContext {
	var p = new(Cmd_setLogicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setLogic

	return p
}

func (s *Cmd_setLogicContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setLogicContext) CMD_SetLogic() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetLogic, 0)
}

func (s *Cmd_setLogicContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Cmd_setLogicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setLogicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setLogicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setLogic(s)
	}
}

func (s *Cmd_setLogicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setLogic(s)
	}
}

func (s *Cmd_setLogicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setLogic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setLogic() (localctx ICmd_setLogicContext) {
	localctx = NewCmd_setLogicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SMTLIBv2ParserRULE_cmd_setLogic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		p.Match(SMTLIBv2ParserCMD_SetLogic)
	}
	{
		p.SetState(786)
		p.Symbol()
	}

	return localctx
}

// ICmd_setOptionContext is an interface to support dynamic dispatch.
type ICmd_setOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmd_setOptionContext differentiates from other interfaces.
	IsCmd_setOptionContext()
}

type Cmd_setOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmd_setOptionContext() *Cmd_setOptionContext {
	var p = new(Cmd_setOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption
	return p
}

func (*Cmd_setOptionContext) IsCmd_setOptionContext() {}

func NewCmd_setOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmd_setOptionContext {
	var p = new(Cmd_setOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_cmd_setOption

	return p
}

func (s *Cmd_setOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmd_setOptionContext) CMD_SetOption() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserCMD_SetOption, 0)
}

func (s *Cmd_setOptionContext) Option() IOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionContext)
}

func (s *Cmd_setOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmd_setOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmd_setOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCmd_setOption(s)
	}
}

func (s *Cmd_setOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCmd_setOption(s)
	}
}

func (s *Cmd_setOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCmd_setOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Cmd_setOption() (localctx ICmd_setOptionContext) {
	localctx = NewCmd_setOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SMTLIBv2ParserRULE_cmd_setOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)
		p.Match(SMTLIBv2ParserCMD_SetOption)
	}
	{
		p.SetState(789)
		p.Option()
	}

	return localctx
}

// ICommandContext is an interface to support dynamic dispatch.
type ICommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandContext differentiates from other interfaces.
	IsCommandContext()
}

type CommandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandContext() *CommandContext {
	var p = new(CommandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_command
	return p
}

func (*CommandContext) IsCommandContext() {}

func NewCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandContext {
	var p = new(CommandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_command

	return p
}

func (s *CommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *CommandContext) Cmd_assert() ICmd_assertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_assertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_assertContext)
}

func (s *CommandContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *CommandContext) Cmd_checkSat() ICmd_checkSatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_checkSatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_checkSatContext)
}

func (s *CommandContext) Cmd_checkSatAssuming() ICmd_checkSatAssumingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_checkSatAssumingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_checkSatAssumingContext)
}

func (s *CommandContext) Cmd_declareConst() ICmd_declareConstContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareConstContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareConstContext)
}

func (s *CommandContext) Cmd_declareDatatype() ICmd_declareDatatypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareDatatypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareDatatypeContext)
}

func (s *CommandContext) Cmd_declareDatatypes() ICmd_declareDatatypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareDatatypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareDatatypesContext)
}

func (s *CommandContext) Cmd_declareFun() ICmd_declareFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareFunContext)
}

func (s *CommandContext) Cmd_declareSort() ICmd_declareSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_declareSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_declareSortContext)
}

func (s *CommandContext) Cmd_defineFun() ICmd_defineFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunContext)
}

func (s *CommandContext) Cmd_defineFunRec() ICmd_defineFunRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunRecContext)
}

func (s *CommandContext) Cmd_defineFunsRec() ICmd_defineFunsRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunsRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunsRecContext)
}

func (s *CommandContext) Cmd_defineSort() ICmd_defineSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineSortContext)
}

func (s *CommandContext) Cmd_echo() ICmd_echoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_echoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_echoContext)
}

func (s *CommandContext) Cmd_exit() ICmd_exitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_exitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_exitContext)
}

func (s *CommandContext) Cmd_getAssertions() ICmd_getAssertionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getAssertionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getAssertionsContext)
}

func (s *CommandContext) Cmd_getAssignment() ICmd_getAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getAssignmentContext)
}

func (s *CommandContext) Cmd_getInfo() ICmd_getInfoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getInfoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getInfoContext)
}

func (s *CommandContext) Cmd_getModel() ICmd_getModelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getModelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getModelContext)
}

func (s *CommandContext) Cmd_getOption() ICmd_getOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getOptionContext)
}

func (s *CommandContext) Cmd_getProof() ICmd_getProofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getProofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getProofContext)
}

func (s *CommandContext) Cmd_getUnsatAssumptions() ICmd_getUnsatAssumptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getUnsatAssumptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getUnsatAssumptionsContext)
}

func (s *CommandContext) Cmd_getUnsatCore() ICmd_getUnsatCoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getUnsatCoreContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getUnsatCoreContext)
}

func (s *CommandContext) Cmd_getValue() ICmd_getValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_getValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_getValueContext)
}

func (s *CommandContext) Cmd_pop() ICmd_popContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_popContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_popContext)
}

func (s *CommandContext) Cmd_push() ICmd_pushContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_pushContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_pushContext)
}

func (s *CommandContext) Cmd_reset() ICmd_resetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_resetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_resetContext)
}

func (s *CommandContext) Cmd_resetAssertions() ICmd_resetAssertionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_resetAssertionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_resetAssertionsContext)
}

func (s *CommandContext) Cmd_setInfo() ICmd_setInfoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_setInfoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_setInfoContext)
}

func (s *CommandContext) Cmd_setLogic() ICmd_setLogicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_setLogicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_setLogicContext)
}

func (s *CommandContext) Cmd_setOption() ICmd_setOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_setOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_setOptionContext)
}

func (s *CommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCommand(s)
	}
}

func (s *CommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCommand(s)
	}
}

func (s *CommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Command() (localctx ICommandContext) {
	localctx = NewCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SMTLIBv2ParserRULE_command)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(791)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(792)
			p.Cmd_assert()
		}
		{
			p.SetState(793)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(795)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(796)
			p.Cmd_checkSat()
		}
		{
			p.SetState(797)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(799)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(800)
			p.Cmd_checkSatAssuming()
		}
		{
			p.SetState(801)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(803)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(804)
			p.Cmd_declareConst()
		}
		{
			p.SetState(805)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(807)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(808)
			p.Cmd_declareDatatype()
		}
		{
			p.SetState(809)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(811)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(812)
			p.Cmd_declareDatatypes()
		}
		{
			p.SetState(813)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(815)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(816)
			p.Cmd_declareFun()
		}
		{
			p.SetState(817)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(819)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(820)
			p.Cmd_declareSort()
		}
		{
			p.SetState(821)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(823)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(824)
			p.Cmd_defineFun()
		}
		{
			p.SetState(825)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(827)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(828)
			p.Cmd_defineFunRec()
		}
		{
			p.SetState(829)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(831)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(832)
			p.Cmd_defineFunsRec()
		}
		{
			p.SetState(833)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(835)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(836)
			p.Cmd_defineSort()
		}
		{
			p.SetState(837)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(839)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(840)
			p.Cmd_echo()
		}
		{
			p.SetState(841)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(843)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(844)
			p.Cmd_exit()
		}
		{
			p.SetState(845)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(847)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(848)
			p.Cmd_getAssertions()
		}
		{
			p.SetState(849)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(851)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(852)
			p.Cmd_getAssignment()
		}
		{
			p.SetState(853)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(855)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(856)
			p.Cmd_getInfo()
		}
		{
			p.SetState(857)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(859)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(860)
			p.Cmd_getModel()
		}
		{
			p.SetState(861)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(863)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(864)
			p.Cmd_getOption()
		}
		{
			p.SetState(865)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(867)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(868)
			p.Cmd_getProof()
		}
		{
			p.SetState(869)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(871)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(872)
			p.Cmd_getUnsatAssumptions()
		}
		{
			p.SetState(873)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(875)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(876)
			p.Cmd_getUnsatCore()
		}
		{
			p.SetState(877)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(879)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(880)
			p.Cmd_getValue()
		}
		{
			p.SetState(881)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(883)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(884)
			p.Cmd_pop()
		}
		{
			p.SetState(885)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(887)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(888)
			p.Cmd_push()
		}
		{
			p.SetState(889)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(891)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(892)
			p.Cmd_reset()
		}
		{
			p.SetState(893)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(895)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(896)
			p.Cmd_resetAssertions()
		}
		{
			p.SetState(897)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(899)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(900)
			p.Cmd_setInfo()
		}
		{
			p.SetState(901)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(903)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(904)
			p.Cmd_setLogic()
		}
		{
			p.SetState(905)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(907)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(908)
			p.Cmd_setOption()
		}
		{
			p.SetState(909)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IB_valueContext is an interface to support dynamic dispatch.
type IB_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsB_valueContext differentiates from other interfaces.
	IsB_valueContext()
}

type B_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyB_valueContext() *B_valueContext {
	var p = new(B_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_b_value
	return p
}

func (*B_valueContext) IsB_valueContext() {}

func NewB_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *B_valueContext {
	var p = new(B_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_b_value

	return p
}

func (s *B_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *B_valueContext) PS_True() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_True, 0)
}

func (s *B_valueContext) PS_False() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_False, 0)
}

func (s *B_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *B_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *B_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterB_value(s)
	}
}

func (s *B_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitB_value(s)
	}
}

func (s *B_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitB_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) B_value() (localctx IB_valueContext) {
	localctx = NewB_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SMTLIBv2ParserRULE_b_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SMTLIBv2ParserPS_False || _la == SMTLIBv2ParserPS_True) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOptionContext is an interface to support dynamic dispatch.
type IOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionContext differentiates from other interfaces.
	IsOptionContext()
}

type OptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionContext() *OptionContext {
	var p = new(OptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_option
	return p
}

func (*OptionContext) IsOptionContext() {}

func NewOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionContext {
	var p = new(OptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_option

	return p
}

func (s *OptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionContext) PK_DiagnosticOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_DiagnosticOutputChannel, 0)
}

func (s *OptionContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *OptionContext) PK_GlobalDeclarations() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_GlobalDeclarations, 0)
}

func (s *OptionContext) B_value() IB_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IB_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IB_valueContext)
}

func (s *OptionContext) PK_InteractiveMode() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_InteractiveMode, 0)
}

func (s *OptionContext) PK_PrintSuccess() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_PrintSuccess, 0)
}

func (s *OptionContext) PK_ProduceAssertions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssertions, 0)
}

func (s *OptionContext) PK_ProduceAssignments() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceAssignments, 0)
}

func (s *OptionContext) PK_ProduceModels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceModels, 0)
}

func (s *OptionContext) PK_ProduceProofs() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceProofs, 0)
}

func (s *OptionContext) PK_ProduceUnsatAssumptions() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatAssumptions, 0)
}

func (s *OptionContext) PK_ProduceUnsatCores() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ProduceUnsatCores, 0)
}

func (s *OptionContext) PK_RandomSeed() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RandomSeed, 0)
}

func (s *OptionContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *OptionContext) PK_RegularOutputChannel() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_RegularOutputChannel, 0)
}

func (s *OptionContext) PK_ReproducibleResourceLimit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReproducibleResourceLimit, 0)
}

func (s *OptionContext) PK_Verbosity() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Verbosity, 0)
}

func (s *OptionContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *OptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterOption(s)
	}
}

func (s *OptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitOption(s)
	}
}

func (s *OptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Option() (localctx IOptionContext) {
	localctx = NewOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SMTLIBv2ParserRULE_option)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.Match(SMTLIBv2ParserPK_DiagnosticOutputChannel)
		}
		{
			p.SetState(916)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.Match(SMTLIBv2ParserPK_GlobalDeclarations)
		}
		{
			p.SetState(918)
			p.B_value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(919)
			p.Match(SMTLIBv2ParserPK_InteractiveMode)
		}
		{
			p.SetState(920)
			p.B_value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(921)
			p.Match(SMTLIBv2ParserPK_PrintSuccess)
		}
		{
			p.SetState(922)
			p.B_value()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(923)
			p.Match(SMTLIBv2ParserPK_ProduceAssertions)
		}
		{
			p.SetState(924)
			p.B_value()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(925)
			p.Match(SMTLIBv2ParserPK_ProduceAssignments)
		}
		{
			p.SetState(926)
			p.B_value()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(927)
			p.Match(SMTLIBv2ParserPK_ProduceModels)
		}
		{
			p.SetState(928)
			p.B_value()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(929)
			p.Match(SMTLIBv2ParserPK_ProduceProofs)
		}
		{
			p.SetState(930)
			p.B_value()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(931)
			p.Match(SMTLIBv2ParserPK_ProduceUnsatAssumptions)
		}
		{
			p.SetState(932)
			p.B_value()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(933)
			p.Match(SMTLIBv2ParserPK_ProduceUnsatCores)
		}
		{
			p.SetState(934)
			p.B_value()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(935)
			p.Match(SMTLIBv2ParserPK_RandomSeed)
		}
		{
			p.SetState(936)
			p.Numeral()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(937)
			p.Match(SMTLIBv2ParserPK_RegularOutputChannel)
		}
		{
			p.SetState(938)
			p.String_()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(939)
			p.Match(SMTLIBv2ParserPK_ReproducibleResourceLimit)
		}
		{
			p.SetState(940)
			p.Numeral()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(941)
			p.Match(SMTLIBv2ParserPK_Verbosity)
		}
		{
			p.SetState(942)
			p.Numeral()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(943)
			p.Attribute()
		}

	}

	return localctx
}

// IInfo_flagContext is an interface to support dynamic dispatch.
type IInfo_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfo_flagContext differentiates from other interfaces.
	IsInfo_flagContext()
}

type Info_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_flagContext() *Info_flagContext {
	var p = new(Info_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag
	return p
}

func (*Info_flagContext) IsInfo_flagContext() {}

func NewInfo_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_flagContext {
	var p = new(Info_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_info_flag

	return p
}

func (s *Info_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_flagContext) PK_AllStatistics() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AllStatistics, 0)
}

func (s *Info_flagContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *Info_flagContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *Info_flagContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *Info_flagContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *Info_flagContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *Info_flagContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *Info_flagContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *Info_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterInfo_flag(s)
	}
}

func (s *Info_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitInfo_flag(s)
	}
}

func (s *Info_flagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitInfo_flag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Info_flag() (localctx IInfo_flagContext) {
	localctx = NewInfo_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SMTLIBv2ParserRULE_info_flag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(946)
			p.Match(SMTLIBv2ParserPK_AllStatistics)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(947)
			p.Match(SMTLIBv2ParserPK_AssertionStackLevels)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(948)
			p.Match(SMTLIBv2ParserPK_Authors)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(949)
			p.Match(SMTLIBv2ParserPK_ErrorBehaviour)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(950)
			p.Match(SMTLIBv2ParserPK_Name)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(951)
			p.Match(SMTLIBv2ParserPK_ReasonUnknown)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(952)
			p.Match(SMTLIBv2ParserPK_Version)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(953)
			p.Keyword()
		}

	}

	return localctx
}

// IError_behaviourContext is an interface to support dynamic dispatch.
type IError_behaviourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_behaviourContext differentiates from other interfaces.
	IsError_behaviourContext()
}

type Error_behaviourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_behaviourContext() *Error_behaviourContext {
	var p = new(Error_behaviourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour
	return p
}

func (*Error_behaviourContext) IsError_behaviourContext() {}

func NewError_behaviourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_behaviourContext {
	var p = new(Error_behaviourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_error_behaviour

	return p
}

func (s *Error_behaviourContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_behaviourContext) PS_ImmediateExit() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ImmediateExit, 0)
}

func (s *Error_behaviourContext) PS_ContinuedExecution() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_ContinuedExecution, 0)
}

func (s *Error_behaviourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_behaviourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_behaviourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterError_behaviour(s)
	}
}

func (s *Error_behaviourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitError_behaviour(s)
	}
}

func (s *Error_behaviourContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitError_behaviour(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Error_behaviour() (localctx IError_behaviourContext) {
	localctx = NewError_behaviourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SMTLIBv2ParserRULE_error_behaviour)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SMTLIBv2ParserPS_ContinuedExecution || _la == SMTLIBv2ParserPS_ImmediateExit) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReason_unknownContext is an interface to support dynamic dispatch.
type IReason_unknownContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReason_unknownContext differentiates from other interfaces.
	IsReason_unknownContext()
}

type Reason_unknownContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReason_unknownContext() *Reason_unknownContext {
	var p = new(Reason_unknownContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown
	return p
}

func (*Reason_unknownContext) IsReason_unknownContext() {}

func NewReason_unknownContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reason_unknownContext {
	var p = new(Reason_unknownContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_reason_unknown

	return p
}

func (s *Reason_unknownContext) GetParser() antlr.Parser { return s.parser }

func (s *Reason_unknownContext) PS_Memout() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Memout, 0)
}

func (s *Reason_unknownContext) PS_Incomplete() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Incomplete, 0)
}

func (s *Reason_unknownContext) S_expr() IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Reason_unknownContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reason_unknownContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reason_unknownContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterReason_unknown(s)
	}
}

func (s *Reason_unknownContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitReason_unknown(s)
	}
}

func (s *Reason_unknownContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitReason_unknown(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Reason_unknown() (localctx IReason_unknownContext) {
	localctx = NewReason_unknownContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SMTLIBv2ParserRULE_reason_unknown)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(958)
			p.Match(SMTLIBv2ParserPS_Memout)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(959)
			p.Match(SMTLIBv2ParserPS_Incomplete)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(960)
			p.S_expr()
		}

	}

	return localctx
}

// IModel_responseContext is an interface to support dynamic dispatch.
type IModel_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModel_responseContext differentiates from other interfaces.
	IsModel_responseContext()
}

type Model_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModel_responseContext() *Model_responseContext {
	var p = new(Model_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_model_response
	return p
}

func (*Model_responseContext) IsModel_responseContext() {}

func NewModel_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Model_responseContext {
	var p = new(Model_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_model_response

	return p
}

func (s *Model_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Model_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Model_responseContext) Cmd_defineFun() ICmd_defineFunContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunContext)
}

func (s *Model_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Model_responseContext) Cmd_defineFunRec() ICmd_defineFunRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunRecContext)
}

func (s *Model_responseContext) Cmd_defineFunsRec() ICmd_defineFunsRecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmd_defineFunsRecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmd_defineFunsRecContext)
}

func (s *Model_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Model_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Model_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterModel_response(s)
	}
}

func (s *Model_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitModel_response(s)
	}
}

func (s *Model_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitModel_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Model_response() (localctx IModel_responseContext) {
	localctx = NewModel_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SMTLIBv2ParserRULE_model_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(963)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(964)
			p.Cmd_defineFun()
		}
		{
			p.SetState(965)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(967)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(968)
			p.Cmd_defineFunRec()
		}
		{
			p.SetState(969)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(971)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(972)
			p.Cmd_defineFunsRec()
		}
		{
			p.SetState(973)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IInfo_responseContext is an interface to support dynamic dispatch.
type IInfo_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfo_responseContext differentiates from other interfaces.
	IsInfo_responseContext()
}

type Info_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfo_responseContext() *Info_responseContext {
	var p = new(Info_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_info_response
	return p
}

func (*Info_responseContext) IsInfo_responseContext() {}

func NewInfo_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Info_responseContext {
	var p = new(Info_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_info_response

	return p
}

func (s *Info_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Info_responseContext) PK_AssertionStackLevels() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_AssertionStackLevels, 0)
}

func (s *Info_responseContext) Numeral() INumeralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeralContext)
}

func (s *Info_responseContext) PK_Authors() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Authors, 0)
}

func (s *Info_responseContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Info_responseContext) PK_ErrorBehaviour() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ErrorBehaviour, 0)
}

func (s *Info_responseContext) Error_behaviour() IError_behaviourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_behaviourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_behaviourContext)
}

func (s *Info_responseContext) PK_Name() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Name, 0)
}

func (s *Info_responseContext) PK_ReasonUnknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_ReasonUnknown, 0)
}

func (s *Info_responseContext) Reason_unknown() IReason_unknownContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReason_unknownContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReason_unknownContext)
}

func (s *Info_responseContext) PK_Version() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPK_Version, 0)
}

func (s *Info_responseContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Info_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Info_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Info_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterInfo_response(s)
	}
}

func (s *Info_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitInfo_response(s)
	}
}

func (s *Info_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitInfo_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Info_response() (localctx IInfo_responseContext) {
	localctx = NewInfo_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SMTLIBv2ParserRULE_info_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Match(SMTLIBv2ParserPK_AssertionStackLevels)
		}
		{
			p.SetState(978)
			p.Numeral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(979)
			p.Match(SMTLIBv2ParserPK_Authors)
		}
		{
			p.SetState(980)
			p.String_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(981)
			p.Match(SMTLIBv2ParserPK_ErrorBehaviour)
		}
		{
			p.SetState(982)
			p.Error_behaviour()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(983)
			p.Match(SMTLIBv2ParserPK_Name)
		}
		{
			p.SetState(984)
			p.String_()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(985)
			p.Match(SMTLIBv2ParserPK_ReasonUnknown)
		}
		{
			p.SetState(986)
			p.Reason_unknown()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(987)
			p.Match(SMTLIBv2ParserPK_Version)
		}
		{
			p.SetState(988)
			p.String_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(989)
			p.Attribute()
		}

	}

	return localctx
}

// IValuation_pairContext is an interface to support dynamic dispatch.
type IValuation_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuation_pairContext differentiates from other interfaces.
	IsValuation_pairContext()
}

type Valuation_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuation_pairContext() *Valuation_pairContext {
	var p = new(Valuation_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair
	return p
}

func (*Valuation_pairContext) IsValuation_pairContext() {}

func NewValuation_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Valuation_pairContext {
	var p = new(Valuation_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_valuation_pair

	return p
}

func (s *Valuation_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Valuation_pairContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Valuation_pairContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Valuation_pairContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Valuation_pairContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Valuation_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Valuation_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Valuation_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterValuation_pair(s)
	}
}

func (s *Valuation_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitValuation_pair(s)
	}
}

func (s *Valuation_pairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitValuation_pair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Valuation_pair() (localctx IValuation_pairContext) {
	localctx = NewValuation_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SMTLIBv2ParserRULE_valuation_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(993)
		p.Term()
	}
	{
		p.SetState(994)
		p.Term()
	}
	{
		p.SetState(995)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IT_valuation_pairContext is an interface to support dynamic dispatch.
type IT_valuation_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT_valuation_pairContext differentiates from other interfaces.
	IsT_valuation_pairContext()
}

type T_valuation_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_valuation_pairContext() *T_valuation_pairContext {
	var p = new(T_valuation_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair
	return p
}

func (*T_valuation_pairContext) IsT_valuation_pairContext() {}

func NewT_valuation_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_valuation_pairContext {
	var p = new(T_valuation_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_t_valuation_pair

	return p
}

func (s *T_valuation_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *T_valuation_pairContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *T_valuation_pairContext) Symbol() ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *T_valuation_pairContext) B_value() IB_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IB_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IB_valueContext)
}

func (s *T_valuation_pairContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *T_valuation_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_valuation_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_valuation_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterT_valuation_pair(s)
	}
}

func (s *T_valuation_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitT_valuation_pair(s)
	}
}

func (s *T_valuation_pairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitT_valuation_pair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) T_valuation_pair() (localctx IT_valuation_pairContext) {
	localctx = NewT_valuation_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SMTLIBv2ParserRULE_t_valuation_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(SMTLIBv2ParserParOpen)
	}
	{
		p.SetState(998)
		p.Symbol()
	}
	{
		p.SetState(999)
		p.B_value()
	}
	{
		p.SetState(1000)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ICheck_sat_responseContext is an interface to support dynamic dispatch.
type ICheck_sat_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheck_sat_responseContext differentiates from other interfaces.
	IsCheck_sat_responseContext()
}

type Check_sat_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheck_sat_responseContext() *Check_sat_responseContext {
	var p = new(Check_sat_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response
	return p
}

func (*Check_sat_responseContext) IsCheck_sat_responseContext() {}

func NewCheck_sat_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Check_sat_responseContext {
	var p = new(Check_sat_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_check_sat_response

	return p
}

func (s *Check_sat_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Check_sat_responseContext) PS_Sat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Sat, 0)
}

func (s *Check_sat_responseContext) PS_Unsat() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsat, 0)
}

func (s *Check_sat_responseContext) PS_Unknown() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unknown, 0)
}

func (s *Check_sat_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Check_sat_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Check_sat_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterCheck_sat_response(s)
	}
}

func (s *Check_sat_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitCheck_sat_response(s)
	}
}

func (s *Check_sat_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitCheck_sat_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Check_sat_response() (localctx ICheck_sat_responseContext) {
	localctx = NewCheck_sat_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SMTLIBv2ParserRULE_check_sat_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEcho_responseContext is an interface to support dynamic dispatch.
type IEcho_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEcho_responseContext differentiates from other interfaces.
	IsEcho_responseContext()
}

type Echo_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEcho_responseContext() *Echo_responseContext {
	var p = new(Echo_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response
	return p
}

func (*Echo_responseContext) IsEcho_responseContext() {}

func NewEcho_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Echo_responseContext {
	var p = new(Echo_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_echo_response

	return p
}

func (s *Echo_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Echo_responseContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *Echo_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Echo_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Echo_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterEcho_response(s)
	}
}

func (s *Echo_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitEcho_response(s)
	}
}

func (s *Echo_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitEcho_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Echo_response() (localctx IEcho_responseContext) {
	localctx = NewEcho_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SMTLIBv2ParserRULE_echo_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.String_()
	}

	return localctx
}

// IGet_assertions_responseContext is an interface to support dynamic dispatch.
type IGet_assertions_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_assertions_responseContext differentiates from other interfaces.
	IsGet_assertions_responseContext()
}

type Get_assertions_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_assertions_responseContext() *Get_assertions_responseContext {
	var p = new(Get_assertions_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response
	return p
}

func (*Get_assertions_responseContext) IsGet_assertions_responseContext() {}

func NewGet_assertions_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_assertions_responseContext {
	var p = new(Get_assertions_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_assertions_response

	return p
}

func (s *Get_assertions_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_assertions_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_assertions_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_assertions_responseContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Get_assertions_responseContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Get_assertions_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_assertions_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_assertions_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_assertions_response(s)
	}
}

func (s *Get_assertions_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_assertions_response(s)
	}
}

func (s *Get_assertions_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_assertions_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_assertions_response() (localctx IGet_assertions_responseContext) {
	localctx = NewGet_assertions_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SMTLIBv2ParserRULE_get_assertions_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserParOpen)|(1<<SMTLIBv2ParserString_)|(1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(SMTLIBv2ParserNumeral-66))|(1<<(SMTLIBv2ParserBinary-66))|(1<<(SMTLIBv2ParserHexDecimal-66))|(1<<(SMTLIBv2ParserDecimal-66)))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1007)
			p.Term()
		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1013)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_assignment_responseContext is an interface to support dynamic dispatch.
type IGet_assignment_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_assignment_responseContext differentiates from other interfaces.
	IsGet_assignment_responseContext()
}

type Get_assignment_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_assignment_responseContext() *Get_assignment_responseContext {
	var p = new(Get_assignment_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response
	return p
}

func (*Get_assignment_responseContext) IsGet_assignment_responseContext() {}

func NewGet_assignment_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_assignment_responseContext {
	var p = new(Get_assignment_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_assignment_response

	return p
}

func (s *Get_assignment_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_assignment_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_assignment_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_assignment_responseContext) AllT_valuation_pair() []IT_valuation_pairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IT_valuation_pairContext)(nil)).Elem())
	var tst = make([]IT_valuation_pairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IT_valuation_pairContext)
		}
	}

	return tst
}

func (s *Get_assignment_responseContext) T_valuation_pair(i int) IT_valuation_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT_valuation_pairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IT_valuation_pairContext)
}

func (s *Get_assignment_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_assignment_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_assignment_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_assignment_response(s)
	}
}

func (s *Get_assignment_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_assignment_response(s)
	}
}

func (s *Get_assignment_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_assignment_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_assignment_response() (localctx IGet_assignment_responseContext) {
	localctx = NewGet_assignment_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SMTLIBv2ParserRULE_get_assignment_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(1016)
			p.T_valuation_pair()
		}

		p.SetState(1021)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1022)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_info_responseContext is an interface to support dynamic dispatch.
type IGet_info_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_info_responseContext differentiates from other interfaces.
	IsGet_info_responseContext()
}

type Get_info_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_info_responseContext() *Get_info_responseContext {
	var p = new(Get_info_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response
	return p
}

func (*Get_info_responseContext) IsGet_info_responseContext() {}

func NewGet_info_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_info_responseContext {
	var p = new(Get_info_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_info_response

	return p
}

func (s *Get_info_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_info_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_info_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_info_responseContext) AllInfo_response() []IInfo_responseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInfo_responseContext)(nil)).Elem())
	var tst = make([]IInfo_responseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInfo_responseContext)
		}
	}

	return tst
}

func (s *Get_info_responseContext) Info_response(i int) IInfo_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfo_responseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInfo_responseContext)
}

func (s *Get_info_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_info_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_info_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_info_response(s)
	}
}

func (s *Get_info_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_info_response(s)
	}
}

func (s *Get_info_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_info_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_info_response() (localctx IGet_info_responseContext) {
	localctx = NewGet_info_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SMTLIBv2ParserRULE_get_info_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SMTLIBv2ParserColon-70))|(1<<(SMTLIBv2ParserPK_AllStatistics-70))|(1<<(SMTLIBv2ParserPK_AssertionStackLevels-70))|(1<<(SMTLIBv2ParserPK_Authors-70))|(1<<(SMTLIBv2ParserPK_Category-70))|(1<<(SMTLIBv2ParserPK_Chainable-70))|(1<<(SMTLIBv2ParserPK_Definition-70))|(1<<(SMTLIBv2ParserPK_DiagnosticOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ErrorBehaviour-70))|(1<<(SMTLIBv2ParserPK_Extension-70))|(1<<(SMTLIBv2ParserPK_Funs-70))|(1<<(SMTLIBv2ParserPK_FunsDescription-70))|(1<<(SMTLIBv2ParserPK_GlobalDeclarations-70))|(1<<(SMTLIBv2ParserPK_InteractiveMode-70))|(1<<(SMTLIBv2ParserPK_Language-70))|(1<<(SMTLIBv2ParserPK_LeftAssoc-70))|(1<<(SMTLIBv2ParserPK_License-70))|(1<<(SMTLIBv2ParserPK_Named-70))|(1<<(SMTLIBv2ParserPK_Name-70))|(1<<(SMTLIBv2ParserPK_Notes-70))|(1<<(SMTLIBv2ParserPK_Pattern-70))|(1<<(SMTLIBv2ParserPK_PrintSuccess-70))|(1<<(SMTLIBv2ParserPK_ProduceAssertions-70))|(1<<(SMTLIBv2ParserPK_ProduceAssignments-70))|(1<<(SMTLIBv2ParserPK_ProduceModels-70))|(1<<(SMTLIBv2ParserPK_ProduceProofs-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatAssumptions-70))|(1<<(SMTLIBv2ParserPK_ProduceUnsatCores-70))|(1<<(SMTLIBv2ParserPK_RandomSeed-70))|(1<<(SMTLIBv2ParserPK_ReasonUnknown-70))|(1<<(SMTLIBv2ParserPK_RegularOutputChannel-70))|(1<<(SMTLIBv2ParserPK_ReproducibleResourceLimit-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(SMTLIBv2ParserPK_RightAssoc-102))|(1<<(SMTLIBv2ParserPK_SmtLibVersion-102))|(1<<(SMTLIBv2ParserPK_Sorts-102))|(1<<(SMTLIBv2ParserPK_SortsDescription-102))|(1<<(SMTLIBv2ParserPK_Source-102))|(1<<(SMTLIBv2ParserPK_Status-102))|(1<<(SMTLIBv2ParserPK_Theories-102))|(1<<(SMTLIBv2ParserPK_Values-102))|(1<<(SMTLIBv2ParserPK_Verbosity-102))|(1<<(SMTLIBv2ParserPK_Version-102)))) != 0) {
		{
			p.SetState(1025)
			p.Info_response()
		}

		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1030)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_model_responseContext is an interface to support dynamic dispatch.
type IGet_model_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_model_responseContext differentiates from other interfaces.
	IsGet_model_responseContext()
}

type Get_model_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_model_responseContext() *Get_model_responseContext {
	var p = new(Get_model_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response
	return p
}

func (*Get_model_responseContext) IsGet_model_responseContext() {}

func NewGet_model_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_model_responseContext {
	var p = new(Get_model_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_model_response

	return p
}

func (s *Get_model_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_model_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_model_responseContext) RS_Model() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserRS_Model, 0)
}

func (s *Get_model_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_model_responseContext) AllModel_response() []IModel_responseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModel_responseContext)(nil)).Elem())
	var tst = make([]IModel_responseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModel_responseContext)
		}
	}

	return tst
}

func (s *Get_model_responseContext) Model_response(i int) IModel_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModel_responseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModel_responseContext)
}

func (s *Get_model_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_model_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_model_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_model_response(s)
	}
}

func (s *Get_model_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_model_response(s)
	}
}

func (s *Get_model_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_model_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_model_response() (localctx IGet_model_responseContext) {
	localctx = NewGet_model_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SMTLIBv2ParserRULE_get_model_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1032)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(1033)
			p.Match(SMTLIBv2ParserRS_Model)
		}
		p.SetState(1037)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(1034)
				p.Model_response()
			}

			p.SetState(1039)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1040)
			p.Match(SMTLIBv2ParserParClose)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1041)
			p.Match(SMTLIBv2ParserParOpen)
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SMTLIBv2ParserParOpen {
			{
				p.SetState(1042)
				p.Model_response()
			}

			p.SetState(1047)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1048)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}

// IGet_option_responseContext is an interface to support dynamic dispatch.
type IGet_option_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_option_responseContext differentiates from other interfaces.
	IsGet_option_responseContext()
}

type Get_option_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_option_responseContext() *Get_option_responseContext {
	var p = new(Get_option_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response
	return p
}

func (*Get_option_responseContext) IsGet_option_responseContext() {}

func NewGet_option_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_option_responseContext {
	var p = new(Get_option_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_option_response

	return p
}

func (s *Get_option_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_option_responseContext) Attribute_value() IAttribute_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *Get_option_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_option_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_option_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_option_response(s)
	}
}

func (s *Get_option_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_option_response(s)
	}
}

func (s *Get_option_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_option_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_option_response() (localctx IGet_option_responseContext) {
	localctx = NewGet_option_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SMTLIBv2ParserRULE_get_option_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Attribute_value()
	}

	return localctx
}

// IGet_proof_responseContext is an interface to support dynamic dispatch.
type IGet_proof_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_proof_responseContext differentiates from other interfaces.
	IsGet_proof_responseContext()
}

type Get_proof_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_proof_responseContext() *Get_proof_responseContext {
	var p = new(Get_proof_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response
	return p
}

func (*Get_proof_responseContext) IsGet_proof_responseContext() {}

func NewGet_proof_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_proof_responseContext {
	var p = new(Get_proof_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_proof_response

	return p
}

func (s *Get_proof_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_proof_responseContext) S_expr() IS_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IS_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IS_exprContext)
}

func (s *Get_proof_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_proof_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_proof_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_proof_response(s)
	}
}

func (s *Get_proof_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_proof_response(s)
	}
}

func (s *Get_proof_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_proof_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_proof_response() (localctx IGet_proof_responseContext) {
	localctx = NewGet_proof_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SMTLIBv2ParserRULE_get_proof_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.S_expr()
	}

	return localctx
}

// IGet_unsat_assump_responseContext is an interface to support dynamic dispatch.
type IGet_unsat_assump_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_unsat_assump_responseContext differentiates from other interfaces.
	IsGet_unsat_assump_responseContext()
}

type Get_unsat_assump_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_unsat_assump_responseContext() *Get_unsat_assump_responseContext {
	var p = new(Get_unsat_assump_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response
	return p
}

func (*Get_unsat_assump_responseContext) IsGet_unsat_assump_responseContext() {}

func NewGet_unsat_assump_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_unsat_assump_responseContext {
	var p = new(Get_unsat_assump_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_assump_response

	return p
}

func (s *Get_unsat_assump_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_unsat_assump_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_unsat_assump_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_unsat_assump_responseContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Get_unsat_assump_responseContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Get_unsat_assump_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_unsat_assump_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_unsat_assump_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_unsat_assump_response(s)
	}
}

func (s *Get_unsat_assump_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_unsat_assump_response(s)
	}
}

func (s *Get_unsat_assump_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_unsat_assump_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_unsat_assump_response() (localctx IGet_unsat_assump_responseContext) {
	localctx = NewGet_unsat_assump_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SMTLIBv2ParserRULE_get_unsat_assump_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1056)
			p.Symbol()
		}

		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1062)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_unsat_core_responseContext is an interface to support dynamic dispatch.
type IGet_unsat_core_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_unsat_core_responseContext differentiates from other interfaces.
	IsGet_unsat_core_responseContext()
}

type Get_unsat_core_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_unsat_core_responseContext() *Get_unsat_core_responseContext {
	var p = new(Get_unsat_core_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response
	return p
}

func (*Get_unsat_core_responseContext) IsGet_unsat_core_responseContext() {}

func NewGet_unsat_core_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_unsat_core_responseContext {
	var p = new(Get_unsat_core_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_unsat_core_response

	return p
}

func (s *Get_unsat_core_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_unsat_core_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_unsat_core_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_unsat_core_responseContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *Get_unsat_core_responseContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *Get_unsat_core_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_unsat_core_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_unsat_core_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_unsat_core_response(s)
	}
}

func (s *Get_unsat_core_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_unsat_core_response(s)
	}
}

func (s *Get_unsat_core_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_unsat_core_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_unsat_core_response() (localctx IGet_unsat_core_responseContext) {
	localctx = NewGet_unsat_core_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SMTLIBv2ParserRULE_get_unsat_core_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1064)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SMTLIBv2ParserQuotedSymbol)|(1<<SMTLIBv2ParserPS_Not)|(1<<SMTLIBv2ParserPS_Bool)|(1<<SMTLIBv2ParserPS_ContinuedExecution)|(1<<SMTLIBv2ParserPS_Error)|(1<<SMTLIBv2ParserPS_False)|(1<<SMTLIBv2ParserPS_ImmediateExit)|(1<<SMTLIBv2ParserPS_Incomplete)|(1<<SMTLIBv2ParserPS_Logic)|(1<<SMTLIBv2ParserPS_Memout)|(1<<SMTLIBv2ParserPS_Sat)|(1<<SMTLIBv2ParserPS_Success)|(1<<SMTLIBv2ParserPS_Theory)|(1<<SMTLIBv2ParserPS_True)|(1<<SMTLIBv2ParserPS_Unknown)|(1<<SMTLIBv2ParserPS_Unsupported)|(1<<SMTLIBv2ParserPS_Unsat))) != 0) || _la == SMTLIBv2ParserUndefinedSymbol {
		{
			p.SetState(1065)
			p.Symbol()
		}

		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1071)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// IGet_value_responseContext is an interface to support dynamic dispatch.
type IGet_value_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_value_responseContext differentiates from other interfaces.
	IsGet_value_responseContext()
}

type Get_value_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_value_responseContext() *Get_value_responseContext {
	var p = new(Get_value_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response
	return p
}

func (*Get_value_responseContext) IsGet_value_responseContext() {}

func NewGet_value_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_value_responseContext {
	var p = new(Get_value_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_get_value_response

	return p
}

func (s *Get_value_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_value_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *Get_value_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *Get_value_responseContext) AllValuation_pair() []IValuation_pairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValuation_pairContext)(nil)).Elem())
	var tst = make([]IValuation_pairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValuation_pairContext)
		}
	}

	return tst
}

func (s *Get_value_responseContext) Valuation_pair(i int) IValuation_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuation_pairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValuation_pairContext)
}

func (s *Get_value_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_value_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_value_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGet_value_response(s)
	}
}

func (s *Get_value_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGet_value_response(s)
	}
}

func (s *Get_value_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGet_value_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Get_value_response() (localctx IGet_value_responseContext) {
	localctx = NewGet_value_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SMTLIBv2ParserRULE_get_value_response)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(SMTLIBv2ParserParOpen)
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SMTLIBv2ParserParOpen {
		{
			p.SetState(1074)
			p.Valuation_pair()
		}

		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1079)
		p.Match(SMTLIBv2ParserParClose)
	}

	return localctx
}

// ISpecific_success_responseContext is an interface to support dynamic dispatch.
type ISpecific_success_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecific_success_responseContext differentiates from other interfaces.
	IsSpecific_success_responseContext()
}

type Specific_success_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecific_success_responseContext() *Specific_success_responseContext {
	var p = new(Specific_success_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response
	return p
}

func (*Specific_success_responseContext) IsSpecific_success_responseContext() {}

func NewSpecific_success_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specific_success_responseContext {
	var p = new(Specific_success_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_specific_success_response

	return p
}

func (s *Specific_success_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *Specific_success_responseContext) Check_sat_response() ICheck_sat_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheck_sat_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheck_sat_responseContext)
}

func (s *Specific_success_responseContext) Echo_response() IEcho_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEcho_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEcho_responseContext)
}

func (s *Specific_success_responseContext) Get_assertions_response() IGet_assertions_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_assertions_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_assertions_responseContext)
}

func (s *Specific_success_responseContext) Get_assignment_response() IGet_assignment_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_assignment_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_assignment_responseContext)
}

func (s *Specific_success_responseContext) Get_info_response() IGet_info_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_info_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_info_responseContext)
}

func (s *Specific_success_responseContext) Get_model_response() IGet_model_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_model_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_model_responseContext)
}

func (s *Specific_success_responseContext) Get_option_response() IGet_option_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_option_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_option_responseContext)
}

func (s *Specific_success_responseContext) Get_proof_response() IGet_proof_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_proof_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_proof_responseContext)
}

func (s *Specific_success_responseContext) Get_unsat_assump_response() IGet_unsat_assump_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_unsat_assump_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_unsat_assump_responseContext)
}

func (s *Specific_success_responseContext) Get_unsat_core_response() IGet_unsat_core_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_unsat_core_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_unsat_core_responseContext)
}

func (s *Specific_success_responseContext) Get_value_response() IGet_value_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_value_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_value_responseContext)
}

func (s *Specific_success_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specific_success_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specific_success_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterSpecific_success_response(s)
	}
}

func (s *Specific_success_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitSpecific_success_response(s)
	}
}

func (s *Specific_success_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitSpecific_success_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) Specific_success_response() (localctx ISpecific_success_responseContext) {
	localctx = NewSpecific_success_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SMTLIBv2ParserRULE_specific_success_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1081)
			p.Check_sat_response()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1082)
			p.Echo_response()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1083)
			p.Get_assertions_response()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1084)
			p.Get_assignment_response()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1085)
			p.Get_info_response()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1086)
			p.Get_model_response()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1087)
			p.Get_option_response()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1088)
			p.Get_proof_response()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1089)
			p.Get_unsat_assump_response()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1090)
			p.Get_unsat_core_response()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1091)
			p.Get_value_response()
		}

	}

	return localctx
}

// IGeneral_responseContext is an interface to support dynamic dispatch.
type IGeneral_responseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneral_responseContext differentiates from other interfaces.
	IsGeneral_responseContext()
}

type General_responseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneral_responseContext() *General_responseContext {
	var p = new(General_responseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SMTLIBv2ParserRULE_general_response
	return p
}

func (*General_responseContext) IsGeneral_responseContext() {}

func NewGeneral_responseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *General_responseContext {
	var p = new(General_responseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SMTLIBv2ParserRULE_general_response

	return p
}

func (s *General_responseContext) GetParser() antlr.Parser { return s.parser }

func (s *General_responseContext) PS_Success() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Success, 0)
}

func (s *General_responseContext) Specific_success_response() ISpecific_success_responseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecific_success_responseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecific_success_responseContext)
}

func (s *General_responseContext) PS_Unsupported() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Unsupported, 0)
}

func (s *General_responseContext) ParOpen() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParOpen, 0)
}

func (s *General_responseContext) PS_Error() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserPS_Error, 0)
}

func (s *General_responseContext) String_() IString_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_Context)
}

func (s *General_responseContext) ParClose() antlr.TerminalNode {
	return s.GetToken(SMTLIBv2ParserParClose, 0)
}

func (s *General_responseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *General_responseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *General_responseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.EnterGeneral_response(s)
	}
}

func (s *General_responseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SMTLIBv2Listener); ok {
		listenerT.ExitGeneral_response(s)
	}
}

func (s *General_responseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SMTLIBv2Visitor:
		return t.VisitGeneral_response(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SMTLIBv2Parser) General_response() (localctx IGeneral_responseContext) {
	localctx = NewGeneral_responseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SMTLIBv2ParserRULE_general_response)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1094)
			p.Match(SMTLIBv2ParserPS_Success)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1095)
			p.Specific_success_response()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1096)
			p.Match(SMTLIBv2ParserPS_Unsupported)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1097)
			p.Match(SMTLIBv2ParserParOpen)
		}
		{
			p.SetState(1098)
			p.Match(SMTLIBv2ParserPS_Error)
		}
		{
			p.SetState(1099)
			p.String_()
		}
		{
			p.SetState(1100)
			p.Match(SMTLIBv2ParserParClose)
		}

	}

	return localctx
}
